// *************************************************************************
//
// This File Is Automatically Generated by the StarBusIDL-to-C++ Compiler !
//
// Copyright (c) 2003
// Network Information Security Institute,Computer College,NUDT.
// ChangSha,Hunan,PRC
//
// All Rights Reserved
//
// *************************************************************************

// Version: 5.0.0

#include <STAR/CORBAClient.h>
#include <STAR/CORBAServer.h>
#include <Dinner.h>

namespace Dinner
{

STAR::TypeCodeConst _tc_ForkNotAvailable(
"01f112001600000044000000010000002000000049444c3a44696e6e65722f466f726b4e6f744"
"17661696c61626c653a312e300011000000466f726b4e6f74417661696c61626c65002c006300"
"000000"
);

STAR::TypeCodeConst _tc_NotTheEater(
"01ee1200160000003800000001ee12001b00000049444c3a44696e6e65722f4e6f74546865456"
"17465723a312e3000000c0000004e6f7454686545617465720000000000"
);

STAR::TypeCodeConst _tc_Fork(
"01f712000e0000002500000001ee12001400000049444c3a44696e6e65722f466f726b3a312e3"
"00005000000466f726b00"
);

STAR::TypeCodeConst _tc_Named(
"01f712000e0000002a00000001ee12001500000049444c3a44696e6e65722f4e616d65643a312"
"e3000a7a000060000004e616d656400"
);

STAR::TypeCodeConst _tc_Philosopher(
"01f712000e0000003400000001ee12001b00000049444c3a44696e6e65722f5068696c6f736f7"
"06865723a312e3000ff0c0000005068696c6f736f7068657200"
);

STAR::TypeCodeConst _tc_Cutlery(
"01f712000e0000002c00000001ee12001700000049444c3a44696e6e65722f4375746c6572793"
"a312e300000080000004375746c65727900"
);

STAR::TypeCodeConst _tc_PhilosopherHomeExplicit(
"01f712000e0000004c00000001ee12002700000049444c3a44696e6e65722f5068696c6f736f7"
"0686572486f6d654578706c696369743a312e300000180000005068696c6f736f70686572486f"
"6d654578706c6963697400"
);

STAR::TypeCodeConst _tc_PhilosopherHomeImplicit(
"01f712000e0000004c00000001ee12002700000049444c3a44696e6e65722f5068696c6f736f7"
"0686572486f6d65496d706c696369743a312e300000180000005068696c6f736f70686572486f"
"6d65496d706c6963697400"
);

STAR::TypeCodeConst _tc_PhilosopherHome(
"01f712000e0000003c00000001ee12001f00000049444c3a44696e6e65722f5068696c6f736f7"
"0686572486f6d653a312e300000100000005068696c6f736f70686572486f6d6500"
);

STAR::TypeCodeConst _tc_CutleryHomeExplicit(
"01f712000e0000004400000001ee12002300000049444c3a44696e6e65722f4375746c6572794"
"86f6d654578706c696369743a312e300000140000004375746c657279486f6d654578706c6963"
"697400"
);

STAR::TypeCodeConst _tc_CutleryHomeImplicit(
"01f712000e0000004400000001ee12002300000049444c3a44696e6e65722f4375746c6572794"
"86f6d65496d706c696369743a312e300000140000004375746c657279486f6d65496d706c6963"
"697400"
);

STAR::TypeCodeConst _tc_CutleryHome(
"01f712000e0000003400000001ee12001b00000049444c3a44696e6e65722f4375746c6572794"
"86f6d653a312e3000ff0c0000004375746c657279486f6d6500"
);

} // End of namespace Dinner

//
// Exception declare ::Dinner::ForkNotAvailable
//
Dinner::ForkNotAvailable::ForkNotAvailable(const ForkNotAvailable& _star_a)
    : CORBA::UserException(_star_a)
{
}

Dinner::ForkNotAvailable&
Dinner::ForkNotAvailable::operator=(const ForkNotAvailable&)
{
    return *this;
}

Dinner::ForkNotAvailable*
Dinner::ForkNotAvailable::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<ForkNotAvailable*>(p);
}

const Dinner::ForkNotAvailable*
Dinner::ForkNotAvailable::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const ForkNotAvailable*>(p);
}

const char*
Dinner::ForkNotAvailable::_name() const
{
    return "ForkNotAvailable";
}

const char*
Dinner::ForkNotAvailable::_rep_id() const
{
    return "IDL:Dinner/ForkNotAvailable:1.0";
}

char*
Dinner::ForkNotAvailable::_to_string() const
{
    return _STAR_defaultToString("Dinner::ForkNotAvailable");
}

CORBA::Exception*
Dinner::ForkNotAvailable::_STAR_clone() const
{
    return new ForkNotAvailable(*this);
}

void
Dinner::ForkNotAvailable::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
Dinner::ForkNotAvailable::_STAR_unmarshal(ForkNotAvailable&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:Dinner/ForkNotAvailable:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, Dinner::ForkNotAvailable* v)
{
    static const STAR::Info< Dinner::ForkNotAvailable > info;
    any.replace(Dinner::_tc_ForkNotAvailable, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const Dinner::ForkNotAvailable& v)
{
    any <<= new Dinner::ForkNotAvailable(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const Dinner::ForkNotAvailable*& v)
{
    if(any.check_type(Dinner::_tc_ForkNotAvailable))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            Dinner::ForkNotAvailable* val = new Dinner::ForkNotAvailable;
            Dinner::ForkNotAvailable::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (Dinner::ForkNotAvailable*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::Dinner::NotTheEater
//
Dinner::NotTheEater::NotTheEater(const NotTheEater& _star_a)
    : CORBA::UserException(_star_a)
{
}

Dinner::NotTheEater&
Dinner::NotTheEater::operator=(const NotTheEater&)
{
    return *this;
}

Dinner::NotTheEater*
Dinner::NotTheEater::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<NotTheEater*>(p);
}

const Dinner::NotTheEater*
Dinner::NotTheEater::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const NotTheEater*>(p);
}

const char*
Dinner::NotTheEater::_name() const
{
    return "NotTheEater";
}

const char*
Dinner::NotTheEater::_rep_id() const
{
    return "IDL:Dinner/NotTheEater:1.0";
}

char*
Dinner::NotTheEater::_to_string() const
{
    return _STAR_defaultToString("Dinner::NotTheEater");
}

CORBA::Exception*
Dinner::NotTheEater::_STAR_clone() const
{
    return new NotTheEater(*this);
}

void
Dinner::NotTheEater::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
Dinner::NotTheEater::_STAR_unmarshal(NotTheEater&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:Dinner/NotTheEater:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, Dinner::NotTheEater* v)
{
    static const STAR::Info< Dinner::NotTheEater > info;
    any.replace(Dinner::_tc_NotTheEater, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const Dinner::NotTheEater& v)
{
    any <<= new Dinner::NotTheEater(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const Dinner::NotTheEater*& v)
{
    if(any.check_type(Dinner::_tc_NotTheEater))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            Dinner::NotTheEater* val = new Dinner::NotTheEater;
            Dinner::NotTheEater::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (Dinner::NotTheEater*)any.value();
        return true;
    }
    else
        return false;
}

//
// Interface declare ::Dinner::Fork
//
const char* Dinner::Fork::ids_[] =
{
    "IDL:Dinner/Fork:1.0",
    0
};

void
STARDuplicate(Dinner::Fork_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(Dinner::Fork_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

Dinner::Fork_ptr
Dinner::Fork::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Fork_ptr v = dynamic_cast<Fork_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            Dinner::Fork_broker* val = new Dinner::Fork_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Dinner::Fork_ptr
Dinner::Fork::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Dinner::Fork_ptr
Dinner::Fork::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Fork_ptr v = dynamic_cast<Fork_ptr>(p);
        if(v)
            return _duplicate(v);

        Dinner::Fork_broker* val = new Dinner::Fork_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

Dinner::Fork_ptr
Dinner::Fork::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Dinner::Fork::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(Dinner::Fork_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(Dinner::Fork_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    Dinner::Fork_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        Dinner::Fork_broker* _star_obj = new Dinner::Fork_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = Dinner::Fork::_nil();
}

void
operator<<=(CORBA::Any& any, Dinner::Fork_ptr* v)
{
    any.replace(Dinner::_tc_Fork, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Dinner::Fork_ptr v)
{
    Dinner::Fork_ptr val = Dinner::Fork::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Dinner::Fork_ptr& v)
{
    if(any.check_type(Dinner::_tc_Fork))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Dinner::Fork_ptr>(val)))
            {
                Dinner::Fork_broker* obj = new Dinner::Fork_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Dinner::Fork::_nil();

        return true;
    }
    else
        return false;
}

const char**
Dinner::Fork_broker::_STAR_ids() const
{
    return ids_;
}

//
// Operation declare Dinner::Fork_broker::obtain_fork
//
::Components::Cookie*
Dinner::Fork_broker::obtain_fork()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("obtain_fork", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:Dinner/ForkNotAvailable:1.0") == 0)
                                {
                                    ::Dinner::ForkNotAvailable _star_except;
                                    ::Dinner::ForkNotAvailable::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::Components::Cookie_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.out(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Dinner::Fork_broker::release_fork
//
void
Dinner::Fork_broker::release_fork(::Components::Cookie* _star_a0)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("release_fork", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            STARMarshal(_star_a0, _star_out);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:Dinner/NotTheEater:1.0") == 0)
                                {
                                    ::Dinner::NotTheEater _star_except;
                                    ::Dinner::NotTheEater::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                                return;
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Interface declare ::Dinner::Named
//
const char* Dinner::Named::ids_[] =
{
    "IDL:Dinner/Named:1.0",
    0
};

void
STARDuplicate(Dinner::Named_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(Dinner::Named_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

Dinner::Named_ptr
Dinner::Named::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Named_ptr v = dynamic_cast<Named_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            Dinner::Named_broker* val = new Dinner::Named_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Dinner::Named_ptr
Dinner::Named::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Dinner::Named_ptr
Dinner::Named::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Named_ptr v = dynamic_cast<Named_ptr>(p);
        if(v)
            return _duplicate(v);

        Dinner::Named_broker* val = new Dinner::Named_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

Dinner::Named_ptr
Dinner::Named::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Dinner::Named::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(Dinner::Named_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(Dinner::Named_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    Dinner::Named_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        Dinner::Named_broker* _star_obj = new Dinner::Named_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = Dinner::Named::_nil();
}

void
operator<<=(CORBA::Any& any, Dinner::Named_ptr* v)
{
    any.replace(Dinner::_tc_Named, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Dinner::Named_ptr v)
{
    Dinner::Named_ptr val = Dinner::Named::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Dinner::Named_ptr& v)
{
    if(any.check_type(Dinner::_tc_Named))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Dinner::Named_ptr>(val)))
            {
                Dinner::Named_broker* obj = new Dinner::Named_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Dinner::Named::_nil();

        return true;
    }
    else
        return false;
}

const char**
Dinner::Named_broker::_STAR_ids() const
{
    return ids_;
}

//
// Attribute declare Dinner::Named_broker::name
//
char*
Dinner::Named_broker::name()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("_get_name", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down);
                        CORBA::String_var _star_r;
                        try
                        {
                            _star_r = _star_in -> read_string();
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        return _star_r._retn();
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

void
Dinner::Named_broker::name(const char* _star_a0)
{
    bool _star_retry = true;
    for(;;)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("_set_name", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            _star_out -> write_string(_star_a0);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        return;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Interface declare ::Dinner::Philosopher
//
const char* Dinner::Philosopher::ids_[] =
{
    "IDL:Dinner/Philosopher:1.0",
    "IDL:Dinner/Named:1.0",
    "IDL:omg.org/Components/CCMObject:1.0",
    "IDL:omg.org/Components/Navigation:1.0",
    "IDL:omg.org/Components/Receptacles:1.0",
    "IDL:omg.org/Components/Events:1.0",
    0
};

void
STARDuplicate(Dinner::Philosopher_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(Dinner::Philosopher_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

Dinner::Philosopher_ptr
Dinner::Philosopher::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Philosopher_ptr v = dynamic_cast<Philosopher_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            Dinner::Philosopher_broker* val = new Dinner::Philosopher_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Dinner::Philosopher_ptr
Dinner::Philosopher::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Dinner::Philosopher_ptr
Dinner::Philosopher::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Philosopher_ptr v = dynamic_cast<Philosopher_ptr>(p);
        if(v)
            return _duplicate(v);

        Dinner::Philosopher_broker* val = new Dinner::Philosopher_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

Dinner::Philosopher_ptr
Dinner::Philosopher::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Dinner::Philosopher::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(Dinner::Philosopher_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(Dinner::Philosopher_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    Dinner::Philosopher_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        Dinner::Philosopher_broker* _star_obj = new Dinner::Philosopher_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = Dinner::Philosopher::_nil();
}

void
operator<<=(CORBA::Any& any, Dinner::Philosopher_ptr* v)
{
    any.replace(Dinner::_tc_Philosopher, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Dinner::Philosopher_ptr v)
{
    Dinner::Philosopher_ptr val = Dinner::Philosopher::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Dinner::Philosopher_ptr& v)
{
    if(any.check_type(Dinner::_tc_Philosopher))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Dinner::Philosopher_ptr>(val)))
            {
                Dinner::Philosopher_broker* obj = new Dinner::Philosopher_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Dinner::Philosopher::_nil();

        return true;
    }
    else
        return false;
}

const char**
Dinner::Philosopher_broker::_STAR_ids() const
{
    return ids_;
}

//
// Attribute declare Dinner::Philosopher_broker::thinking_seconds
//
CORBA::ULong
Dinner::Philosopher_broker::thinking_seconds()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("_get_thinking_seconds", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down);
                        CORBA::ULong _star_r;
                        try
                        {
                            _star_r = _star_in -> read_ulong();
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        return _star_r;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

void
Dinner::Philosopher_broker::thinking_seconds(CORBA::ULong _star_a0)
{
    bool _star_retry = true;
    for(;;)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("_set_thinking_seconds", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            _star_out -> write_ulong(_star_a0);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        return;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Attribute declare Dinner::Philosopher_broker::eating_seconds
//
CORBA::ULong
Dinner::Philosopher_broker::eating_seconds()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("_get_eating_seconds", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down);
                        CORBA::ULong _star_r;
                        try
                        {
                            _star_r = _star_in -> read_ulong();
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        return _star_r;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

void
Dinner::Philosopher_broker::eating_seconds(CORBA::ULong _star_a0)
{
    bool _star_retry = true;
    for(;;)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("_set_eating_seconds", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            _star_out -> write_ulong(_star_a0);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        return;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Attribute declare Dinner::Philosopher_broker::sleeping_seconds
//
CORBA::ULong
Dinner::Philosopher_broker::sleeping_seconds()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("_get_sleeping_seconds", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down);
                        CORBA::ULong _star_r;
                        try
                        {
                            _star_r = _star_in -> read_ulong();
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        return _star_r;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

void
Dinner::Philosopher_broker::sleeping_seconds(CORBA::ULong _star_a0)
{
    bool _star_retry = true;
    for(;;)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("_set_sleeping_seconds", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            _star_out -> write_ulong(_star_a0);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        return;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Dinner::Philosopher_broker::connect_left_hand
//
void
Dinner::Philosopher_broker::connect_left_hand(::Dinner::Fork_ptr _star_a0)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("connect_left_hand", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            STARMarshal(_star_a0, _star_out);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:omg.org/Components/AlreadyConnected:1.0") == 0)
                                {
                                    ::Components::AlreadyConnected _star_except;
                                    ::Components::AlreadyConnected::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:omg.org/Components/InvalidConnection:1.0") == 0)
                                {
                                    ::Components::InvalidConnection _star_except;
                                    ::Components::InvalidConnection::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                                return;
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Dinner::Philosopher_broker::disconnect_left_hand
//
::Dinner::Fork_ptr
Dinner::Philosopher_broker::disconnect_left_hand()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("disconnect_left_hand", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:omg.org/Components/NoConnection:1.0") == 0)
                                {
                                    ::Components::NoConnection _star_except;
                                    ::Components::NoConnection::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::Dinner::Fork_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.inout(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Dinner::Philosopher_broker::get_connection_left_hand
//
::Dinner::Fork_ptr
Dinner::Philosopher_broker::get_connection_left_hand()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("get_connection_left_hand", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::Dinner::Fork_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.inout(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Dinner::Philosopher_broker::connect_right_hand
//
void
Dinner::Philosopher_broker::connect_right_hand(::Dinner::Fork_ptr _star_a0)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("connect_right_hand", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            STARMarshal(_star_a0, _star_out);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:omg.org/Components/AlreadyConnected:1.0") == 0)
                                {
                                    ::Components::AlreadyConnected _star_except;
                                    ::Components::AlreadyConnected::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:omg.org/Components/InvalidConnection:1.0") == 0)
                                {
                                    ::Components::InvalidConnection _star_except;
                                    ::Components::InvalidConnection::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                                return;
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Dinner::Philosopher_broker::disconnect_right_hand
//
::Dinner::Fork_ptr
Dinner::Philosopher_broker::disconnect_right_hand()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("disconnect_right_hand", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:omg.org/Components/NoConnection:1.0") == 0)
                                {
                                    ::Components::NoConnection _star_except;
                                    ::Components::NoConnection::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::Dinner::Fork_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.inout(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Dinner::Philosopher_broker::get_connection_right_hand
//
::Dinner::Fork_ptr
Dinner::Philosopher_broker::get_connection_right_hand()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("get_connection_right_hand", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::Dinner::Fork_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.inout(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Dinner::Philosopher_broker::connect_observer
//
void
Dinner::Philosopher_broker::connect_observer(::Dinner::Observing_ptr _star_a0)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("connect_observer", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            STARMarshal(_star_a0, _star_out);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:omg.org/Components/AlreadyConnected:1.0") == 0)
                                {
                                    ::Components::AlreadyConnected _star_except;
                                    ::Components::AlreadyConnected::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:omg.org/Components/InvalidConnection:1.0") == 0)
                                {
                                    ::Components::InvalidConnection _star_except;
                                    ::Components::InvalidConnection::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                                return;
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Dinner::Philosopher_broker::disconnect_observer
//
::Dinner::Observing_ptr
Dinner::Philosopher_broker::disconnect_observer()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("disconnect_observer", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:omg.org/Components/NoConnection:1.0") == 0)
                                {
                                    ::Components::NoConnection _star_except;
                                    ::Components::NoConnection::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::Dinner::Observing_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.inout(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Dinner::Philosopher_broker::get_connection_observer
//
::Dinner::Observing_ptr
Dinner::Philosopher_broker::get_connection_observer()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("get_connection_observer", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::Dinner::Observing_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.inout(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Interface declare ::Dinner::Cutlery
//
const char* Dinner::Cutlery::ids_[] =
{
    "IDL:Dinner/Cutlery:1.0",
    "IDL:omg.org/Components/CCMObject:1.0",
    "IDL:omg.org/Components/Navigation:1.0",
    "IDL:omg.org/Components/Receptacles:1.0",
    "IDL:omg.org/Components/Events:1.0",
    0
};

void
STARDuplicate(Dinner::Cutlery_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(Dinner::Cutlery_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

Dinner::Cutlery_ptr
Dinner::Cutlery::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Cutlery_ptr v = dynamic_cast<Cutlery_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            Dinner::Cutlery_broker* val = new Dinner::Cutlery_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Dinner::Cutlery_ptr
Dinner::Cutlery::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Dinner::Cutlery_ptr
Dinner::Cutlery::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Cutlery_ptr v = dynamic_cast<Cutlery_ptr>(p);
        if(v)
            return _duplicate(v);

        Dinner::Cutlery_broker* val = new Dinner::Cutlery_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

Dinner::Cutlery_ptr
Dinner::Cutlery::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Dinner::Cutlery::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(Dinner::Cutlery_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(Dinner::Cutlery_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    Dinner::Cutlery_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        Dinner::Cutlery_broker* _star_obj = new Dinner::Cutlery_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = Dinner::Cutlery::_nil();
}

void
operator<<=(CORBA::Any& any, Dinner::Cutlery_ptr* v)
{
    any.replace(Dinner::_tc_Cutlery, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Dinner::Cutlery_ptr v)
{
    Dinner::Cutlery_ptr val = Dinner::Cutlery::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Dinner::Cutlery_ptr& v)
{
    if(any.check_type(Dinner::_tc_Cutlery))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Dinner::Cutlery_ptr>(val)))
            {
                Dinner::Cutlery_broker* obj = new Dinner::Cutlery_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Dinner::Cutlery::_nil();

        return true;
    }
    else
        return false;
}

const char**
Dinner::Cutlery_broker::_STAR_ids() const
{
    return ids_;
}

//
// Operation declare Dinner::Cutlery_broker::provide_the_fork
//
::Dinner::Fork_ptr
Dinner::Cutlery_broker::provide_the_fork()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("provide_the_fork", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::Dinner::Fork_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.inout(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Interface declare ::Dinner::PhilosopherHomeExplicit
//
const char* Dinner::PhilosopherHomeExplicit::ids_[] =
{
    "IDL:Dinner/PhilosopherHomeExplicit:1.0",
    "IDL:omg.org/Components/HomeConfiguration:1.0",
    "IDL:omg.org/Components/CCMHome:1.0",
    0
};

void
STARDuplicate(Dinner::PhilosopherHomeExplicit_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(Dinner::PhilosopherHomeExplicit_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

Dinner::PhilosopherHomeExplicit_ptr
Dinner::PhilosopherHomeExplicit::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        PhilosopherHomeExplicit_ptr v = dynamic_cast<PhilosopherHomeExplicit_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            Dinner::PhilosopherHomeExplicit_broker* val = new Dinner::PhilosopherHomeExplicit_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Dinner::PhilosopherHomeExplicit_ptr
Dinner::PhilosopherHomeExplicit::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Dinner::PhilosopherHomeExplicit_ptr
Dinner::PhilosopherHomeExplicit::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        PhilosopherHomeExplicit_ptr v = dynamic_cast<PhilosopherHomeExplicit_ptr>(p);
        if(v)
            return _duplicate(v);

        Dinner::PhilosopherHomeExplicit_broker* val = new Dinner::PhilosopherHomeExplicit_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

Dinner::PhilosopherHomeExplicit_ptr
Dinner::PhilosopherHomeExplicit::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Dinner::PhilosopherHomeExplicit::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(Dinner::PhilosopherHomeExplicit_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(Dinner::PhilosopherHomeExplicit_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    Dinner::PhilosopherHomeExplicit_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        Dinner::PhilosopherHomeExplicit_broker* _star_obj = new Dinner::PhilosopherHomeExplicit_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = Dinner::PhilosopherHomeExplicit::_nil();
}

void
operator<<=(CORBA::Any& any, Dinner::PhilosopherHomeExplicit_ptr* v)
{
    any.replace(Dinner::_tc_PhilosopherHomeExplicit, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Dinner::PhilosopherHomeExplicit_ptr v)
{
    Dinner::PhilosopherHomeExplicit_ptr val = Dinner::PhilosopherHomeExplicit::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Dinner::PhilosopherHomeExplicit_ptr& v)
{
    if(any.check_type(Dinner::_tc_PhilosopherHomeExplicit))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Dinner::PhilosopherHomeExplicit_ptr>(val)))
            {
                Dinner::PhilosopherHomeExplicit_broker* obj = new Dinner::PhilosopherHomeExplicit_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Dinner::PhilosopherHomeExplicit::_nil();

        return true;
    }
    else
        return false;
}

const char**
Dinner::PhilosopherHomeExplicit_broker::_STAR_ids() const
{
    return ids_;
}

//
// Interface declare ::Dinner::PhilosopherHomeImplicit
//
const char* Dinner::PhilosopherHomeImplicit::ids_[] =
{
    "IDL:Dinner/PhilosopherHomeImplicit:1.0",
    "IDL:omg.org/Components/KeylessCCMHome:1.0",
    0
};

void
STARDuplicate(Dinner::PhilosopherHomeImplicit_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(Dinner::PhilosopherHomeImplicit_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

Dinner::PhilosopherHomeImplicit_ptr
Dinner::PhilosopherHomeImplicit::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        PhilosopherHomeImplicit_ptr v = dynamic_cast<PhilosopherHomeImplicit_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            Dinner::PhilosopherHomeImplicit_broker* val = new Dinner::PhilosopherHomeImplicit_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Dinner::PhilosopherHomeImplicit_ptr
Dinner::PhilosopherHomeImplicit::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Dinner::PhilosopherHomeImplicit_ptr
Dinner::PhilosopherHomeImplicit::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        PhilosopherHomeImplicit_ptr v = dynamic_cast<PhilosopherHomeImplicit_ptr>(p);
        if(v)
            return _duplicate(v);

        Dinner::PhilosopherHomeImplicit_broker* val = new Dinner::PhilosopherHomeImplicit_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

Dinner::PhilosopherHomeImplicit_ptr
Dinner::PhilosopherHomeImplicit::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Dinner::PhilosopherHomeImplicit::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(Dinner::PhilosopherHomeImplicit_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(Dinner::PhilosopherHomeImplicit_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    Dinner::PhilosopherHomeImplicit_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        Dinner::PhilosopherHomeImplicit_broker* _star_obj = new Dinner::PhilosopherHomeImplicit_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = Dinner::PhilosopherHomeImplicit::_nil();
}

void
operator<<=(CORBA::Any& any, Dinner::PhilosopherHomeImplicit_ptr* v)
{
    any.replace(Dinner::_tc_PhilosopherHomeImplicit, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Dinner::PhilosopherHomeImplicit_ptr v)
{
    Dinner::PhilosopherHomeImplicit_ptr val = Dinner::PhilosopherHomeImplicit::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Dinner::PhilosopherHomeImplicit_ptr& v)
{
    if(any.check_type(Dinner::_tc_PhilosopherHomeImplicit))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Dinner::PhilosopherHomeImplicit_ptr>(val)))
            {
                Dinner::PhilosopherHomeImplicit_broker* obj = new Dinner::PhilosopherHomeImplicit_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Dinner::PhilosopherHomeImplicit::_nil();

        return true;
    }
    else
        return false;
}

const char**
Dinner::PhilosopherHomeImplicit_broker::_STAR_ids() const
{
    return ids_;
}

//
// Operation declare Dinner::PhilosopherHomeImplicit_broker::create
//
::Dinner::Philosopher_ptr
Dinner::PhilosopherHomeImplicit_broker::create()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("create", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:omg.org/Components/CreateFailure:1.0") == 0)
                                {
                                    ::Components::CreateFailure _star_except;
                                    ::Components::CreateFailure::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::Dinner::Philosopher_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.inout(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Interface declare ::Dinner::PhilosopherHome
//
const char* Dinner::PhilosopherHome::ids_[] =
{
    "IDL:Dinner/PhilosopherHome:1.0",
    "IDL:Dinner/PhilosopherHomeExplicit:1.0",
    "IDL:omg.org/Components/HomeConfiguration:1.0",
    "IDL:omg.org/Components/CCMHome:1.0",
    "IDL:Dinner/PhilosopherHomeImplicit:1.0",
    "IDL:omg.org/Components/KeylessCCMHome:1.0",
    0
};

void
STARDuplicate(Dinner::PhilosopherHome_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(Dinner::PhilosopherHome_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

Dinner::PhilosopherHome_ptr
Dinner::PhilosopherHome::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        PhilosopherHome_ptr v = dynamic_cast<PhilosopherHome_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            Dinner::PhilosopherHome_broker* val = new Dinner::PhilosopherHome_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Dinner::PhilosopherHome_ptr
Dinner::PhilosopherHome::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Dinner::PhilosopherHome_ptr
Dinner::PhilosopherHome::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        PhilosopherHome_ptr v = dynamic_cast<PhilosopherHome_ptr>(p);
        if(v)
            return _duplicate(v);

        Dinner::PhilosopherHome_broker* val = new Dinner::PhilosopherHome_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

Dinner::PhilosopherHome_ptr
Dinner::PhilosopherHome::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Dinner::PhilosopherHome::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(Dinner::PhilosopherHome_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(Dinner::PhilosopherHome_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    Dinner::PhilosopherHome_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        Dinner::PhilosopherHome_broker* _star_obj = new Dinner::PhilosopherHome_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = Dinner::PhilosopherHome::_nil();
}

void
operator<<=(CORBA::Any& any, Dinner::PhilosopherHome_ptr* v)
{
    any.replace(Dinner::_tc_PhilosopherHome, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Dinner::PhilosopherHome_ptr v)
{
    Dinner::PhilosopherHome_ptr val = Dinner::PhilosopherHome::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Dinner::PhilosopherHome_ptr& v)
{
    if(any.check_type(Dinner::_tc_PhilosopherHome))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Dinner::PhilosopherHome_ptr>(val)))
            {
                Dinner::PhilosopherHome_broker* obj = new Dinner::PhilosopherHome_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Dinner::PhilosopherHome::_nil();

        return true;
    }
    else
        return false;
}

const char**
Dinner::PhilosopherHome_broker::_STAR_ids() const
{
    return ids_;
}

//
// Interface declare ::Dinner::CutleryHomeExplicit
//
const char* Dinner::CutleryHomeExplicit::ids_[] =
{
    "IDL:Dinner/CutleryHomeExplicit:1.0",
    "IDL:omg.org/Components/HomeConfiguration:1.0",
    "IDL:omg.org/Components/CCMHome:1.0",
    0
};

void
STARDuplicate(Dinner::CutleryHomeExplicit_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(Dinner::CutleryHomeExplicit_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

Dinner::CutleryHomeExplicit_ptr
Dinner::CutleryHomeExplicit::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CutleryHomeExplicit_ptr v = dynamic_cast<CutleryHomeExplicit_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            Dinner::CutleryHomeExplicit_broker* val = new Dinner::CutleryHomeExplicit_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Dinner::CutleryHomeExplicit_ptr
Dinner::CutleryHomeExplicit::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Dinner::CutleryHomeExplicit_ptr
Dinner::CutleryHomeExplicit::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CutleryHomeExplicit_ptr v = dynamic_cast<CutleryHomeExplicit_ptr>(p);
        if(v)
            return _duplicate(v);

        Dinner::CutleryHomeExplicit_broker* val = new Dinner::CutleryHomeExplicit_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

Dinner::CutleryHomeExplicit_ptr
Dinner::CutleryHomeExplicit::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Dinner::CutleryHomeExplicit::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(Dinner::CutleryHomeExplicit_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(Dinner::CutleryHomeExplicit_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    Dinner::CutleryHomeExplicit_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        Dinner::CutleryHomeExplicit_broker* _star_obj = new Dinner::CutleryHomeExplicit_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = Dinner::CutleryHomeExplicit::_nil();
}

void
operator<<=(CORBA::Any& any, Dinner::CutleryHomeExplicit_ptr* v)
{
    any.replace(Dinner::_tc_CutleryHomeExplicit, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Dinner::CutleryHomeExplicit_ptr v)
{
    Dinner::CutleryHomeExplicit_ptr val = Dinner::CutleryHomeExplicit::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Dinner::CutleryHomeExplicit_ptr& v)
{
    if(any.check_type(Dinner::_tc_CutleryHomeExplicit))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Dinner::CutleryHomeExplicit_ptr>(val)))
            {
                Dinner::CutleryHomeExplicit_broker* obj = new Dinner::CutleryHomeExplicit_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Dinner::CutleryHomeExplicit::_nil();

        return true;
    }
    else
        return false;
}

const char**
Dinner::CutleryHomeExplicit_broker::_STAR_ids() const
{
    return ids_;
}

//
// Interface declare ::Dinner::CutleryHomeImplicit
//
const char* Dinner::CutleryHomeImplicit::ids_[] =
{
    "IDL:Dinner/CutleryHomeImplicit:1.0",
    "IDL:omg.org/Components/KeylessCCMHome:1.0",
    0
};

void
STARDuplicate(Dinner::CutleryHomeImplicit_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(Dinner::CutleryHomeImplicit_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

Dinner::CutleryHomeImplicit_ptr
Dinner::CutleryHomeImplicit::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CutleryHomeImplicit_ptr v = dynamic_cast<CutleryHomeImplicit_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            Dinner::CutleryHomeImplicit_broker* val = new Dinner::CutleryHomeImplicit_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Dinner::CutleryHomeImplicit_ptr
Dinner::CutleryHomeImplicit::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Dinner::CutleryHomeImplicit_ptr
Dinner::CutleryHomeImplicit::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CutleryHomeImplicit_ptr v = dynamic_cast<CutleryHomeImplicit_ptr>(p);
        if(v)
            return _duplicate(v);

        Dinner::CutleryHomeImplicit_broker* val = new Dinner::CutleryHomeImplicit_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

Dinner::CutleryHomeImplicit_ptr
Dinner::CutleryHomeImplicit::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Dinner::CutleryHomeImplicit::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(Dinner::CutleryHomeImplicit_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(Dinner::CutleryHomeImplicit_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    Dinner::CutleryHomeImplicit_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        Dinner::CutleryHomeImplicit_broker* _star_obj = new Dinner::CutleryHomeImplicit_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = Dinner::CutleryHomeImplicit::_nil();
}

void
operator<<=(CORBA::Any& any, Dinner::CutleryHomeImplicit_ptr* v)
{
    any.replace(Dinner::_tc_CutleryHomeImplicit, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Dinner::CutleryHomeImplicit_ptr v)
{
    Dinner::CutleryHomeImplicit_ptr val = Dinner::CutleryHomeImplicit::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Dinner::CutleryHomeImplicit_ptr& v)
{
    if(any.check_type(Dinner::_tc_CutleryHomeImplicit))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Dinner::CutleryHomeImplicit_ptr>(val)))
            {
                Dinner::CutleryHomeImplicit_broker* obj = new Dinner::CutleryHomeImplicit_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Dinner::CutleryHomeImplicit::_nil();

        return true;
    }
    else
        return false;
}

const char**
Dinner::CutleryHomeImplicit_broker::_STAR_ids() const
{
    return ids_;
}

//
// Operation declare Dinner::CutleryHomeImplicit_broker::create
//
::Dinner::Cutlery_ptr
Dinner::CutleryHomeImplicit_broker::create()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("create", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:omg.org/Components/CreateFailure:1.0") == 0)
                                {
                                    ::Components::CreateFailure _star_except;
                                    ::Components::CreateFailure::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::Dinner::Cutlery_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.inout(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Interface declare ::Dinner::CutleryHome
//
const char* Dinner::CutleryHome::ids_[] =
{
    "IDL:Dinner/CutleryHome:1.0",
    "IDL:Dinner/CutleryHomeExplicit:1.0",
    "IDL:omg.org/Components/HomeConfiguration:1.0",
    "IDL:omg.org/Components/CCMHome:1.0",
    "IDL:Dinner/CutleryHomeImplicit:1.0",
    "IDL:omg.org/Components/KeylessCCMHome:1.0",
    0
};

void
STARDuplicate(Dinner::CutleryHome_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(Dinner::CutleryHome_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

Dinner::CutleryHome_ptr
Dinner::CutleryHome::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CutleryHome_ptr v = dynamic_cast<CutleryHome_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            Dinner::CutleryHome_broker* val = new Dinner::CutleryHome_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Dinner::CutleryHome_ptr
Dinner::CutleryHome::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Dinner::CutleryHome_ptr
Dinner::CutleryHome::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CutleryHome_ptr v = dynamic_cast<CutleryHome_ptr>(p);
        if(v)
            return _duplicate(v);

        Dinner::CutleryHome_broker* val = new Dinner::CutleryHome_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

Dinner::CutleryHome_ptr
Dinner::CutleryHome::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Dinner::CutleryHome::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(Dinner::CutleryHome_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(Dinner::CutleryHome_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    Dinner::CutleryHome_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        Dinner::CutleryHome_broker* _star_obj = new Dinner::CutleryHome_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = Dinner::CutleryHome::_nil();
}

void
operator<<=(CORBA::Any& any, Dinner::CutleryHome_ptr* v)
{
    any.replace(Dinner::_tc_CutleryHome, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Dinner::CutleryHome_ptr v)
{
    Dinner::CutleryHome_ptr val = Dinner::CutleryHome::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Dinner::CutleryHome_ptr& v)
{
    if(any.check_type(Dinner::_tc_CutleryHome))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Dinner::CutleryHome_ptr>(val)))
            {
                Dinner::CutleryHome_broker* obj = new Dinner::CutleryHome_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Dinner::CutleryHome::_nil();

        return true;
    }
    else
        return false;
}

const char**
Dinner::CutleryHome_broker::_STAR_ids() const
{
    return ids_;
}
