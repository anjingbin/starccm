// *************************************************************************
//
// This File Is Automatically Generated by the StarBusIDL-to-C++ Compiler !
//
// Copyright (c) 2003
// Network Information Security Institute,Computer College,NUDT.
// ChangSha,Hunan,PRC
//
// All Rights Reserved
//
// *************************************************************************

// Version: 5.0.0

#ifndef ___CCM_Dinner_h__
#define ___CCM_Dinner_h__

#include <Components.h>
#include <Dinner.h>
#include <ComponentServentBase.h>

namespace Dinner
{

class CCM_Fork;
typedef CCM_Fork* CCM_Fork_ptr;
typedef CCM_Fork* CCM_ForkRef;

extern STAR::TypeCodeConst _tc_CCM_Fork;

class CCM_Named;
typedef CCM_Named* CCM_Named_ptr;
typedef CCM_Named* CCM_NamedRef;

extern STAR::TypeCodeConst _tc_CCM_Named;

class CCM_Philosopher;
typedef CCM_Philosopher* CCM_Philosopher_ptr;
typedef CCM_Philosopher* CCM_PhilosopherRef;

extern STAR::TypeCodeConst _tc_CCM_Philosopher;

class CCM_Cutlery;
typedef CCM_Cutlery* CCM_Cutlery_ptr;
typedef CCM_Cutlery* CCM_CutleryRef;

extern STAR::TypeCodeConst _tc_CCM_Cutlery;

class CCM_PhilosopherHomeExplicit;
typedef CCM_PhilosopherHomeExplicit* CCM_PhilosopherHomeExplicit_ptr;
typedef CCM_PhilosopherHomeExplicit* CCM_PhilosopherHomeExplicitRef;

extern STAR::TypeCodeConst _tc_CCM_PhilosopherHomeExplicit;

class CCM_PhilosopherHomeImplicit;
typedef CCM_PhilosopherHomeImplicit* CCM_PhilosopherHomeImplicit_ptr;
typedef CCM_PhilosopherHomeImplicit* CCM_PhilosopherHomeImplicitRef;

extern STAR::TypeCodeConst _tc_CCM_PhilosopherHomeImplicit;

class CCM_PhilosopherHome;
typedef CCM_PhilosopherHome* CCM_PhilosopherHome_ptr;
typedef CCM_PhilosopherHome* CCM_PhilosopherHomeRef;

extern STAR::TypeCodeConst _tc_CCM_PhilosopherHome;

class CCM_CutleryHomeExplicit;
typedef CCM_CutleryHomeExplicit* CCM_CutleryHomeExplicit_ptr;
typedef CCM_CutleryHomeExplicit* CCM_CutleryHomeExplicitRef;

extern STAR::TypeCodeConst _tc_CCM_CutleryHomeExplicit;

class CCM_CutleryHomeImplicit;
typedef CCM_CutleryHomeImplicit* CCM_CutleryHomeImplicit_ptr;
typedef CCM_CutleryHomeImplicit* CCM_CutleryHomeImplicitRef;

extern STAR::TypeCodeConst _tc_CCM_CutleryHomeImplicit;

class CCM_CutleryHome;
typedef CCM_CutleryHome* CCM_CutleryHome_ptr;
typedef CCM_CutleryHome* CCM_CutleryHomeRef;

extern STAR::TypeCodeConst _tc_CCM_CutleryHome;

class CCM_Philosopher_Context;
typedef CCM_Philosopher_Context* CCM_Philosopher_Context_ptr;
typedef CCM_Philosopher_Context* CCM_Philosopher_ContextRef;

extern STAR::TypeCodeConst _tc_CCM_Philosopher_Context;

class CCM_Cutlery_Context;
typedef CCM_Cutlery_Context* CCM_Cutlery_Context_ptr;
typedef CCM_Cutlery_Context* CCM_Cutlery_ContextRef;

extern STAR::TypeCodeConst _tc_CCM_Cutlery_Context;

} // End of namespace Dinner

void STARDuplicate(Dinner::CCM_Fork_ptr);
void STARRelease(Dinner::CCM_Fork_ptr);

void STARMarshal(Dinner::CCM_Fork_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(Dinner::CCM_Fork_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(Dinner::CCM_Named_ptr);
void STARRelease(Dinner::CCM_Named_ptr);

void STARMarshal(Dinner::CCM_Named_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(Dinner::CCM_Named_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(Dinner::CCM_Philosopher_ptr);
void STARRelease(Dinner::CCM_Philosopher_ptr);

void STARMarshal(Dinner::CCM_Philosopher_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(Dinner::CCM_Philosopher_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(Dinner::CCM_Cutlery_ptr);
void STARRelease(Dinner::CCM_Cutlery_ptr);

void STARMarshal(Dinner::CCM_Cutlery_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(Dinner::CCM_Cutlery_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(Dinner::CCM_PhilosopherHomeExplicit_ptr);
void STARRelease(Dinner::CCM_PhilosopherHomeExplicit_ptr);

void STARMarshal(Dinner::CCM_PhilosopherHomeExplicit_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(Dinner::CCM_PhilosopherHomeExplicit_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(Dinner::CCM_PhilosopherHomeImplicit_ptr);
void STARRelease(Dinner::CCM_PhilosopherHomeImplicit_ptr);

void STARMarshal(Dinner::CCM_PhilosopherHomeImplicit_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(Dinner::CCM_PhilosopherHomeImplicit_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(Dinner::CCM_PhilosopherHome_ptr);
void STARRelease(Dinner::CCM_PhilosopherHome_ptr);

void STARMarshal(Dinner::CCM_PhilosopherHome_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(Dinner::CCM_PhilosopherHome_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(Dinner::CCM_CutleryHomeExplicit_ptr);
void STARRelease(Dinner::CCM_CutleryHomeExplicit_ptr);

void STARMarshal(Dinner::CCM_CutleryHomeExplicit_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(Dinner::CCM_CutleryHomeExplicit_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(Dinner::CCM_CutleryHomeImplicit_ptr);
void STARRelease(Dinner::CCM_CutleryHomeImplicit_ptr);

void STARMarshal(Dinner::CCM_CutleryHomeImplicit_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(Dinner::CCM_CutleryHomeImplicit_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(Dinner::CCM_CutleryHome_ptr);
void STARRelease(Dinner::CCM_CutleryHome_ptr);

void STARMarshal(Dinner::CCM_CutleryHome_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(Dinner::CCM_CutleryHome_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(Dinner::CCM_Philosopher_Context_ptr);
void STARRelease(Dinner::CCM_Philosopher_Context_ptr);

void STARMarshal(Dinner::CCM_Philosopher_Context_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(Dinner::CCM_Philosopher_Context_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(Dinner::CCM_Cutlery_Context_ptr);
void STARRelease(Dinner::CCM_Cutlery_Context_ptr);

void STARMarshal(Dinner::CCM_Cutlery_Context_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(Dinner::CCM_Cutlery_Context_ptr&, STAR::InputStreamImpl*);

namespace Dinner
{

typedef STAR::ObjVar< CCM_Fork > CCM_Fork_var;
typedef STAR::ObjOut< CCM_Fork > CCM_Fork_out;

typedef STAR::ObjVar< CCM_Named > CCM_Named_var;
typedef STAR::ObjOut< CCM_Named > CCM_Named_out;

typedef STAR::ObjVar< CCM_Philosopher > CCM_Philosopher_var;
typedef STAR::ObjOut< CCM_Philosopher > CCM_Philosopher_out;

typedef STAR::ObjVar< CCM_Cutlery > CCM_Cutlery_var;
typedef STAR::ObjOut< CCM_Cutlery > CCM_Cutlery_out;

typedef STAR::ObjVar< CCM_PhilosopherHomeExplicit > CCM_PhilosopherHomeExplicit_var;
typedef STAR::ObjOut< CCM_PhilosopherHomeExplicit > CCM_PhilosopherHomeExplicit_out;

typedef STAR::ObjVar< CCM_PhilosopherHomeImplicit > CCM_PhilosopherHomeImplicit_var;
typedef STAR::ObjOut< CCM_PhilosopherHomeImplicit > CCM_PhilosopherHomeImplicit_out;

typedef STAR::ObjVar< CCM_PhilosopherHome > CCM_PhilosopherHome_var;
typedef STAR::ObjOut< CCM_PhilosopherHome > CCM_PhilosopherHome_out;

typedef STAR::ObjVar< CCM_CutleryHomeExplicit > CCM_CutleryHomeExplicit_var;
typedef STAR::ObjOut< CCM_CutleryHomeExplicit > CCM_CutleryHomeExplicit_out;

typedef STAR::ObjVar< CCM_CutleryHomeImplicit > CCM_CutleryHomeImplicit_var;
typedef STAR::ObjOut< CCM_CutleryHomeImplicit > CCM_CutleryHomeImplicit_out;

typedef STAR::ObjVar< CCM_CutleryHome > CCM_CutleryHome_var;
typedef STAR::ObjOut< CCM_CutleryHome > CCM_CutleryHome_out;

typedef STAR::ObjVar< CCM_Philosopher_Context > CCM_Philosopher_Context_var;
typedef STAR::ObjOut< CCM_Philosopher_Context > CCM_Philosopher_Context_out;

typedef STAR::ObjVar< CCM_Cutlery_Context > CCM_Cutlery_Context_var;
typedef STAR::ObjOut< CCM_Cutlery_Context > CCM_Cutlery_Context_out;

} // End of namespace Dinner

//
// Module declare ::Dinner
//
namespace Dinner
{

//
// Interface declare ::Dinner::CCM_Fork
//
class CCM_Fork : virtual public Dinner::Fork
{
    CCM_Fork(const CCM_Fork&);
    void operator=(const CCM_Fork&);

public:

    CCM_Fork() { }
    virtual ~CCM_Fork() { }

    typedef CCM_Fork_ptr _ptr_type;
    typedef CCM_Fork_var _var_type;

    static inline CCM_Fork_ptr
    _duplicate(CCM_Fork_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline CCM_Fork_ptr
    _nil()
    {
        return 0;
    }

    static CCM_Fork_ptr _narrow(CORBA::Object_ptr);
    static CCM_Fork_ptr _narrow(CORBA::AbstractBase_ptr);

};


//
// Interface declare ::Dinner::CCM_Named
//
class CCM_Named : virtual public Dinner::Named
{
    CCM_Named(const CCM_Named&);
    void operator=(const CCM_Named&);

public:

    CCM_Named() { }
    virtual ~CCM_Named() { }

    typedef CCM_Named_ptr _ptr_type;
    typedef CCM_Named_var _var_type;

    static inline CCM_Named_ptr
    _duplicate(CCM_Named_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline CCM_Named_ptr
    _nil()
    {
        return 0;
    }

    static CCM_Named_ptr _narrow(CORBA::Object_ptr);
    static CCM_Named_ptr _narrow(CORBA::AbstractBase_ptr);

};


//
// Interface declare ::Dinner::CCM_Philosopher
//
class CCM_Philosopher : virtual public Components::EnterpriseComponent,
                        virtual public Dinner::Named
{
    CCM_Philosopher(const CCM_Philosopher&);
    void operator=(const CCM_Philosopher&);

public:

    CCM_Philosopher() { }
    virtual ~CCM_Philosopher() { }

    typedef CCM_Philosopher_ptr _ptr_type;
    typedef CCM_Philosopher_var _var_type;

    static inline CCM_Philosopher_ptr
    _duplicate(CCM_Philosopher_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline CCM_Philosopher_ptr
    _nil()
    {
        return 0;
    }

    static CCM_Philosopher_ptr _narrow(CORBA::Object_ptr);
    static CCM_Philosopher_ptr _narrow(CORBA::AbstractBase_ptr);


    //
    // Attribute Get declare ::Dinner::CCM_Philosopher::thinking_seconds
    //
    virtual CORBA::ULong thinking_seconds() = 0;

    //
    // Attribute Set declare ::Dinner::CCM_Philosopher::thinking_seconds
    //
    virtual void thinking_seconds(CORBA::ULong) = 0;

    //
    // Attribute Get declare ::Dinner::CCM_Philosopher::eating_seconds
    //
    virtual CORBA::ULong eating_seconds() = 0;

    //
    // Attribute Set declare ::Dinner::CCM_Philosopher::eating_seconds
    //
    virtual void eating_seconds(CORBA::ULong) = 0;

    //
    // Attribute Get declare ::Dinner::CCM_Philosopher::sleeping_seconds
    //
    virtual CORBA::ULong sleeping_seconds() = 0;

    //
    // Attribute Set declare ::Dinner::CCM_Philosopher::sleeping_seconds
    //
    virtual void sleeping_seconds(CORBA::ULong) = 0;

    //
    // Operation declare ::Dinner::CCM_Philosopher::configuration_complete
    //
    virtual void configuration_complete() = 0;
};


//
// Interface declare ::Dinner::CCM_Cutlery
//
class CCM_Cutlery : virtual public Components::EnterpriseComponent
{
    CCM_Cutlery(const CCM_Cutlery&);
    void operator=(const CCM_Cutlery&);

public:

    CCM_Cutlery() { }
    virtual ~CCM_Cutlery() { }

    typedef CCM_Cutlery_ptr _ptr_type;
    typedef CCM_Cutlery_var _var_type;

    static inline CCM_Cutlery_ptr
    _duplicate(CCM_Cutlery_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline CCM_Cutlery_ptr
    _nil()
    {
        return 0;
    }

    static CCM_Cutlery_ptr _narrow(CORBA::Object_ptr);
    static CCM_Cutlery_ptr _narrow(CORBA::AbstractBase_ptr);


    //
    // Operation declare ::Dinner::CCM_Cutlery::get_the_fork
    //
    virtual ::Dinner::CCM_Fork_ptr get_the_fork() = 0;

    //
    // Operation declare ::Dinner::CCM_Cutlery::configuration_complete
    //
    virtual void configuration_complete() = 0;
};


//
// Interface declare ::Dinner::CCM_PhilosopherHomeExplicit
//
class CCM_PhilosopherHomeExplicit : virtual public Components::HomeExecutorBase
{
    CCM_PhilosopherHomeExplicit(const CCM_PhilosopherHomeExplicit&);
    void operator=(const CCM_PhilosopherHomeExplicit&);

public:

    CCM_PhilosopherHomeExplicit() { }
    virtual ~CCM_PhilosopherHomeExplicit() { }

    typedef CCM_PhilosopherHomeExplicit_ptr _ptr_type;
    typedef CCM_PhilosopherHomeExplicit_var _var_type;

    static inline CCM_PhilosopherHomeExplicit_ptr
    _duplicate(CCM_PhilosopherHomeExplicit_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline CCM_PhilosopherHomeExplicit_ptr
    _nil()
    {
        return 0;
    }

    static CCM_PhilosopherHomeExplicit_ptr _narrow(CORBA::Object_ptr);
    static CCM_PhilosopherHomeExplicit_ptr _narrow(CORBA::AbstractBase_ptr);

};


//
// Interface declare ::Dinner::CCM_PhilosopherHomeImplicit
//
class CCM_PhilosopherHomeImplicit : virtual public CORBA::Object
{
    CCM_PhilosopherHomeImplicit(const CCM_PhilosopherHomeImplicit&);
    void operator=(const CCM_PhilosopherHomeImplicit&);

public:

    CCM_PhilosopherHomeImplicit() { }
    virtual ~CCM_PhilosopherHomeImplicit() { }

    typedef CCM_PhilosopherHomeImplicit_ptr _ptr_type;
    typedef CCM_PhilosopherHomeImplicit_var _var_type;

    static inline CCM_PhilosopherHomeImplicit_ptr
    _duplicate(CCM_PhilosopherHomeImplicit_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline CCM_PhilosopherHomeImplicit_ptr
    _nil()
    {
        return 0;
    }

    static CCM_PhilosopherHomeImplicit_ptr _narrow(CORBA::Object_ptr);
    static CCM_PhilosopherHomeImplicit_ptr _narrow(CORBA::AbstractBase_ptr);


    //
    // Operation declare ::Dinner::CCM_PhilosopherHomeImplicit::create
    //
    virtual ::Components::EnterpriseComponent_ptr create() = 0;
};


//
// Interface declare ::Dinner::CCM_PhilosopherHome
//
class CCM_PhilosopherHome : virtual public Dinner::CCM_PhilosopherHomeExplicit,
                            virtual public Dinner::CCM_PhilosopherHomeImplicit
{
    CCM_PhilosopherHome(const CCM_PhilosopherHome&);
    void operator=(const CCM_PhilosopherHome&);

public:

    CCM_PhilosopherHome() { }
    virtual ~CCM_PhilosopherHome() { }

    typedef CCM_PhilosopherHome_ptr _ptr_type;
    typedef CCM_PhilosopherHome_var _var_type;

    static inline CCM_PhilosopherHome_ptr
    _duplicate(CCM_PhilosopherHome_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline CCM_PhilosopherHome_ptr
    _nil()
    {
        return 0;
    }

    static CCM_PhilosopherHome_ptr _narrow(CORBA::Object_ptr);
    static CCM_PhilosopherHome_ptr _narrow(CORBA::AbstractBase_ptr);

};


//
// Interface declare ::Dinner::CCM_CutleryHomeExplicit
//
class CCM_CutleryHomeExplicit : virtual public Components::HomeExecutorBase
{
    CCM_CutleryHomeExplicit(const CCM_CutleryHomeExplicit&);
    void operator=(const CCM_CutleryHomeExplicit&);

public:

    CCM_CutleryHomeExplicit() { }
    virtual ~CCM_CutleryHomeExplicit() { }

    typedef CCM_CutleryHomeExplicit_ptr _ptr_type;
    typedef CCM_CutleryHomeExplicit_var _var_type;

    static inline CCM_CutleryHomeExplicit_ptr
    _duplicate(CCM_CutleryHomeExplicit_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline CCM_CutleryHomeExplicit_ptr
    _nil()
    {
        return 0;
    }

    static CCM_CutleryHomeExplicit_ptr _narrow(CORBA::Object_ptr);
    static CCM_CutleryHomeExplicit_ptr _narrow(CORBA::AbstractBase_ptr);

};


//
// Interface declare ::Dinner::CCM_CutleryHomeImplicit
//
class CCM_CutleryHomeImplicit : virtual public CORBA::Object
{
    CCM_CutleryHomeImplicit(const CCM_CutleryHomeImplicit&);
    void operator=(const CCM_CutleryHomeImplicit&);

public:

    CCM_CutleryHomeImplicit() { }
    virtual ~CCM_CutleryHomeImplicit() { }

    typedef CCM_CutleryHomeImplicit_ptr _ptr_type;
    typedef CCM_CutleryHomeImplicit_var _var_type;

    static inline CCM_CutleryHomeImplicit_ptr
    _duplicate(CCM_CutleryHomeImplicit_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline CCM_CutleryHomeImplicit_ptr
    _nil()
    {
        return 0;
    }

    static CCM_CutleryHomeImplicit_ptr _narrow(CORBA::Object_ptr);
    static CCM_CutleryHomeImplicit_ptr _narrow(CORBA::AbstractBase_ptr);


    //
    // Operation declare ::Dinner::CCM_CutleryHomeImplicit::create
    //
    virtual ::Components::EnterpriseComponent_ptr create() = 0;
};


//
// Interface declare ::Dinner::CCM_CutleryHome
//
class CCM_CutleryHome : virtual public Dinner::CCM_CutleryHomeExplicit,
                        virtual public Dinner::CCM_CutleryHomeImplicit
{
    CCM_CutleryHome(const CCM_CutleryHome&);
    void operator=(const CCM_CutleryHome&);

public:

    CCM_CutleryHome() { }
    virtual ~CCM_CutleryHome() { }

    typedef CCM_CutleryHome_ptr _ptr_type;
    typedef CCM_CutleryHome_var _var_type;

    static inline CCM_CutleryHome_ptr
    _duplicate(CCM_CutleryHome_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline CCM_CutleryHome_ptr
    _nil()
    {
        return 0;
    }

    static CCM_CutleryHome_ptr _narrow(CORBA::Object_ptr);
    static CCM_CutleryHome_ptr _narrow(CORBA::AbstractBase_ptr);

};


//
// Interface declare ::Dinner::CCM_Philosopher_Context
//
class CCM_Philosopher_Context : virtual public Components::Session2Context
{
    CCM_Philosopher_Context(const CCM_Philosopher_Context&);
    void operator=(const CCM_Philosopher_Context&);

public:

    CCM_Philosopher_Context() { }
    virtual ~CCM_Philosopher_Context() { }

    typedef CCM_Philosopher_Context_ptr _ptr_type;
    typedef CCM_Philosopher_Context_var _var_type;

    static inline CCM_Philosopher_Context_ptr
    _duplicate(CCM_Philosopher_Context_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline CCM_Philosopher_Context_ptr
    _nil()
    {
        return 0;
    }

    static CCM_Philosopher_Context_ptr _narrow(CORBA::Object_ptr);
    static CCM_Philosopher_Context_ptr _narrow(CORBA::AbstractBase_ptr);
    
	virtual Components::ComponentServentBase* getServant() = 0;
		
	virtual CORBA::ORB_ptr getORB() = 0;

    //
    // Operation declare ::Dinner::CCM_Philosopher_Context::get_connection_left_hand
    //
    virtual ::Dinner::Fork_ptr get_connection_left_hand() = 0;

    //
    // Operation declare ::Dinner::CCM_Philosopher_Context::get_connection_right_hand
    //
    virtual ::Dinner::Fork_ptr get_connection_right_hand() = 0;

    //
    // Operation declare ::Dinner::CCM_Philosopher_Context::get_connection_observer
    //
    virtual ::Dinner::Observing_ptr get_connection_observer() = 0;
};


//
// Interface declare ::Dinner::CCM_Cutlery_Context
//
class CCM_Cutlery_Context : virtual public Components::Session2Context
{
    CCM_Cutlery_Context(const CCM_Cutlery_Context&);
    void operator=(const CCM_Cutlery_Context&);

public:

    CCM_Cutlery_Context() { }
    virtual ~CCM_Cutlery_Context() { }

    typedef CCM_Cutlery_Context_ptr _ptr_type;
    typedef CCM_Cutlery_Context_var _var_type;

    static inline CCM_Cutlery_Context_ptr
    _duplicate(CCM_Cutlery_Context_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline CCM_Cutlery_Context_ptr
    _nil()
    {
        return 0;
    }

    static CCM_Cutlery_Context_ptr _narrow(CORBA::Object_ptr);
    static CCM_Cutlery_Context_ptr _narrow(CORBA::AbstractBase_ptr);

};


} // End of namespace Dinner

//
// Module declare ::Dinner
//
namespace OBV_Dinner
{

} // End of namespace OBV_Dinner

//
// Interface declare ::Dinner::CCM_Fork
//
namespace CORBA
{

inline void
release(Dinner::CCM_Fork_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(Dinner::CCM_Fork_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, Dinner::CCM_Fork_ptr*);
void operator<<=(CORBA::Any&, Dinner::CCM_Fork_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, Dinner::CCM_Fork_ptr&);

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_Fork_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_Fork_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Dinner::CCM_Fork_ptr& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::Dinner::CCM_Named
//
namespace CORBA
{

inline void
release(Dinner::CCM_Named_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(Dinner::CCM_Named_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, Dinner::CCM_Named_ptr*);
void operator<<=(CORBA::Any&, Dinner::CCM_Named_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, Dinner::CCM_Named_ptr&);

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_Named_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_Named_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Dinner::CCM_Named_ptr& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::Dinner::CCM_Philosopher
//
namespace CORBA
{

inline void
release(Dinner::CCM_Philosopher_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(Dinner::CCM_Philosopher_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, Dinner::CCM_Philosopher_ptr*);
void operator<<=(CORBA::Any&, Dinner::CCM_Philosopher_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, Dinner::CCM_Philosopher_ptr&);

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_Philosopher_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_Philosopher_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Dinner::CCM_Philosopher_ptr& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::Dinner::CCM_Cutlery
//
namespace CORBA
{

inline void
release(Dinner::CCM_Cutlery_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(Dinner::CCM_Cutlery_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, Dinner::CCM_Cutlery_ptr*);
void operator<<=(CORBA::Any&, Dinner::CCM_Cutlery_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, Dinner::CCM_Cutlery_ptr&);

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_Cutlery_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_Cutlery_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Dinner::CCM_Cutlery_ptr& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::Dinner::CCM_PhilosopherHomeExplicit
//
namespace CORBA
{

inline void
release(Dinner::CCM_PhilosopherHomeExplicit_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(Dinner::CCM_PhilosopherHomeExplicit_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, Dinner::CCM_PhilosopherHomeExplicit_ptr*);
void operator<<=(CORBA::Any&, Dinner::CCM_PhilosopherHomeExplicit_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, Dinner::CCM_PhilosopherHomeExplicit_ptr&);

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_PhilosopherHomeExplicit_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_PhilosopherHomeExplicit_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Dinner::CCM_PhilosopherHomeExplicit_ptr& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::Dinner::CCM_PhilosopherHomeImplicit
//
namespace CORBA
{

inline void
release(Dinner::CCM_PhilosopherHomeImplicit_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(Dinner::CCM_PhilosopherHomeImplicit_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, Dinner::CCM_PhilosopherHomeImplicit_ptr*);
void operator<<=(CORBA::Any&, Dinner::CCM_PhilosopherHomeImplicit_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, Dinner::CCM_PhilosopherHomeImplicit_ptr&);

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_PhilosopherHomeImplicit_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_PhilosopherHomeImplicit_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Dinner::CCM_PhilosopherHomeImplicit_ptr& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::Dinner::CCM_PhilosopherHome
//
namespace CORBA
{

inline void
release(Dinner::CCM_PhilosopherHome_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(Dinner::CCM_PhilosopherHome_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, Dinner::CCM_PhilosopherHome_ptr*);
void operator<<=(CORBA::Any&, Dinner::CCM_PhilosopherHome_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, Dinner::CCM_PhilosopherHome_ptr&);

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_PhilosopherHome_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_PhilosopherHome_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Dinner::CCM_PhilosopherHome_ptr& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::Dinner::CCM_CutleryHomeExplicit
//
namespace CORBA
{

inline void
release(Dinner::CCM_CutleryHomeExplicit_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(Dinner::CCM_CutleryHomeExplicit_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, Dinner::CCM_CutleryHomeExplicit_ptr*);
void operator<<=(CORBA::Any&, Dinner::CCM_CutleryHomeExplicit_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, Dinner::CCM_CutleryHomeExplicit_ptr&);

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_CutleryHomeExplicit_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_CutleryHomeExplicit_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Dinner::CCM_CutleryHomeExplicit_ptr& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::Dinner::CCM_CutleryHomeImplicit
//
namespace CORBA
{

inline void
release(Dinner::CCM_CutleryHomeImplicit_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(Dinner::CCM_CutleryHomeImplicit_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, Dinner::CCM_CutleryHomeImplicit_ptr*);
void operator<<=(CORBA::Any&, Dinner::CCM_CutleryHomeImplicit_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, Dinner::CCM_CutleryHomeImplicit_ptr&);

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_CutleryHomeImplicit_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_CutleryHomeImplicit_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Dinner::CCM_CutleryHomeImplicit_ptr& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::Dinner::CCM_CutleryHome
//
namespace CORBA
{

inline void
release(Dinner::CCM_CutleryHome_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(Dinner::CCM_CutleryHome_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, Dinner::CCM_CutleryHome_ptr*);
void operator<<=(CORBA::Any&, Dinner::CCM_CutleryHome_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, Dinner::CCM_CutleryHome_ptr&);

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_CutleryHome_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_CutleryHome_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Dinner::CCM_CutleryHome_ptr& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::Dinner::CCM_Philosopher_Context
//
namespace CORBA
{

inline void
release(Dinner::CCM_Philosopher_Context_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(Dinner::CCM_Philosopher_Context_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, Dinner::CCM_Philosopher_Context_ptr*);
void operator<<=(CORBA::Any&, Dinner::CCM_Philosopher_Context_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, Dinner::CCM_Philosopher_Context_ptr&);

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_Philosopher_Context_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_Philosopher_Context_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Dinner::CCM_Philosopher_Context_ptr& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::Dinner::CCM_Cutlery_Context
//
namespace CORBA
{

inline void
release(Dinner::CCM_Cutlery_Context_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(Dinner::CCM_Cutlery_Context_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, Dinner::CCM_Cutlery_Context_ptr*);
void operator<<=(CORBA::Any&, Dinner::CCM_Cutlery_Context_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, Dinner::CCM_Cutlery_Context_ptr&);

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_Cutlery_Context_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, Dinner::CCM_Cutlery_Context_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Dinner::CCM_Cutlery_Context_ptr& val)
{
    return any.in() >>= val;
}

#endif
