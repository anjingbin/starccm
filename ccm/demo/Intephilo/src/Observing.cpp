// *************************************************************************
//
// This File Is Automatically Generated by the StarBusIDL-to-C++ Compiler !
//
// Copyright (c) 2003
// Network Information Security Institute,Computer College,NUDT.
// ChangSha,Hunan,PRC
//
// All Rights Reserved
//
// *************************************************************************

// Version: 5.0.0

#include <STAR/CORBAClient.h>
#include <STAR/CORBAServer.h>
#include <Observing.h>

namespace javax
{

namespace ejb
{

STAR::TypeCodeConst _tc_EJBHome(
"019a49000e0000003c00000001f0fd7f27000000524d493a6a617661782e656a622e454a42486"
"f6d653a30303030303030303030303030303030000008000000454a42486f6d6500"
);

STAR::TypeCodeConst _tc_EJBObject(
"019a49000e0000004200000001f0fd7f29000000524d493a6a617661782e656a622e454a424f6"
"26a6563743a3030303030303030303030303030303000ac49000a000000454a424f626a656374"
"00"
);

} // End of namespace ejb

} // End of namespace javax

namespace Dinner
{

STAR::TypeCodeConst _tc_Observing(
"01f712000e0000003e0000000100000026000000524d493a44696e6e65722e4f6273657276696"
"e673a303030303030303030303030303030300049000a0000004f6273657276696e6700"
);

STAR::TypeCodeConst _tc_ObservingHome(
"01f712000e0000004600000001ee12002a000000524d493a44696e6e65722e4f6273657276696"
"e67486f6d653a303030303030303030303030303030300012000e0000004f6273657276696e67"
"486f6d6500"
);

} // End of namespace Dinner

//
// Interface declare ::javax::ejb::EJBHome
//
const char* javax::ejb::EJBHome::ids_[] =
{
    "RMI:javax.ejb.EJBHome:0000000000000000",
    0
};

void
STARDuplicate(javax::ejb::EJBHome_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(javax::ejb::EJBHome_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

javax::ejb::EJBHome_ptr
javax::ejb::EJBHome::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        EJBHome_ptr v = dynamic_cast<EJBHome_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            javax::ejb::EJBHome_broker* val = new javax::ejb::EJBHome_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

javax::ejb::EJBHome_ptr
javax::ejb::EJBHome::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

javax::ejb::EJBHome_ptr
javax::ejb::EJBHome::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        EJBHome_ptr v = dynamic_cast<EJBHome_ptr>(p);
        if(v)
            return _duplicate(v);

        javax::ejb::EJBHome_broker* val = new javax::ejb::EJBHome_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

javax::ejb::EJBHome_ptr
javax::ejb::EJBHome::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
javax::ejb::EJBHome::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(javax::ejb::EJBHome_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(javax::ejb::EJBHome_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    javax::ejb::EJBHome_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        javax::ejb::EJBHome_broker* _star_obj = new javax::ejb::EJBHome_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = javax::ejb::EJBHome::_nil();
}

void
operator<<=(CORBA::Any& any, javax::ejb::EJBHome_ptr* v)
{
    any.replace(javax::ejb::_tc_EJBHome, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, javax::ejb::EJBHome_ptr v)
{
    javax::ejb::EJBHome_ptr val = javax::ejb::EJBHome::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, javax::ejb::EJBHome_ptr& v)
{
    if(any.check_type(javax::ejb::_tc_EJBHome))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<javax::ejb::EJBHome_ptr>(val)))
            {
                javax::ejb::EJBHome_broker* obj = new javax::ejb::EJBHome_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = javax::ejb::EJBHome::_nil();

        return true;
    }
    else
        return false;
}

const char**
javax::ejb::EJBHome_broker::_STAR_ids() const
{
    return ids_;
}

//
// Interface declare ::javax::ejb::EJBObject
//
const char* javax::ejb::EJBObject::ids_[] =
{
    "RMI:javax.ejb.EJBObject:0000000000000000",
    0
};

void
STARDuplicate(javax::ejb::EJBObject_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(javax::ejb::EJBObject_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

javax::ejb::EJBObject_ptr
javax::ejb::EJBObject::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        EJBObject_ptr v = dynamic_cast<EJBObject_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            javax::ejb::EJBObject_broker* val = new javax::ejb::EJBObject_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

javax::ejb::EJBObject_ptr
javax::ejb::EJBObject::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

javax::ejb::EJBObject_ptr
javax::ejb::EJBObject::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        EJBObject_ptr v = dynamic_cast<EJBObject_ptr>(p);
        if(v)
            return _duplicate(v);

        javax::ejb::EJBObject_broker* val = new javax::ejb::EJBObject_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

javax::ejb::EJBObject_ptr
javax::ejb::EJBObject::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
javax::ejb::EJBObject::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(javax::ejb::EJBObject_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(javax::ejb::EJBObject_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    javax::ejb::EJBObject_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        javax::ejb::EJBObject_broker* _star_obj = new javax::ejb::EJBObject_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = javax::ejb::EJBObject::_nil();
}

void
operator<<=(CORBA::Any& any, javax::ejb::EJBObject_ptr* v)
{
    any.replace(javax::ejb::_tc_EJBObject, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, javax::ejb::EJBObject_ptr v)
{
    javax::ejb::EJBObject_ptr val = javax::ejb::EJBObject::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, javax::ejb::EJBObject_ptr& v)
{
    if(any.check_type(javax::ejb::_tc_EJBObject))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<javax::ejb::EJBObject_ptr>(val)))
            {
                javax::ejb::EJBObject_broker* obj = new javax::ejb::EJBObject_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = javax::ejb::EJBObject::_nil();

        return true;
    }
    else
        return false;
}

const char**
javax::ejb::EJBObject_broker::_STAR_ids() const
{
    return ids_;
}

//
// Attribute declare javax::ejb::EJBObject_broker::EJBHome
//
::javax::ejb::EJBHome_ptr
javax::ejb::EJBObject_broker::EJBHome()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("_get_EJBHome", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down);
                        ::javax::ejb::EJBHome_var _star_r;
                        try
                        {
                            STARUnmarshal(_star_r.inout(), _star_in);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        return _star_r._retn();
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare javax::ejb::EJBObject_broker::remove
//
void
javax::ejb::EJBObject_broker::remove()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("remove", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        break;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare javax::ejb::EJBObject_broker::isIdentical
//
CORBA::Boolean
javax::ejb::EJBObject_broker::isIdentical(::javax::ejb::EJBObject_ptr _star_a0)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("isIdentical", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            STARMarshal(_star_a0, _star_out);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            CORBA::Boolean _star_r;
                            try
                            {
                                _star_r = _star_in -> read_boolean();
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Interface declare ::Dinner::Observing
//
const char* Dinner::Observing::ids_[] =
{
    "RMI:Dinner.Observing:0000000000000000",
    "RMI:javax.ejb.EJBObject:0000000000000000",
    0
};

void
STARDuplicate(Dinner::Observing_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(Dinner::Observing_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

Dinner::Observing_ptr
Dinner::Observing::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Observing_ptr v = dynamic_cast<Observing_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            Dinner::Observing_broker* val = new Dinner::Observing_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Dinner::Observing_ptr
Dinner::Observing::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Dinner::Observing_ptr
Dinner::Observing::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Observing_ptr v = dynamic_cast<Observing_ptr>(p);
        if(v)
            return _duplicate(v);

        Dinner::Observing_broker* val = new Dinner::Observing_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

Dinner::Observing_ptr
Dinner::Observing::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Dinner::Observing::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(Dinner::Observing_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(Dinner::Observing_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    Dinner::Observing_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        Dinner::Observing_broker* _star_obj = new Dinner::Observing_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = Dinner::Observing::_nil();
}

void
operator<<=(CORBA::Any& any, Dinner::Observing_ptr* v)
{
    any.replace(Dinner::_tc_Observing, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Dinner::Observing_ptr v)
{
    Dinner::Observing_ptr val = Dinner::Observing::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Dinner::Observing_ptr& v)
{
    if(any.check_type(Dinner::_tc_Observing))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Dinner::Observing_ptr>(val)))
            {
                Dinner::Observing_broker* obj = new Dinner::Observing_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Dinner::Observing::_nil();

        return true;
    }
    else
        return false;
}

const char**
Dinner::Observing_broker::_STAR_ids() const
{
    return ids_;
}

//
// Operation declare Dinner::Observing_broker::change_status
//
void
Dinner::Observing_broker::change_status(CORBA::Long _star_a0,
                                        ::CORBA::WStringValue* _star_a1)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("change_status", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            _star_out -> write_long(_star_a0);
                            STARMarshal(_star_a1, _star_out);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        break;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                                return;
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Interface declare ::Dinner::ObservingHome
//
const char* Dinner::ObservingHome::ids_[] =
{
    "RMI:Dinner.ObservingHome:0000000000000000",
    "RMI:javax.ejb.EJBHome:0000000000000000",
    0
};

void
STARDuplicate(Dinner::ObservingHome_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(Dinner::ObservingHome_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

Dinner::ObservingHome_ptr
Dinner::ObservingHome::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        ObservingHome_ptr v = dynamic_cast<ObservingHome_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            Dinner::ObservingHome_broker* val = new Dinner::ObservingHome_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Dinner::ObservingHome_ptr
Dinner::ObservingHome::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Dinner::ObservingHome_ptr
Dinner::ObservingHome::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        ObservingHome_ptr v = dynamic_cast<ObservingHome_ptr>(p);
        if(v)
            return _duplicate(v);

        Dinner::ObservingHome_broker* val = new Dinner::ObservingHome_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

Dinner::ObservingHome_ptr
Dinner::ObservingHome::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Dinner::ObservingHome::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(Dinner::ObservingHome_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(Dinner::ObservingHome_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    Dinner::ObservingHome_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        Dinner::ObservingHome_broker* _star_obj = new Dinner::ObservingHome_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = Dinner::ObservingHome::_nil();
}

void
operator<<=(CORBA::Any& any, Dinner::ObservingHome_ptr* v)
{
    any.replace(Dinner::_tc_ObservingHome, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Dinner::ObservingHome_ptr v)
{
    Dinner::ObservingHome_ptr val = Dinner::ObservingHome::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Dinner::ObservingHome_ptr& v)
{
    if(any.check_type(Dinner::_tc_ObservingHome))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Dinner::ObservingHome_ptr>(val)))
            {
                Dinner::ObservingHome_broker* obj = new Dinner::ObservingHome_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Dinner::ObservingHome::_nil();

        return true;
    }
    else
        return false;
}

const char**
Dinner::ObservingHome_broker::_STAR_ids() const
{
    return ids_;
}

//
// Operation declare Dinner::ObservingHome_broker::create
//
::Dinner::Observing_ptr
Dinner::ObservingHome_broker::create()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("create", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::Dinner::Observing_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.inout(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}
