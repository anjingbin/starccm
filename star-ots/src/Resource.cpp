// *************************************************************************
//
// This File Is Automatically Generated by the StarBusIDL-to-C++ Compiler !
//
// Copyright (c) 2003
// Network Information Security Institute,Computer College,NUDT.
// ChangSha,Hunan,PRC
//
// All Rights Reserved
//
// *************************************************************************

// Version: 5.0.0

#include <STAR/CORBAClient.h>
#include <STAR/CORBAServer.h>
#include <Resource_skel.h>
#include <Resource.h>

STAR::TypeCodeConst _tc_ResourceFactory(
"01a77d000e0000003400000001f0fd7f1800000049444c3a5265736f75726365466163746f727"
"93a312e3000100000005265736f75726365466163746f727900"
);

STAR::TypeCodeConst _tc_Resource(
"01a77d000e0000002900000001f0fd7f1100000049444c3a5265736f757263653a312e3000fff"
"fff090000005265736f7572636500"
);

//
// Interface declare ::ResourceFactory
//
const char* ResourceFactory::ids_[] =
{
    "IDL:ResourceFactory:1.0",
    0
};

void
STARDuplicate(ResourceFactory_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(ResourceFactory_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

ResourceFactory_ptr
ResourceFactory::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        ResourceFactory_ptr v = dynamic_cast<ResourceFactory_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            ResourceFactory_broker* val = new ResourceFactory_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

ResourceFactory_ptr
ResourceFactory::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

ResourceFactory_ptr
ResourceFactory::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        ResourceFactory_ptr v = dynamic_cast<ResourceFactory_ptr>(p);
        if(v)
            return _duplicate(v);

        ResourceFactory_broker* val = new ResourceFactory_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

ResourceFactory_ptr
ResourceFactory::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
ResourceFactory::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(ResourceFactory_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(ResourceFactory_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    ResourceFactory_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        ResourceFactory_broker* _star_obj = new ResourceFactory_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = ResourceFactory::_nil();
}

void
operator<<=(CORBA::Any& any, ResourceFactory_ptr* v)
{
    any.replace(_tc_ResourceFactory, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, ResourceFactory_ptr v)
{
    ResourceFactory_ptr val = ResourceFactory::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, ResourceFactory_ptr& v)
{
    if(any.check_type(_tc_ResourceFactory))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<ResourceFactory_ptr>(val)))
            {
                ResourceFactory_broker* obj = new ResourceFactory_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = ResourceFactory::_nil();

        return true;
    }
    else
        return false;
}

const char**
ResourceFactory_broker::_STAR_ids() const
{
    return ids_;
}

//
// Operation declare ResourceFactory_broker::create
//
::Resource_ptr
ResourceFactory_broker::create(CORBA::Short _star_a0)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("create", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            _star_out -> write_short(_star_a0);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::Resource_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.inout(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "create");
                    return dynamic_cast<POA_ResourceFactory*>(_star_stub->_star_servant_) -> create(_star_a0);
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Interface declare ::Resource
//
const char* Resource::ids_[] =
{
    "IDL:Resource:1.0",
    "IDL:PG_Resource:1.0",
    0
};

void
STARDuplicate(Resource_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(Resource_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

Resource_ptr
Resource::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Resource_ptr v = dynamic_cast<Resource_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            Resource_broker* val = new Resource_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Resource_ptr
Resource::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Resource_ptr
Resource::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Resource_ptr v = dynamic_cast<Resource_ptr>(p);
        if(v)
            return _duplicate(v);

        Resource_broker* val = new Resource_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

Resource_ptr
Resource::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Resource::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(Resource_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(Resource_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    Resource_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        Resource_broker* _star_obj = new Resource_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = Resource::_nil();
}

void
operator<<=(CORBA::Any& any, Resource_ptr* v)
{
    any.replace(_tc_Resource, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Resource_ptr v)
{
    Resource_ptr val = Resource::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Resource_ptr& v)
{
    if(any.check_type(_tc_Resource))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Resource_ptr>(val)))
            {
                Resource_broker* obj = new Resource_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Resource::_nil();

        return true;
    }
    else
        return false;
}

const char**
Resource_broker::_STAR_ids() const
{
    return ids_;
}

//
// Operation declare Resource_broker::prepare
//
::CosTransactions::Vote
Resource_broker::prepare()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("prepare", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/HeuristicMixed:1.0") == 0)
                                {
                                    ::CosTransactions::HeuristicMixed _star_except;
                                    ::CosTransactions::HeuristicMixed::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/HeuristicHazard:1.0") == 0)
                                {
                                    ::CosTransactions::HeuristicHazard _star_except;
                                    ::CosTransactions::HeuristicHazard::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::CosTransactions::Vote _star_r;
                            try
                            {
                                _star_r = (CosTransactions::Vote)_star_in -> read_ulong();
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "prepare");
                    return dynamic_cast<POA_Resource*>(_star_stub->_star_servant_) -> prepare();
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Resource_broker::rollback
//
void
Resource_broker::rollback()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("rollback", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/HeuristicCommit:1.0") == 0)
                                {
                                    ::CosTransactions::HeuristicCommit _star_except;
                                    ::CosTransactions::HeuristicCommit::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/HeuristicMixed:1.0") == 0)
                                {
                                    ::CosTransactions::HeuristicMixed _star_except;
                                    ::CosTransactions::HeuristicMixed::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/HeuristicHazard:1.0") == 0)
                                {
                                    ::CosTransactions::HeuristicHazard _star_except;
                                    ::CosTransactions::HeuristicHazard::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "rollback");
                    dynamic_cast<POA_Resource*>(_star_stub->_star_servant_) -> rollback();
                    #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                                        volatile int i = 1;
                                                        i++;
                    #endif
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Resource_broker::commit
//
void
Resource_broker::commit()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("commit", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/NotPrepared:1.0") == 0)
                                {
                                    ::CosTransactions::NotPrepared _star_except;
                                    ::CosTransactions::NotPrepared::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/HeuristicRollback:1.0") == 0)
                                {
                                    ::CosTransactions::HeuristicRollback _star_except;
                                    ::CosTransactions::HeuristicRollback::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/HeuristicMixed:1.0") == 0)
                                {
                                    ::CosTransactions::HeuristicMixed _star_except;
                                    ::CosTransactions::HeuristicMixed::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/HeuristicHazard:1.0") == 0)
                                {
                                    ::CosTransactions::HeuristicHazard _star_except;
                                    ::CosTransactions::HeuristicHazard::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "commit");
                    dynamic_cast<POA_Resource*>(_star_stub->_star_servant_) -> commit();
                    #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                                        volatile int i = 1;
                                                        i++;
                    #endif
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Resource_broker::commit_one_phase
//
void
Resource_broker::commit_one_phase()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("commit_one_phase", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/HeuristicHazard:1.0") == 0)
                                {
                                    ::CosTransactions::HeuristicHazard _star_except;
                                    ::CosTransactions::HeuristicHazard::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "commit_one_phase");
                    dynamic_cast<POA_Resource*>(_star_stub->_star_servant_) -> commit_one_phase();
                    #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                                        volatile int i = 1;
                                                        i++;
                    #endif
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Resource_broker::forget
//
void
Resource_broker::forget()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("forget", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "forget");
                    dynamic_cast<POA_Resource*>(_star_stub->_star_servant_) -> forget();
                    #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                                        volatile int i = 1;
                                                        i++;
                    #endif
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Resource_broker::release
//
void
Resource_broker::release()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("release", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        break;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "release");
                    dynamic_cast<POA_Resource*>(_star_stub->_star_servant_) -> release();
                    #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                                        volatile int i = 1;
                                                        i++;
                    #endif
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Resource_broker::BeginTrans
//
CORBA::Boolean
Resource_broker::BeginTrans()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("BeginTrans", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            CORBA::Boolean _star_r;
                            try
                            {
                                _star_r = _star_in -> read_boolean();
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "BeginTrans");
                    return dynamic_cast<POA_Resource*>(_star_stub->_star_servant_) -> BeginTrans();
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Resource_broker::set_recoverycoordinator
//
void
Resource_broker::set_recoverycoordinator(::CosTransactions::RecoveryCoordinator_ptr _star_a0)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("set_recoverycoordinator", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            STARMarshal(_star_a0, _star_out);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "set_recoverycoordinator");
                    dynamic_cast<POA_Resource*>(_star_stub->_star_servant_) -> set_recoverycoordinator(_star_a0);
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Resource_broker::heuristic_decision
//
void
Resource_broker::heuristic_decision()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("heuristic_decision", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "heuristic_decision");
                    dynamic_cast<POA_Resource*>(_star_stub->_star_servant_) -> heuristic_decision();
                    #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                                        volatile int i = 1;
                                                        i++;
                    #endif
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}
