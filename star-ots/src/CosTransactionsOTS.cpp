// *************************************************************************
//
// This File Is Automatically Generated by the StarBusIDL-to-C++ Compiler !
//
// Copyright (c) 2003
// Network Information Security Institute,Computer College,NUDT.
// ChangSha,Hunan,PRC
//
// All Rights Reserved
//
// *************************************************************************

// Version: 5.0.0

#include <STAR/CORBAClient.h>
#include <STAR/CORBAServer.h>
#include <CosTransactionsOTS_skel.h>
#include <CosTransactionsOTS.h>

namespace CosTransactions
{

STAR::TypeCodeConst _tc_Status(
"01f112001100000016010000010000001f00000049444c3a436f735472616e73616374696f6e7"
"32f5374617475733a312e3000100700000053746174757300000a0000000d0000005374617475"
"7341637469766500f11200150000005374617475734d61726b6564526f6c6c6261636b0000000"
"00f0000005374617475735072657061726564000010000000537461747573436f6d6d69747465"
"640011000000537461747573526f6c6c65644261636b000000000e000000537461747573556e6"
"b6e6f776e000000140000005374617475734e6f5472616e73616374696f6e0010000000537461"
"747573507265706172696e670011000000537461747573436f6d6d697474696e6700f11200120"
"00000537461747573526f6c6c696e674261636b00"
);

STAR::TypeCodeConst _tc_Vote(
"01f11200110000006d000000010000001d00000049444c3a436f735472616e73616374696f6e7"
"32f566f74653a312e300030001005000000566f746500730000030000000b000000566f746543"
"6f6d6d697400650d000000566f7465526f6c6c6261636b006b65640d000000566f74655265616"
"44f6e6c7900"
);

STAR::TypeCodeConst _tc_ResourceVote(
"01f1120011000000c6000000010000002500000049444c3a436f735472616e73616374696f6e7"
"32f5265736f75726365566f74653a312e30006f74650d0000005265736f75726365566f746500"
"6f6d6d060000000f00000052565f566f74655f436f6d6d697400641100000052565f566f74655"
"f526f6c6c6261636b007350721100000052565f566f74655f526561644f6e6c79000000000f00"
"000052565f4e6f74507265706172656400640d00000052565f436f6d6d69747465640073556e0"
"e00000052565f526f6c6c65644261636b00"
);

STAR::TypeCodeConst _tc_TRANSACTION_REQUIRED(
"01f112001600000058000000010000002d00000049444c3a436f735472616e73616374696f6e7"
"32f5452414e53414354494f4e5f52455155495245443a312e300065736f150000005452414e53"
"414354494f4e5f52455155495245440074655f00000000"
);

STAR::TypeCodeConst _tc_TRANSACTION_ROLLEDBACK(
"01ee1200160000005800000001ee12002f00000049444c3a436f735472616e73616374696f6e7"
"32f5452414e53414354494f4e5f524f4c4c45444241434b3a312e300000170000005452414e53"
"414354494f4e5f524f4c4c45444241434b000000000000"
);

STAR::TypeCodeConst _tc_INVALID_TRANSACTION(
"01ee1200160000005000000001ee12002c00000049444c3a436f735472616e73616374696f6e7"
"32f494e56414c49445f5452414e53414354494f4e3a312e300014000000494e56414c49445f54"
"52414e53414354494f4e0000000000"
);

STAR::TypeCodeConst _tc_WRONG_TRANSACTION(
"01ee1200160000005000000001ee12002a00000049444c3a436f735472616e73616374696f6e7"
"32f57524f4e475f5452414e53414354494f4e3a312e300012001200000057524f4e475f545241"
"4e53414354494f4e00000000000000"
);

STAR::TypeCodeConst _tc_HeuristicRollback(
"01ee1200160000005000000001ee12002a00000049444c3a436f735472616e73616374696f6e7"
"32f486575726973746963526f6c6c6261636b3a312e3000120012000000486575726973746963"
"526f6c6c6261636b00000000000000"
);

STAR::TypeCodeConst _tc_HeuristicCommit(
"01ee1200160000004800000001ee12002800000049444c3a436f735472616e73616374696f6e7"
"32f486575726973746963436f6d6d69743a312e300010000000486575726973746963436f6d6d"
"69740000000000"
);

STAR::TypeCodeConst _tc_HeuristicMixed(
"01ee1200160000004800000001ee12002700000049444c3a436f735472616e73616374696f6e7"
"32f4865757269737469634d697865643a312e3000000f0000004865757269737469634d697865"
"64000000000000"
);

STAR::TypeCodeConst _tc_HeuristicHazard(
"01ee1200160000004800000001ee12002800000049444c3a436f735472616e73616374696f6e7"
"32f48657572697374696348617a6172643a312e30001000000048657572697374696348617a61"
"72640000000000"
);

STAR::TypeCodeConst _tc_SubtransactionsUnavailable(
"01ee1200160000006000000001ee12003300000049444c3a436f735472616e73616374696f6e7"
"32f5375627472616e73616374696f6e73556e617661696c61626c653a312e3000001b00000053"
"75627472616e73616374696f6e73556e617661696c61626c65000000000000"
);

STAR::TypeCodeConst _tc_NotSubtransaction(
"01ee1200160000005000000001ee12002a00000049444c3a436f735472616e73616374696f6e7"
"32f4e6f745375627472616e73616374696f6e3a312e30001200120000004e6f74537562747261"
"6e73616374696f6e00000000000000"
);

STAR::TypeCodeConst _tc_Inactive(
"01ee1200160000004000000001ee12002100000049444c3a436f735472616e73616374696f6e7"
"32f496e6163746976653a312e300000000009000000496e6163746976650000000000000000"
);

STAR::TypeCodeConst _tc_NotPrepared(
"01ee1200160000004000000001ee12002400000049444c3a436f735472616e73616374696f6e7"
"32f4e6f7450726570617265643a312e30000c0000004e6f7450726570617265640000000000"
);

STAR::TypeCodeConst _tc_NoTransaction(
"01ee1200160000004800000001ee12002600000049444c3a436f735472616e73616374696f6e7"
"32f4e6f5472616e73616374696f6e3a312e300012000e0000004e6f5472616e73616374696f6e"
"00120000000000"
);

STAR::TypeCodeConst _tc_InvalidControl(
"01ee1200160000004800000001ee12002700000049444c3a436f735472616e73616374696f6e7"
"32f496e76616c6964436f6e74726f6c3a312e3000000f000000496e76616c6964436f6e74726f"
"6c000000000000"
);

STAR::TypeCodeConst _tc_Unavailable(
"01ee1200160000004000000001ee12002400000049444c3a436f735472616e73616374696f6e7"
"32f556e617661696c61626c653a312e30000c000000556e617661696c61626c650000000000"
);

STAR::TypeCodeConst _tc_SynchronizationUnavailable(
"01ee1200160000006000000001ee12003300000049444c3a436f735472616e73616374696f6e7"
"32f53796e6368726f6e697a6174696f6e556e617661696c61626c653a312e3000001b00000053"
"796e6368726f6e697a6174696f6e556e617661696c61626c65000000000000"
);

STAR::TypeCodeConst _tc_TransactionFactory(
"010000000e0000004b00000001ee12002b00000049444c3a436f735472616e73616374696f6e7"
"32f5472616e73616374696f6e466163746f72793a312e300000130000005472616e7361637469"
"6f6e466163746f727900"
);

STAR::TypeCodeConst _tc_Control(
"010000000e0000003400000001ee12002000000049444c3a436f735472616e73616374696f6e7"
"32f436f6e74726f6c3a312e300008000000436f6e74726f6c00"
);

STAR::TypeCodeConst _tc_Terminator(
"010000000e0000003b00000001ee12002300000049444c3a436f735472616e73616374696f6e7"
"32f5465726d696e61746f723a312e3000000b0000005465726d696e61746f7200"
);

STAR::TypeCodeConst _tc_Coordinator(
"010000000e0000003c00000001ee12002400000049444c3a436f735472616e73616374696f6e7"
"32f436f6f7264696e61746f723a312e30000c000000436f6f7264696e61746f7200"
);

STAR::TypeCodeConst Coordinator::_tc_RCV(
"010000000f000000aa010000010000002800000049444c3a436f735472616e73616374696f6e7"
"32f436f6f7264696e61746f722f5243563a312e30000400000052435600030000000200000072"
"0051000e0000002900000001ef12001100000049444c3a5265736f757263653a312e3000bc690"
"0090000005265736f757263650000000003000000726300000e0000004c00000001bc69002c00"
"000049444c3a436f735472616e73616374696f6e732f5265636f76657279436f6f7264696e617"
"46f723a312e3000140000005265636f76657279436f6f7264696e61746f720003000000727600"
"0011000000c6000000010000002500000049444c3a436f735472616e73616374696f6e732f526"
"5736f75726365566f74653a312e30009b7d000d0000005265736f75726365566f746500f01200"
"060000000f00000052565f566f74655f436f6d6d697400001100000052565f566f74655f526f6"
"c6c6261636b008e25101100000052565f566f74655f526561644f6e6c7900ffffff0f00000052"
"565f4e6f74507265706172656400000d00000052565f436f6d6d697474656400ef12000e00000"
"052565f526f6c6c65644261636b00"
);

STAR::TypeCodeConst Coordinator::_tc_RCVs(
"012281001500000004020000018e25102900000049444c3a436f735472616e73616374696f6e7"
"32f436f6f7264696e61746f722f524356733a312e3000ee120005000000524356730000000013"
"000000bc01000001cc5b000f000000aa01000001fa00002800000049444c3a436f735472616e7"
"3616374696f6e732f436f6f7264696e61746f722f5243563a312e300004000000524356000300"
"000002000000720000000e0000002900000001277d001100000049444c3a5265736f757263653"
"a312e3000a77d00090000005265736f757263650000000003000000726300000e0000004c0000"
"00010000002c00000049444c3a436f735472616e73616374696f6e732f5265636f76657279436"
"f6f7264696e61746f723a312e3000140000005265636f76657279436f6f7264696e61746f7200"
"030000007276000011000000c600000001ed12002500000049444c3a436f735472616e7361637"
"4696f6e732f5265736f75726365566f74653a312e30007a63000d0000005265736f7572636556"
"6f746500ee1200060000000f00000052565f566f74655f436f6d6d697400001100000052565f5"
"66f74655f526f6c6c6261636b00277d001100000052565f566f74655f526561644f6e6c7900e0"
"7f000f00000052565f4e6f74507265706172656400000d00000052565f436f6d6d69747465640"
"00000000e00000052565f526f6c6c65644261636b00201000000000"
);

STAR::TypeCodeConst _tc_RecoveryCoordinator(
"010000000e0000004c000000016363352c00000049444c3a436f735472616e73616374696f6e7"
"32f5265636f76657279436f6f7264696e61746f723a312e3000140000005265636f7665727943"
"6f6f7264696e61746f7200"
);

STAR::TypeCodeConst _tc_TransactionalObject(
"010000000e0000004c00000001ee12002c00000049444c3a436f735472616e73616374696f6e7"
"32f5472616e73616374696f6e616c4f626a6563743a312e3000140000005472616e7361637469"
"6f6e616c4f626a65637400"
);

} // End of namespace CosTransactions

//
// Enum declare ::CosTransactions::Status
//
void
operator<<=(CORBA::Any& any, CosTransactions::Status v)
{
    any.replace(CosTransactions::_tc_Status, new CORBA::ULong((CORBA::ULong)v), true);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::Status& v)
{
    if(any.check_type(CosTransactions::_tc_Status))
    {
        v = (CosTransactions::Status)(*(CORBA::ULong*)any.value());
        return true;
    }
    else
        return false;
}

//
// Enum declare ::CosTransactions::Vote
//
void
operator<<=(CORBA::Any& any, CosTransactions::Vote v)
{
    any.replace(CosTransactions::_tc_Vote, new CORBA::ULong((CORBA::ULong)v), true);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::Vote& v)
{
    if(any.check_type(CosTransactions::_tc_Vote))
    {
        v = (CosTransactions::Vote)(*(CORBA::ULong*)any.value());
        return true;
    }
    else
        return false;
}

//
// Enum declare ::CosTransactions::ResourceVote
//
void
operator<<=(CORBA::Any& any, CosTransactions::ResourceVote v)
{
    any.replace(CosTransactions::_tc_ResourceVote, new CORBA::ULong((CORBA::ULong)v), true);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::ResourceVote& v)
{
    if(any.check_type(CosTransactions::_tc_ResourceVote))
    {
        v = (CosTransactions::ResourceVote)(*(CORBA::ULong*)any.value());
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::TRANSACTION_REQUIRED
//
CosTransactions::TRANSACTION_REQUIRED::TRANSACTION_REQUIRED(const TRANSACTION_REQUIRED& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::TRANSACTION_REQUIRED&
CosTransactions::TRANSACTION_REQUIRED::operator=(const TRANSACTION_REQUIRED&)
{
    return *this;
}

CosTransactions::TRANSACTION_REQUIRED*
CosTransactions::TRANSACTION_REQUIRED::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<TRANSACTION_REQUIRED*>(p);
}

const CosTransactions::TRANSACTION_REQUIRED*
CosTransactions::TRANSACTION_REQUIRED::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const TRANSACTION_REQUIRED*>(p);
}

const char*
CosTransactions::TRANSACTION_REQUIRED::_name() const
{
    return "TRANSACTION_REQUIRED";
}

const char*
CosTransactions::TRANSACTION_REQUIRED::_rep_id() const
{
    return "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0";
}

char*
CosTransactions::TRANSACTION_REQUIRED::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::TRANSACTION_REQUIRED");
}

CORBA::Exception*
CosTransactions::TRANSACTION_REQUIRED::_STAR_clone() const
{
    return new TRANSACTION_REQUIRED(*this);
}

void
CosTransactions::TRANSACTION_REQUIRED::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(TRANSACTION_REQUIRED&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::TRANSACTION_REQUIRED* v)
{
    static const STAR::Info< CosTransactions::TRANSACTION_REQUIRED > info;
    any.replace(CosTransactions::_tc_TRANSACTION_REQUIRED, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::TRANSACTION_REQUIRED& v)
{
    any <<= new CosTransactions::TRANSACTION_REQUIRED(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::TRANSACTION_REQUIRED*& v)
{
    if(any.check_type(CosTransactions::_tc_TRANSACTION_REQUIRED))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::TRANSACTION_REQUIRED* val = new CosTransactions::TRANSACTION_REQUIRED;
            CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::TRANSACTION_REQUIRED*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::TRANSACTION_ROLLEDBACK
//
CosTransactions::TRANSACTION_ROLLEDBACK::TRANSACTION_ROLLEDBACK(const TRANSACTION_ROLLEDBACK& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::TRANSACTION_ROLLEDBACK&
CosTransactions::TRANSACTION_ROLLEDBACK::operator=(const TRANSACTION_ROLLEDBACK&)
{
    return *this;
}

CosTransactions::TRANSACTION_ROLLEDBACK*
CosTransactions::TRANSACTION_ROLLEDBACK::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<TRANSACTION_ROLLEDBACK*>(p);
}

const CosTransactions::TRANSACTION_ROLLEDBACK*
CosTransactions::TRANSACTION_ROLLEDBACK::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const TRANSACTION_ROLLEDBACK*>(p);
}

const char*
CosTransactions::TRANSACTION_ROLLEDBACK::_name() const
{
    return "TRANSACTION_ROLLEDBACK";
}

const char*
CosTransactions::TRANSACTION_ROLLEDBACK::_rep_id() const
{
    return "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0";
}

char*
CosTransactions::TRANSACTION_ROLLEDBACK::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::TRANSACTION_ROLLEDBACK");
}

CORBA::Exception*
CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_clone() const
{
    return new TRANSACTION_ROLLEDBACK(*this);
}

void
CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(TRANSACTION_ROLLEDBACK&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::TRANSACTION_ROLLEDBACK* v)
{
    static const STAR::Info< CosTransactions::TRANSACTION_ROLLEDBACK > info;
    any.replace(CosTransactions::_tc_TRANSACTION_ROLLEDBACK, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::TRANSACTION_ROLLEDBACK& v)
{
    any <<= new CosTransactions::TRANSACTION_ROLLEDBACK(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::TRANSACTION_ROLLEDBACK*& v)
{
    if(any.check_type(CosTransactions::_tc_TRANSACTION_ROLLEDBACK))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::TRANSACTION_ROLLEDBACK* val = new CosTransactions::TRANSACTION_ROLLEDBACK;
            CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::TRANSACTION_ROLLEDBACK*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::INVALID_TRANSACTION
//
CosTransactions::INVALID_TRANSACTION::INVALID_TRANSACTION(const INVALID_TRANSACTION& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::INVALID_TRANSACTION&
CosTransactions::INVALID_TRANSACTION::operator=(const INVALID_TRANSACTION&)
{
    return *this;
}

CosTransactions::INVALID_TRANSACTION*
CosTransactions::INVALID_TRANSACTION::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<INVALID_TRANSACTION*>(p);
}

const CosTransactions::INVALID_TRANSACTION*
CosTransactions::INVALID_TRANSACTION::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const INVALID_TRANSACTION*>(p);
}

const char*
CosTransactions::INVALID_TRANSACTION::_name() const
{
    return "INVALID_TRANSACTION";
}

const char*
CosTransactions::INVALID_TRANSACTION::_rep_id() const
{
    return "IDL:CosTransactions/INVALID_TRANSACTION:1.0";
}

char*
CosTransactions::INVALID_TRANSACTION::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::INVALID_TRANSACTION");
}

CORBA::Exception*
CosTransactions::INVALID_TRANSACTION::_STAR_clone() const
{
    return new INVALID_TRANSACTION(*this);
}

void
CosTransactions::INVALID_TRANSACTION::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(INVALID_TRANSACTION&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::INVALID_TRANSACTION* v)
{
    static const STAR::Info< CosTransactions::INVALID_TRANSACTION > info;
    any.replace(CosTransactions::_tc_INVALID_TRANSACTION, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::INVALID_TRANSACTION& v)
{
    any <<= new CosTransactions::INVALID_TRANSACTION(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::INVALID_TRANSACTION*& v)
{
    if(any.check_type(CosTransactions::_tc_INVALID_TRANSACTION))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::INVALID_TRANSACTION* val = new CosTransactions::INVALID_TRANSACTION;
            CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::INVALID_TRANSACTION*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::WRONG_TRANSACTION
//
CosTransactions::WRONG_TRANSACTION::WRONG_TRANSACTION(const WRONG_TRANSACTION& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::WRONG_TRANSACTION&
CosTransactions::WRONG_TRANSACTION::operator=(const WRONG_TRANSACTION&)
{
    return *this;
}

CosTransactions::WRONG_TRANSACTION*
CosTransactions::WRONG_TRANSACTION::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<WRONG_TRANSACTION*>(p);
}

const CosTransactions::WRONG_TRANSACTION*
CosTransactions::WRONG_TRANSACTION::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const WRONG_TRANSACTION*>(p);
}

const char*
CosTransactions::WRONG_TRANSACTION::_name() const
{
    return "WRONG_TRANSACTION";
}

const char*
CosTransactions::WRONG_TRANSACTION::_rep_id() const
{
    return "IDL:CosTransactions/WRONG_TRANSACTION:1.0";
}

char*
CosTransactions::WRONG_TRANSACTION::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::WRONG_TRANSACTION");
}

CORBA::Exception*
CosTransactions::WRONG_TRANSACTION::_STAR_clone() const
{
    return new WRONG_TRANSACTION(*this);
}

void
CosTransactions::WRONG_TRANSACTION::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(WRONG_TRANSACTION&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::WRONG_TRANSACTION* v)
{
    static const STAR::Info< CosTransactions::WRONG_TRANSACTION > info;
    any.replace(CosTransactions::_tc_WRONG_TRANSACTION, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::WRONG_TRANSACTION& v)
{
    any <<= new CosTransactions::WRONG_TRANSACTION(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::WRONG_TRANSACTION*& v)
{
    if(any.check_type(CosTransactions::_tc_WRONG_TRANSACTION))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::WRONG_TRANSACTION* val = new CosTransactions::WRONG_TRANSACTION;
            CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::WRONG_TRANSACTION*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::HeuristicRollback
//
CosTransactions::HeuristicRollback::HeuristicRollback(const HeuristicRollback& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::HeuristicRollback&
CosTransactions::HeuristicRollback::operator=(const HeuristicRollback&)
{
    return *this;
}

CosTransactions::HeuristicRollback*
CosTransactions::HeuristicRollback::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<HeuristicRollback*>(p);
}

const CosTransactions::HeuristicRollback*
CosTransactions::HeuristicRollback::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const HeuristicRollback*>(p);
}

const char*
CosTransactions::HeuristicRollback::_name() const
{
    return "HeuristicRollback";
}

const char*
CosTransactions::HeuristicRollback::_rep_id() const
{
    return "IDL:CosTransactions/HeuristicRollback:1.0";
}

char*
CosTransactions::HeuristicRollback::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::HeuristicRollback");
}

CORBA::Exception*
CosTransactions::HeuristicRollback::_STAR_clone() const
{
    return new HeuristicRollback(*this);
}

void
CosTransactions::HeuristicRollback::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::HeuristicRollback::_STAR_unmarshal(HeuristicRollback&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/HeuristicRollback:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::HeuristicRollback* v)
{
    static const STAR::Info< CosTransactions::HeuristicRollback > info;
    any.replace(CosTransactions::_tc_HeuristicRollback, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::HeuristicRollback& v)
{
    any <<= new CosTransactions::HeuristicRollback(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::HeuristicRollback*& v)
{
    if(any.check_type(CosTransactions::_tc_HeuristicRollback))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::HeuristicRollback* val = new CosTransactions::HeuristicRollback;
            CosTransactions::HeuristicRollback::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::HeuristicRollback*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::HeuristicCommit
//
CosTransactions::HeuristicCommit::HeuristicCommit(const HeuristicCommit& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::HeuristicCommit&
CosTransactions::HeuristicCommit::operator=(const HeuristicCommit&)
{
    return *this;
}

CosTransactions::HeuristicCommit*
CosTransactions::HeuristicCommit::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<HeuristicCommit*>(p);
}

const CosTransactions::HeuristicCommit*
CosTransactions::HeuristicCommit::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const HeuristicCommit*>(p);
}

const char*
CosTransactions::HeuristicCommit::_name() const
{
    return "HeuristicCommit";
}

const char*
CosTransactions::HeuristicCommit::_rep_id() const
{
    return "IDL:CosTransactions/HeuristicCommit:1.0";
}

char*
CosTransactions::HeuristicCommit::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::HeuristicCommit");
}

CORBA::Exception*
CosTransactions::HeuristicCommit::_STAR_clone() const
{
    return new HeuristicCommit(*this);
}

void
CosTransactions::HeuristicCommit::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::HeuristicCommit::_STAR_unmarshal(HeuristicCommit&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/HeuristicCommit:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::HeuristicCommit* v)
{
    static const STAR::Info< CosTransactions::HeuristicCommit > info;
    any.replace(CosTransactions::_tc_HeuristicCommit, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::HeuristicCommit& v)
{
    any <<= new CosTransactions::HeuristicCommit(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::HeuristicCommit*& v)
{
    if(any.check_type(CosTransactions::_tc_HeuristicCommit))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::HeuristicCommit* val = new CosTransactions::HeuristicCommit;
            CosTransactions::HeuristicCommit::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::HeuristicCommit*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::HeuristicMixed
//
CosTransactions::HeuristicMixed::HeuristicMixed(const HeuristicMixed& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::HeuristicMixed&
CosTransactions::HeuristicMixed::operator=(const HeuristicMixed&)
{
    return *this;
}

CosTransactions::HeuristicMixed*
CosTransactions::HeuristicMixed::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<HeuristicMixed*>(p);
}

const CosTransactions::HeuristicMixed*
CosTransactions::HeuristicMixed::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const HeuristicMixed*>(p);
}

const char*
CosTransactions::HeuristicMixed::_name() const
{
    return "HeuristicMixed";
}

const char*
CosTransactions::HeuristicMixed::_rep_id() const
{
    return "IDL:CosTransactions/HeuristicMixed:1.0";
}

char*
CosTransactions::HeuristicMixed::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::HeuristicMixed");
}

CORBA::Exception*
CosTransactions::HeuristicMixed::_STAR_clone() const
{
    return new HeuristicMixed(*this);
}

void
CosTransactions::HeuristicMixed::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::HeuristicMixed::_STAR_unmarshal(HeuristicMixed&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/HeuristicMixed:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::HeuristicMixed* v)
{
    static const STAR::Info< CosTransactions::HeuristicMixed > info;
    any.replace(CosTransactions::_tc_HeuristicMixed, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::HeuristicMixed& v)
{
    any <<= new CosTransactions::HeuristicMixed(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::HeuristicMixed*& v)
{
    if(any.check_type(CosTransactions::_tc_HeuristicMixed))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::HeuristicMixed* val = new CosTransactions::HeuristicMixed;
            CosTransactions::HeuristicMixed::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::HeuristicMixed*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::HeuristicHazard
//
CosTransactions::HeuristicHazard::HeuristicHazard(const HeuristicHazard& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::HeuristicHazard&
CosTransactions::HeuristicHazard::operator=(const HeuristicHazard&)
{
    return *this;
}

CosTransactions::HeuristicHazard*
CosTransactions::HeuristicHazard::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<HeuristicHazard*>(p);
}

const CosTransactions::HeuristicHazard*
CosTransactions::HeuristicHazard::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const HeuristicHazard*>(p);
}

const char*
CosTransactions::HeuristicHazard::_name() const
{
    return "HeuristicHazard";
}

const char*
CosTransactions::HeuristicHazard::_rep_id() const
{
    return "IDL:CosTransactions/HeuristicHazard:1.0";
}

char*
CosTransactions::HeuristicHazard::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::HeuristicHazard");
}

CORBA::Exception*
CosTransactions::HeuristicHazard::_STAR_clone() const
{
    return new HeuristicHazard(*this);
}

void
CosTransactions::HeuristicHazard::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::HeuristicHazard::_STAR_unmarshal(HeuristicHazard&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/HeuristicHazard:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::HeuristicHazard* v)
{
    static const STAR::Info< CosTransactions::HeuristicHazard > info;
    any.replace(CosTransactions::_tc_HeuristicHazard, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::HeuristicHazard& v)
{
    any <<= new CosTransactions::HeuristicHazard(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::HeuristicHazard*& v)
{
    if(any.check_type(CosTransactions::_tc_HeuristicHazard))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::HeuristicHazard* val = new CosTransactions::HeuristicHazard;
            CosTransactions::HeuristicHazard::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::HeuristicHazard*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::SubtransactionsUnavailable
//
CosTransactions::SubtransactionsUnavailable::SubtransactionsUnavailable(const SubtransactionsUnavailable& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::SubtransactionsUnavailable&
CosTransactions::SubtransactionsUnavailable::operator=(const SubtransactionsUnavailable&)
{
    return *this;
}

CosTransactions::SubtransactionsUnavailable*
CosTransactions::SubtransactionsUnavailable::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<SubtransactionsUnavailable*>(p);
}

const CosTransactions::SubtransactionsUnavailable*
CosTransactions::SubtransactionsUnavailable::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const SubtransactionsUnavailable*>(p);
}

const char*
CosTransactions::SubtransactionsUnavailable::_name() const
{
    return "SubtransactionsUnavailable";
}

const char*
CosTransactions::SubtransactionsUnavailable::_rep_id() const
{
    return "IDL:CosTransactions/SubtransactionsUnavailable:1.0";
}

char*
CosTransactions::SubtransactionsUnavailable::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::SubtransactionsUnavailable");
}

CORBA::Exception*
CosTransactions::SubtransactionsUnavailable::_STAR_clone() const
{
    return new SubtransactionsUnavailable(*this);
}

void
CosTransactions::SubtransactionsUnavailable::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::SubtransactionsUnavailable::_STAR_unmarshal(SubtransactionsUnavailable&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/SubtransactionsUnavailable:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::SubtransactionsUnavailable* v)
{
    static const STAR::Info< CosTransactions::SubtransactionsUnavailable > info;
    any.replace(CosTransactions::_tc_SubtransactionsUnavailable, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::SubtransactionsUnavailable& v)
{
    any <<= new CosTransactions::SubtransactionsUnavailable(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::SubtransactionsUnavailable*& v)
{
    if(any.check_type(CosTransactions::_tc_SubtransactionsUnavailable))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::SubtransactionsUnavailable* val = new CosTransactions::SubtransactionsUnavailable;
            CosTransactions::SubtransactionsUnavailable::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::SubtransactionsUnavailable*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::NotSubtransaction
//
CosTransactions::NotSubtransaction::NotSubtransaction(const NotSubtransaction& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::NotSubtransaction&
CosTransactions::NotSubtransaction::operator=(const NotSubtransaction&)
{
    return *this;
}

CosTransactions::NotSubtransaction*
CosTransactions::NotSubtransaction::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<NotSubtransaction*>(p);
}

const CosTransactions::NotSubtransaction*
CosTransactions::NotSubtransaction::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const NotSubtransaction*>(p);
}

const char*
CosTransactions::NotSubtransaction::_name() const
{
    return "NotSubtransaction";
}

const char*
CosTransactions::NotSubtransaction::_rep_id() const
{
    return "IDL:CosTransactions/NotSubtransaction:1.0";
}

char*
CosTransactions::NotSubtransaction::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::NotSubtransaction");
}

CORBA::Exception*
CosTransactions::NotSubtransaction::_STAR_clone() const
{
    return new NotSubtransaction(*this);
}

void
CosTransactions::NotSubtransaction::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::NotSubtransaction::_STAR_unmarshal(NotSubtransaction&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/NotSubtransaction:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::NotSubtransaction* v)
{
    static const STAR::Info< CosTransactions::NotSubtransaction > info;
    any.replace(CosTransactions::_tc_NotSubtransaction, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::NotSubtransaction& v)
{
    any <<= new CosTransactions::NotSubtransaction(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::NotSubtransaction*& v)
{
    if(any.check_type(CosTransactions::_tc_NotSubtransaction))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::NotSubtransaction* val = new CosTransactions::NotSubtransaction;
            CosTransactions::NotSubtransaction::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::NotSubtransaction*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::Inactive
//
CosTransactions::Inactive::Inactive(const Inactive& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::Inactive&
CosTransactions::Inactive::operator=(const Inactive&)
{
    return *this;
}

CosTransactions::Inactive*
CosTransactions::Inactive::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<Inactive*>(p);
}

const CosTransactions::Inactive*
CosTransactions::Inactive::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const Inactive*>(p);
}

const char*
CosTransactions::Inactive::_name() const
{
    return "Inactive";
}

const char*
CosTransactions::Inactive::_rep_id() const
{
    return "IDL:CosTransactions/Inactive:1.0";
}

char*
CosTransactions::Inactive::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::Inactive");
}

CORBA::Exception*
CosTransactions::Inactive::_STAR_clone() const
{
    return new Inactive(*this);
}

void
CosTransactions::Inactive::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::Inactive::_STAR_unmarshal(Inactive&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/Inactive:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::Inactive* v)
{
    static const STAR::Info< CosTransactions::Inactive > info;
    any.replace(CosTransactions::_tc_Inactive, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::Inactive& v)
{
    any <<= new CosTransactions::Inactive(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::Inactive*& v)
{
    if(any.check_type(CosTransactions::_tc_Inactive))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::Inactive* val = new CosTransactions::Inactive;
            CosTransactions::Inactive::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::Inactive*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::NotPrepared
//
CosTransactions::NotPrepared::NotPrepared(const NotPrepared& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::NotPrepared&
CosTransactions::NotPrepared::operator=(const NotPrepared&)
{
    return *this;
}

CosTransactions::NotPrepared*
CosTransactions::NotPrepared::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<NotPrepared*>(p);
}

const CosTransactions::NotPrepared*
CosTransactions::NotPrepared::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const NotPrepared*>(p);
}

const char*
CosTransactions::NotPrepared::_name() const
{
    return "NotPrepared";
}

const char*
CosTransactions::NotPrepared::_rep_id() const
{
    return "IDL:CosTransactions/NotPrepared:1.0";
}

char*
CosTransactions::NotPrepared::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::NotPrepared");
}

CORBA::Exception*
CosTransactions::NotPrepared::_STAR_clone() const
{
    return new NotPrepared(*this);
}

void
CosTransactions::NotPrepared::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::NotPrepared::_STAR_unmarshal(NotPrepared&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/NotPrepared:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::NotPrepared* v)
{
    static const STAR::Info< CosTransactions::NotPrepared > info;
    any.replace(CosTransactions::_tc_NotPrepared, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::NotPrepared& v)
{
    any <<= new CosTransactions::NotPrepared(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::NotPrepared*& v)
{
    if(any.check_type(CosTransactions::_tc_NotPrepared))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::NotPrepared* val = new CosTransactions::NotPrepared;
            CosTransactions::NotPrepared::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::NotPrepared*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::NoTransaction
//
CosTransactions::NoTransaction::NoTransaction(const NoTransaction& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::NoTransaction&
CosTransactions::NoTransaction::operator=(const NoTransaction&)
{
    return *this;
}

CosTransactions::NoTransaction*
CosTransactions::NoTransaction::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<NoTransaction*>(p);
}

const CosTransactions::NoTransaction*
CosTransactions::NoTransaction::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const NoTransaction*>(p);
}

const char*
CosTransactions::NoTransaction::_name() const
{
    return "NoTransaction";
}

const char*
CosTransactions::NoTransaction::_rep_id() const
{
    return "IDL:CosTransactions/NoTransaction:1.0";
}

char*
CosTransactions::NoTransaction::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::NoTransaction");
}

CORBA::Exception*
CosTransactions::NoTransaction::_STAR_clone() const
{
    return new NoTransaction(*this);
}

void
CosTransactions::NoTransaction::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::NoTransaction::_STAR_unmarshal(NoTransaction&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/NoTransaction:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::NoTransaction* v)
{
    static const STAR::Info< CosTransactions::NoTransaction > info;
    any.replace(CosTransactions::_tc_NoTransaction, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::NoTransaction& v)
{
    any <<= new CosTransactions::NoTransaction(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::NoTransaction*& v)
{
    if(any.check_type(CosTransactions::_tc_NoTransaction))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::NoTransaction* val = new CosTransactions::NoTransaction;
            CosTransactions::NoTransaction::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::NoTransaction*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::InvalidControl
//
CosTransactions::InvalidControl::InvalidControl(const InvalidControl& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::InvalidControl&
CosTransactions::InvalidControl::operator=(const InvalidControl&)
{
    return *this;
}

CosTransactions::InvalidControl*
CosTransactions::InvalidControl::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<InvalidControl*>(p);
}

const CosTransactions::InvalidControl*
CosTransactions::InvalidControl::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const InvalidControl*>(p);
}

const char*
CosTransactions::InvalidControl::_name() const
{
    return "InvalidControl";
}

const char*
CosTransactions::InvalidControl::_rep_id() const
{
    return "IDL:CosTransactions/InvalidControl:1.0";
}

char*
CosTransactions::InvalidControl::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::InvalidControl");
}

CORBA::Exception*
CosTransactions::InvalidControl::_STAR_clone() const
{
    return new InvalidControl(*this);
}

void
CosTransactions::InvalidControl::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::InvalidControl::_STAR_unmarshal(InvalidControl&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/InvalidControl:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::InvalidControl* v)
{
    static const STAR::Info< CosTransactions::InvalidControl > info;
    any.replace(CosTransactions::_tc_InvalidControl, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::InvalidControl& v)
{
    any <<= new CosTransactions::InvalidControl(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::InvalidControl*& v)
{
    if(any.check_type(CosTransactions::_tc_InvalidControl))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::InvalidControl* val = new CosTransactions::InvalidControl;
            CosTransactions::InvalidControl::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::InvalidControl*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::Unavailable
//
CosTransactions::Unavailable::Unavailable(const Unavailable& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::Unavailable&
CosTransactions::Unavailable::operator=(const Unavailable&)
{
    return *this;
}

CosTransactions::Unavailable*
CosTransactions::Unavailable::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<Unavailable*>(p);
}

const CosTransactions::Unavailable*
CosTransactions::Unavailable::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const Unavailable*>(p);
}

const char*
CosTransactions::Unavailable::_name() const
{
    return "Unavailable";
}

const char*
CosTransactions::Unavailable::_rep_id() const
{
    return "IDL:CosTransactions/Unavailable:1.0";
}

char*
CosTransactions::Unavailable::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::Unavailable");
}

CORBA::Exception*
CosTransactions::Unavailable::_STAR_clone() const
{
    return new Unavailable(*this);
}

void
CosTransactions::Unavailable::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::Unavailable::_STAR_unmarshal(Unavailable&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/Unavailable:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::Unavailable* v)
{
    static const STAR::Info< CosTransactions::Unavailable > info;
    any.replace(CosTransactions::_tc_Unavailable, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::Unavailable& v)
{
    any <<= new CosTransactions::Unavailable(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::Unavailable*& v)
{
    if(any.check_type(CosTransactions::_tc_Unavailable))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::Unavailable* val = new CosTransactions::Unavailable;
            CosTransactions::Unavailable::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::Unavailable*)any.value();
        return true;
    }
    else
        return false;
}

//
// Exception declare ::CosTransactions::SynchronizationUnavailable
//
CosTransactions::SynchronizationUnavailable::SynchronizationUnavailable(const SynchronizationUnavailable& _star_a)
    : CORBA::UserException(_star_a)
{
}

CosTransactions::SynchronizationUnavailable&
CosTransactions::SynchronizationUnavailable::operator=(const SynchronizationUnavailable&)
{
    return *this;
}

CosTransactions::SynchronizationUnavailable*
CosTransactions::SynchronizationUnavailable::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<SynchronizationUnavailable*>(p);
}

const CosTransactions::SynchronizationUnavailable*
CosTransactions::SynchronizationUnavailable::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const SynchronizationUnavailable*>(p);
}

const char*
CosTransactions::SynchronizationUnavailable::_name() const
{
    return "SynchronizationUnavailable";
}

const char*
CosTransactions::SynchronizationUnavailable::_rep_id() const
{
    return "IDL:CosTransactions/SynchronizationUnavailable:1.0";
}

char*
CosTransactions::SynchronizationUnavailable::_to_string() const
{
    return _STAR_defaultToString("CosTransactions::SynchronizationUnavailable");
}

CORBA::Exception*
CosTransactions::SynchronizationUnavailable::_STAR_clone() const
{
    return new SynchronizationUnavailable(*this);
}

void
CosTransactions::SynchronizationUnavailable::_STAR_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::SynchronizationUnavailable::_STAR_unmarshal(SynchronizationUnavailable&, STAR::InputStreamImpl* _star_in)
{
    CORBA::String_var id = _star_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/SynchronizationUnavailable:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::SynchronizationUnavailable* v)
{
    static const STAR::Info< CosTransactions::SynchronizationUnavailable > info;
    any.replace(CosTransactions::_tc_SynchronizationUnavailable, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::SynchronizationUnavailable& v)
{
    any <<= new CosTransactions::SynchronizationUnavailable(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::SynchronizationUnavailable*& v)
{
    if(any.check_type(CosTransactions::_tc_SynchronizationUnavailable))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::SynchronizationUnavailable* val = new CosTransactions::SynchronizationUnavailable;
            CosTransactions::SynchronizationUnavailable::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::SynchronizationUnavailable*)any.value();
        return true;
    }
    else
        return false;
}

//
// Interface declare ::CosTransactions::TransactionFactory
//
const char* CosTransactions::TransactionFactory::ids_[] =
{
    "IDL:CosTransactions/TransactionFactory:1.0",
    0
};

void
STARDuplicate(CosTransactions::TransactionFactory_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(CosTransactions::TransactionFactory_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

CosTransactions::TransactionFactory_ptr
CosTransactions::TransactionFactory::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        TransactionFactory_ptr v = dynamic_cast<TransactionFactory_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            CosTransactions::TransactionFactory_broker* val = new CosTransactions::TransactionFactory_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

CosTransactions::TransactionFactory_ptr
CosTransactions::TransactionFactory::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

CosTransactions::TransactionFactory_ptr
CosTransactions::TransactionFactory::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        TransactionFactory_ptr v = dynamic_cast<TransactionFactory_ptr>(p);
        if(v)
            return _duplicate(v);

        CosTransactions::TransactionFactory_broker* val = new CosTransactions::TransactionFactory_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

CosTransactions::TransactionFactory_ptr
CosTransactions::TransactionFactory::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
CosTransactions::TransactionFactory::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(CosTransactions::TransactionFactory_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(CosTransactions::TransactionFactory_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    CosTransactions::TransactionFactory_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        CosTransactions::TransactionFactory_broker* _star_obj = new CosTransactions::TransactionFactory_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = CosTransactions::TransactionFactory::_nil();
}

void
operator<<=(CORBA::Any& any, CosTransactions::TransactionFactory_ptr* v)
{
    any.replace(CosTransactions::_tc_TransactionFactory, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, CosTransactions::TransactionFactory_ptr v)
{
    CosTransactions::TransactionFactory_ptr val = CosTransactions::TransactionFactory::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::TransactionFactory_ptr& v)
{
    if(any.check_type(CosTransactions::_tc_TransactionFactory))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<CosTransactions::TransactionFactory_ptr>(val)))
            {
                CosTransactions::TransactionFactory_broker* obj = new CosTransactions::TransactionFactory_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = CosTransactions::TransactionFactory::_nil();

        return true;
    }
    else
        return false;
}

const char**
CosTransactions::TransactionFactory_broker::_STAR_ids() const
{
    return ids_;
}

//
// Operation declare CosTransactions::TransactionFactory_broker::create
//
::CosTransactions::Control_ptr
CosTransactions::TransactionFactory_broker::create(CORBA::ULong _star_a0)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("create", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            _star_out -> write_ulong(_star_a0);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::CosTransactions::Control_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.inout(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "create");
                    return dynamic_cast<POA_CosTransactions::TransactionFactory*>(_star_stub->_star_servant_) -> create(_star_a0);
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Interface declare ::CosTransactions::Control
//
const char* CosTransactions::Control::ids_[] =
{
    "IDL:CosTransactions/Control:1.0",
    0
};

void
STARDuplicate(CosTransactions::Control_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(CosTransactions::Control_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

CosTransactions::Control_ptr
CosTransactions::Control::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Control_ptr v = dynamic_cast<Control_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            CosTransactions::Control_broker* val = new CosTransactions::Control_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

CosTransactions::Control_ptr
CosTransactions::Control::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

CosTransactions::Control_ptr
CosTransactions::Control::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Control_ptr v = dynamic_cast<Control_ptr>(p);
        if(v)
            return _duplicate(v);

        CosTransactions::Control_broker* val = new CosTransactions::Control_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

CosTransactions::Control_ptr
CosTransactions::Control::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
CosTransactions::Control::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(CosTransactions::Control_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(CosTransactions::Control_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    CosTransactions::Control_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        CosTransactions::Control_broker* _star_obj = new CosTransactions::Control_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = CosTransactions::Control::_nil();
}

void
operator<<=(CORBA::Any& any, CosTransactions::Control_ptr* v)
{
    any.replace(CosTransactions::_tc_Control, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, CosTransactions::Control_ptr v)
{
    CosTransactions::Control_ptr val = CosTransactions::Control::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::Control_ptr& v)
{
    if(any.check_type(CosTransactions::_tc_Control))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<CosTransactions::Control_ptr>(val)))
            {
                CosTransactions::Control_broker* obj = new CosTransactions::Control_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = CosTransactions::Control::_nil();

        return true;
    }
    else
        return false;
}

const char**
CosTransactions::Control_broker::_STAR_ids() const
{
    return ids_;
}

//
// Operation declare CosTransactions::Control_broker::get_terminator
//
::CosTransactions::Terminator_ptr
CosTransactions::Control_broker::get_terminator()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("get_terminator", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/Unavailable:1.0") == 0)
                                {
                                    ::CosTransactions::Unavailable _star_except;
                                    ::CosTransactions::Unavailable::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::CosTransactions::Terminator_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.inout(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "get_terminator");
                    return dynamic_cast<POA_CosTransactions::Control*>(_star_stub->_star_servant_) -> get_terminator();
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare CosTransactions::Control_broker::get_coordinator
//
::CosTransactions::Coordinator_ptr
CosTransactions::Control_broker::get_coordinator()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("get_coordinator", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/Unavailable:1.0") == 0)
                                {
                                    ::CosTransactions::Unavailable _star_except;
                                    ::CosTransactions::Unavailable::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::CosTransactions::Coordinator_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.inout(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "get_coordinator");
                    return dynamic_cast<POA_CosTransactions::Control*>(_star_stub->_star_servant_) -> get_coordinator();
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare CosTransactions::Control_broker::release
//
void
CosTransactions::Control_broker::release()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("release", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        break;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "release");
                    dynamic_cast<POA_CosTransactions::Control*>(_star_stub->_star_servant_) -> release();
                    #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                                        volatile int i = 1;
                                                        i++;
                    #endif
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Interface declare ::CosTransactions::Terminator
//
const char* CosTransactions::Terminator::ids_[] =
{
    "IDL:CosTransactions/Terminator:1.0",
    0
};

void
STARDuplicate(CosTransactions::Terminator_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(CosTransactions::Terminator_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

CosTransactions::Terminator_ptr
CosTransactions::Terminator::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Terminator_ptr v = dynamic_cast<Terminator_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            CosTransactions::Terminator_broker* val = new CosTransactions::Terminator_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

CosTransactions::Terminator_ptr
CosTransactions::Terminator::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

CosTransactions::Terminator_ptr
CosTransactions::Terminator::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Terminator_ptr v = dynamic_cast<Terminator_ptr>(p);
        if(v)
            return _duplicate(v);

        CosTransactions::Terminator_broker* val = new CosTransactions::Terminator_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

CosTransactions::Terminator_ptr
CosTransactions::Terminator::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
CosTransactions::Terminator::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(CosTransactions::Terminator_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(CosTransactions::Terminator_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    CosTransactions::Terminator_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        CosTransactions::Terminator_broker* _star_obj = new CosTransactions::Terminator_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = CosTransactions::Terminator::_nil();
}

void
operator<<=(CORBA::Any& any, CosTransactions::Terminator_ptr* v)
{
    any.replace(CosTransactions::_tc_Terminator, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, CosTransactions::Terminator_ptr v)
{
    CosTransactions::Terminator_ptr val = CosTransactions::Terminator::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::Terminator_ptr& v)
{
    if(any.check_type(CosTransactions::_tc_Terminator))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<CosTransactions::Terminator_ptr>(val)))
            {
                CosTransactions::Terminator_broker* obj = new CosTransactions::Terminator_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = CosTransactions::Terminator::_nil();

        return true;
    }
    else
        return false;
}

const char**
CosTransactions::Terminator_broker::_STAR_ids() const
{
    return ids_;
}

//
// Operation declare CosTransactions::Terminator_broker::commit
//
void
CosTransactions::Terminator_broker::commit(CORBA::Boolean _star_a0)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("commit", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            _star_out -> write_boolean(_star_a0);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/HeuristicMixed:1.0") == 0)
                                {
                                    ::CosTransactions::HeuristicMixed _star_except;
                                    ::CosTransactions::HeuristicMixed::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/HeuristicHazard:1.0") == 0)
                                {
                                    ::CosTransactions::HeuristicHazard _star_except;
                                    ::CosTransactions::HeuristicHazard::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/HeuristicRollback:1.0") == 0)
                                {
                                    ::CosTransactions::HeuristicRollback _star_except;
                                    ::CosTransactions::HeuristicRollback::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/HeuristicCommit:1.0") == 0)
                                {
                                    ::CosTransactions::HeuristicCommit _star_except;
                                    ::CosTransactions::HeuristicCommit::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "commit");
                    dynamic_cast<POA_CosTransactions::Terminator*>(_star_stub->_star_servant_) -> commit(_star_a0);
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare CosTransactions::Terminator_broker::rollback
//
void
CosTransactions::Terminator_broker::rollback()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("rollback", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "rollback");
                    dynamic_cast<POA_CosTransactions::Terminator*>(_star_stub->_star_servant_) -> rollback();
                    #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                                        volatile int i = 1;
                                                        i++;
                    #endif
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare CosTransactions::Terminator_broker::release
//
void
CosTransactions::Terminator_broker::release()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("release", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        break;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "release");
                    dynamic_cast<POA_CosTransactions::Terminator*>(_star_stub->_star_servant_) -> release();
                    #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                                        volatile int i = 1;
                                                        i++;
                    #endif
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Interface declare ::CosTransactions::Coordinator
//
const char* CosTransactions::Coordinator::ids_[] =
{
    "IDL:CosTransactions/Coordinator:1.0",
    0
};

void
STARDuplicate(CosTransactions::Coordinator_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(CosTransactions::Coordinator_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

CosTransactions::Coordinator_ptr
CosTransactions::Coordinator::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Coordinator_ptr v = dynamic_cast<Coordinator_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            CosTransactions::Coordinator_broker* val = new CosTransactions::Coordinator_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

CosTransactions::Coordinator_ptr
CosTransactions::Coordinator::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

CosTransactions::Coordinator_ptr
CosTransactions::Coordinator::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Coordinator_ptr v = dynamic_cast<Coordinator_ptr>(p);
        if(v)
            return _duplicate(v);

        CosTransactions::Coordinator_broker* val = new CosTransactions::Coordinator_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

CosTransactions::Coordinator_ptr
CosTransactions::Coordinator::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
CosTransactions::Coordinator::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(CosTransactions::Coordinator_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(CosTransactions::Coordinator_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    CosTransactions::Coordinator_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        CosTransactions::Coordinator_broker* _star_obj = new CosTransactions::Coordinator_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = CosTransactions::Coordinator::_nil();
}

void
operator<<=(CORBA::Any& any, CosTransactions::Coordinator_ptr* v)
{
    any.replace(CosTransactions::_tc_Coordinator, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, CosTransactions::Coordinator_ptr v)
{
    CosTransactions::Coordinator_ptr val = CosTransactions::Coordinator::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::Coordinator_ptr& v)
{
    if(any.check_type(CosTransactions::_tc_Coordinator))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<CosTransactions::Coordinator_ptr>(val)))
            {
                CosTransactions::Coordinator_broker* obj = new CosTransactions::Coordinator_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = CosTransactions::Coordinator::_nil();

        return true;
    }
    else
        return false;
}

const char**
CosTransactions::Coordinator_broker::_STAR_ids() const
{
    return ids_;
}

//
// Struct declare ::CosTransactions::Coordinator::RCV
//
#ifdef STAR_CLEAR_MEM
CosTransactions::Coordinator::RCV::RCV()
{
    memset(&rv, 0, sizeof(rv));
}
#endif

CosTransactions::Coordinator::RCV::RCV(const RCV& _star_a)
    : r(_star_a.r),
      rc(_star_a.rc),
      rv(_star_a.rv)
{
}

CosTransactions::Coordinator::RCV&
CosTransactions::Coordinator::RCV::operator=(const RCV& _star_a)
{
    if(this != &_star_a)
    {
        r = _star_a.r;
        rc = _star_a.rc;
        rv = _star_a.rv;
    }
    return *this;
}

void
CosTransactions::Coordinator::RCV::_STAR_marshal(STAR::OutputStreamImpl* _star_out) const
{
    STARMarshal(r, _star_out);
    STARMarshal(rc, _star_out);
    _star_out -> write_ulong((CORBA::ULong)rv);
}

void
CosTransactions::Coordinator::RCV::_STAR_unmarshal(RCV& _star_v, STAR::InputStreamImpl* _star_in)
{
    STARUnmarshal(_star_v.r.inout(), _star_in);
    STARUnmarshal(_star_v.rc.inout(), _star_in);
    _star_v.rv = (ResourceVote)_star_in -> read_ulong();
}

void
operator<<=(CORBA::Any& any, CosTransactions::Coordinator::RCV* v)
{
    static const STAR::Info< CosTransactions::Coordinator::RCV > info;
    any.replace(CosTransactions::Coordinator::_tc_RCV, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::Coordinator::RCV& v)
{
    any <<= new CosTransactions::Coordinator::RCV(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::Coordinator::RCV*& v)
{
    if(any.check_type(CosTransactions::Coordinator::_tc_RCV))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::Coordinator::RCV* val = new CosTransactions::Coordinator::RCV;
            CosTransactions::Coordinator::RCV::_STAR_unmarshal(*val, _star_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::Coordinator::RCV*)any.value();
        return true;
    }
    else
        return false;
}

void
CosTransactions::Coordinator::STARInfo_RCVs::marshal(const void* _star_v, STAR::OutputStreamImpl* _star_out) const
{
    const CosTransactions::Coordinator::RCVs& _star_seq = *(const CosTransactions::Coordinator::RCVs*)_star_v;
    CORBA::ULong _star_len0 = _star_seq.length();
    _star_out -> write_ulong(_star_len0);
    CosTransactions::Coordinator::RCV const * _star_buf0 = _star_seq.get_buffer();
    for(CORBA::ULong _star_i0 = 0 ; _star_i0 < _star_len0 ; _star_i0++)
    {
        _star_buf0[_star_i0]._STAR_marshal(_star_out);
    }
}

void
CosTransactions::Coordinator::STARInfo_RCVs::unmarshal(void* _star_v, STAR::InputStreamImpl* _star_in) const
{
    CosTransactions::Coordinator::RCVs& _star_seq = *(CosTransactions::Coordinator::RCVs*)_star_v;
    CORBA::ULong _star_len0 = _star_in -> read_ulong();
    _star_seq.length(_star_len0);
    CosTransactions::Coordinator::RCV * _star_buf0 = _star_seq.get_buffer();
    for(CORBA::ULong _star_i0 = 0 ; _star_i0 < _star_len0 ; _star_i0++)
    {
        CosTransactions::Coordinator::RCV::_STAR_unmarshal(_star_buf0[_star_i0], _star_in);
    }
}

void
operator<<=(CORBA::Any& any, CosTransactions::Coordinator::RCVs* v)
{
    static const CosTransactions::Coordinator::STARInfo_RCVs info;
    any.replace(CosTransactions::Coordinator::_tc_RCVs, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::Coordinator::RCVs& v)
{
    any <<= new CosTransactions::Coordinator::RCVs(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::Coordinator::RCVs*& v)
{
    if(any.check_type(CosTransactions::Coordinator::_tc_RCVs))
    {
        if(!any.info())
        {
            STAR::InputStream_var _star_in = any.create_input_stream();
            CosTransactions::Coordinator::RCVs* val = new CosTransactions::Coordinator::RCVs;
            CORBA::ULong _star_len0 = _star_in -> read_ulong();
            (*val).length(_star_len0);
            CosTransactions::Coordinator::RCV * _star_buf0 = (*val).get_buffer();
            for(CORBA::ULong _star_i0 = 0 ; _star_i0 < _star_len0 ; _star_i0++)
            {
                CosTransactions::Coordinator::RCV::_STAR_unmarshal(_star_buf0[_star_i0], _star_in);
            }
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::Coordinator::RCVs*)any.value();
        return true;
    }
    else
        return false;
}

//renyi 11 25 : added
void 
CosTransactions::Coordinator::remove(RCVs_ptr RCVs_var_tmp,CORBA::ULong idx)
{
	CORBA::ULong tmp_len = RCVs_var_tmp->length();

	if (tmp_len != 1)
//		for(CORBA::ULong i = idx;i < tmp_len;i++)
//Suliang add.
		for(CORBA::ULong i = idx;i < tmp_len-1;i++)
//Suliang add.
			{
				RCVs_var_tmp[i] = RCVs_var_tmp[i+1];

				
//				CORBA::ULong j = tmp_len-1;
//				RCVs_var_tmp -> length(j);
			}
	else 
	{
		RCVs_var_tmp -> length(0);	
	} //end of if
}

//
// Operation declare CosTransactions::Coordinator_broker::get_status
//
::CosTransactions::Status
CosTransactions::Coordinator_broker::get_status()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("get_status", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::CosTransactions::Status _star_r;
                            try
                            {
                                _star_r = (CosTransactions::Status)_star_in -> read_ulong();
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "get_status");
                    return dynamic_cast<POA_CosTransactions::Coordinator*>(_star_stub->_star_servant_) -> get_status();
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare CosTransactions::Coordinator_broker::is_same_transaction
//
CORBA::Boolean
CosTransactions::Coordinator_broker::is_same_transaction(::CosTransactions::Coordinator_ptr _star_a0)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("is_same_transaction", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            STARMarshal(_star_a0, _star_out);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            CORBA::Boolean _star_r;
                            try
                            {
                                _star_r = _star_in -> read_boolean();
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "is_same_transaction");
                    return dynamic_cast<POA_CosTransactions::Coordinator*>(_star_stub->_star_servant_) -> is_same_transaction(_star_a0);
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare CosTransactions::Coordinator_broker::register_resource
//
::CosTransactions::RecoveryCoordinator_ptr
CosTransactions::Coordinator_broker::register_resource(::Resource_ptr _star_a0)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("register_resource", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            STARMarshal(_star_a0, _star_out);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/Inactive:1.0") == 0)
                                {
                                    ::CosTransactions::Inactive _star_except;
                                    ::CosTransactions::Inactive::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::CosTransactions::RecoveryCoordinator_var _star_r;
                            try
                            {
                                STARUnmarshal(_star_r.inout(), _star_in);
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r._retn();
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "register_resource");
                    return dynamic_cast<POA_CosTransactions::Coordinator*>(_star_stub->_star_servant_) -> register_resource(_star_a0);
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare CosTransactions::Coordinator_broker::register_synchronization
//
void
CosTransactions::Coordinator_broker::register_synchronization(::CosTransactions::Synchronization_ptr _star_a0)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("register_synchronization", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            STARMarshal(_star_a0, _star_out);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/Inactive:1.0") == 0)
                                {
                                    ::CosTransactions::Inactive _star_except;
                                    ::CosTransactions::Inactive::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/SynchronizationUnavailable:1.0") == 0)
                                {
                                    ::CosTransactions::SynchronizationUnavailable _star_except;
                                    ::CosTransactions::SynchronizationUnavailable::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "register_synchronization");
                    dynamic_cast<POA_CosTransactions::Coordinator*>(_star_stub->_star_servant_) -> register_synchronization(_star_a0);
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare CosTransactions::Coordinator_broker::rollback_only
//
void
CosTransactions::Coordinator_broker::rollback_only()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("rollback_only", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/Inactive:1.0") == 0)
                                {
                                    ::CosTransactions::Inactive _star_except;
                                    ::CosTransactions::Inactive::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "rollback_only");
                    dynamic_cast<POA_CosTransactions::Coordinator*>(_star_stub->_star_servant_) -> rollback_only();
                    #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                                        volatile int i = 1;
                                                        i++;
                    #endif
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare CosTransactions::Coordinator_broker::commit
//
void
CosTransactions::Coordinator_broker::commit(CORBA::Boolean _star_a0)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("commit", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            _star_out -> write_boolean(_star_a0);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "commit");
                    dynamic_cast<POA_CosTransactions::Coordinator*>(_star_stub->_star_servant_) -> commit(_star_a0);
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare CosTransactions::Coordinator_broker::rollback
//
void
CosTransactions::Coordinator_broker::rollback()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("rollback", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "rollback");
                    dynamic_cast<POA_CosTransactions::Coordinator*>(_star_stub->_star_servant_) -> rollback();
                    #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                                        volatile int i = 1;
                                                        i++;
                    #endif
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare CosTransactions::Coordinator_broker::change_resourcevote
//
void
CosTransactions::Coordinator_broker::change_resourcevote(::Resource_ptr _star_a0,
                                                         ::CosTransactions::ResourceVote _star_a1)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("change_resourcevote", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            STARMarshal(_star_a0, _star_out);
                            _star_out -> write_ulong((CORBA::ULong)_star_a1);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            break;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "change_resourcevote");
                    dynamic_cast<POA_CosTransactions::Coordinator*>(_star_stub->_star_servant_) -> change_resourcevote(_star_a0, _star_a1);
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare CosTransactions::Coordinator_broker::release
//
void
CosTransactions::Coordinator_broker::release()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("release", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        break;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "release");
                    dynamic_cast<POA_CosTransactions::Coordinator*>(_star_stub->_star_servant_) -> release();
                    #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                                        volatile int i = 1;
                                                        i++;
                    #endif
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Interface declare ::CosTransactions::RecoveryCoordinator
//
const char* CosTransactions::RecoveryCoordinator::ids_[] =
{
    "IDL:CosTransactions/RecoveryCoordinator:1.0",
    0
};

void
STARDuplicate(CosTransactions::RecoveryCoordinator_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(CosTransactions::RecoveryCoordinator_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

CosTransactions::RecoveryCoordinator_ptr
CosTransactions::RecoveryCoordinator::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        RecoveryCoordinator_ptr v = dynamic_cast<RecoveryCoordinator_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            CosTransactions::RecoveryCoordinator_broker* val = new CosTransactions::RecoveryCoordinator_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

CosTransactions::RecoveryCoordinator_ptr
CosTransactions::RecoveryCoordinator::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

CosTransactions::RecoveryCoordinator_ptr
CosTransactions::RecoveryCoordinator::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        RecoveryCoordinator_ptr v = dynamic_cast<RecoveryCoordinator_ptr>(p);
        if(v)
            return _duplicate(v);

        CosTransactions::RecoveryCoordinator_broker* val = new CosTransactions::RecoveryCoordinator_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

CosTransactions::RecoveryCoordinator_ptr
CosTransactions::RecoveryCoordinator::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
CosTransactions::RecoveryCoordinator::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(CosTransactions::RecoveryCoordinator_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(CosTransactions::RecoveryCoordinator_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    CosTransactions::RecoveryCoordinator_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        CosTransactions::RecoveryCoordinator_broker* _star_obj = new CosTransactions::RecoveryCoordinator_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = CosTransactions::RecoveryCoordinator::_nil();
}

void
operator<<=(CORBA::Any& any, CosTransactions::RecoveryCoordinator_ptr* v)
{
    any.replace(CosTransactions::_tc_RecoveryCoordinator, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, CosTransactions::RecoveryCoordinator_ptr v)
{
    CosTransactions::RecoveryCoordinator_ptr val = CosTransactions::RecoveryCoordinator::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::RecoveryCoordinator_ptr& v)
{
    if(any.check_type(CosTransactions::_tc_RecoveryCoordinator))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<CosTransactions::RecoveryCoordinator_ptr>(val)))
            {
                CosTransactions::RecoveryCoordinator_broker* obj = new CosTransactions::RecoveryCoordinator_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = CosTransactions::RecoveryCoordinator::_nil();

        return true;
    }
    else
        return false;
}

const char**
CosTransactions::RecoveryCoordinator_broker::_STAR_ids() const
{
    return ids_;
}

//
// Operation declare CosTransactions::RecoveryCoordinator_broker::replay_completion
//
::CosTransactions::Status
CosTransactions::RecoveryCoordinator_broker::replay_completion(::Resource_ptr _star_a0)
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("replay_completion", true);
                    try
                    {
                        STAR::OutputStreamImpl* _star_out = _star_stub->_STAR_prePrepareHeader(_star_down);
                        try
                        {
                            STARMarshal(_star_a0, _star_out);
                        }
                        catch(const CORBA::SystemException& _star_ex)
                        {
                            _star_stub->_STAR_marshalEx(_star_down, _star_ex);
                        }
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        bool _star_uex;
                        STAR::InputStreamImpl* _star_in = _star_stub->_STAR_preRemoveHeader(_star_down, _star_uex);
                        if(_star_uex)
                        {
                            try
                            {
                                CORBA::String_var _star_id = _star_stub->_STAR_unmarshalExceptionId(_star_down);
                                if(strcmp(_star_id, "IDL:CosTransactions/NotPrepared:1.0") == 0)
                                {
                                    ::CosTransactions::NotPrepared _star_except;
                                    ::CosTransactions::NotPrepared::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_REQUIRED _star_except;
                                    ::CosTransactions::TRANSACTION_REQUIRED::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                                {
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK _star_except;
                                    ::CosTransactions::TRANSACTION_ROLLEDBACK::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::INVALID_TRANSACTION _star_except;
                                    ::CosTransactions::INVALID_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                                else if(strcmp(_star_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                                {
                                    ::CosTransactions::WRONG_TRANSACTION _star_except;
                                    ::CosTransactions::WRONG_TRANSACTION::_STAR_unmarshal(_star_except, _star_in);
                                    _star_stub->_STAR_setUserException(_star_down, _star_except);
                                }
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                        }
                        else
                        {
                            ::CosTransactions::Status _star_r;
                            try
                            {
                                _star_r = (CosTransactions::Status)_star_in -> read_ulong();
                            }
                            catch(const CORBA::SystemException& _star_ex)
                            {
                                _star_stub->_STAR_unmarshalEx(_star_down, _star_ex);
                            }
                            _star_stub->_STAR_postRemoveHeader(_star_down);
                            return _star_r;
                        }
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "replay_completion");
                    return dynamic_cast<POA_CosTransactions::RecoveryCoordinator*>(_star_stub->_star_servant_) -> replay_completion(_star_a0);
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare CosTransactions::RecoveryCoordinator_broker::release
//
void
CosTransactions::RecoveryCoordinator_broker::release()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("release", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        break;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                STAR::FastStub_ptr _star_stub = dynamic_cast<STAR::FastStub_ptr>(_star_stubBase.in());
                if (_star_stub!=NULL)
                {
                    STAR::OrbMediatedInvokeHelper _star_handler(_star_stub, "release");
                    dynamic_cast<POA_CosTransactions::RecoveryCoordinator*>(_star_stub->_star_servant_) -> release();
                    #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                                        volatile int i = 1;
                                                        i++;
                    #endif
                                                    return;
                }
                else
                {
                        throw CORBA::INV_OBJREF();
                }
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Interface declare ::CosTransactions::TransactionalObject
//
const char* CosTransactions::TransactionalObject::ids_[] =
{
    "IDL:CosTransactions/TransactionalObject:1.0",
    0
};

void
STARDuplicate(CosTransactions::TransactionalObject_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(CosTransactions::TransactionalObject_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

CosTransactions::TransactionalObject_ptr
CosTransactions::TransactionalObject::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        TransactionalObject_ptr v = dynamic_cast<TransactionalObject_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            CosTransactions::TransactionalObject_broker* val = new CosTransactions::TransactionalObject_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

CosTransactions::TransactionalObject_ptr
CosTransactions::TransactionalObject::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

CosTransactions::TransactionalObject_ptr
CosTransactions::TransactionalObject::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        TransactionalObject_ptr v = dynamic_cast<TransactionalObject_ptr>(p);
        if(v)
            return _duplicate(v);

        CosTransactions::TransactionalObject_broker* val = new CosTransactions::TransactionalObject_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

CosTransactions::TransactionalObject_ptr
CosTransactions::TransactionalObject::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
CosTransactions::TransactionalObject::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(CosTransactions::TransactionalObject_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(CosTransactions::TransactionalObject_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    CosTransactions::TransactionalObject_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        CosTransactions::TransactionalObject_broker* _star_obj = new CosTransactions::TransactionalObject_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = CosTransactions::TransactionalObject::_nil();
}

void
operator<<=(CORBA::Any& any, CosTransactions::TransactionalObject_ptr* v)
{
    any.replace(CosTransactions::_tc_TransactionalObject, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, CosTransactions::TransactionalObject_ptr v)
{
    CosTransactions::TransactionalObject_ptr val = CosTransactions::TransactionalObject::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::TransactionalObject_ptr& v)
{
    if(any.check_type(CosTransactions::_tc_TransactionalObject))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<CosTransactions::TransactionalObject_ptr>(val)))
            {
                CosTransactions::TransactionalObject_broker* obj = new CosTransactions::TransactionalObject_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = CosTransactions::TransactionalObject::_nil();

        return true;
    }
    else
        return false;
}

const char**
CosTransactions::TransactionalObject_broker::_STAR_ids() const
{
    return ids_;
}
