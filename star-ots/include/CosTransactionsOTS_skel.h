// *************************************************************************
//
// This File Is Automatically Generated by the StarBusIDL-to-C++ Compiler !
//
// Copyright (c) 2003
// Network Information Security Institute,Computer College,NUDT.
// ChangSha,Hunan,PRC
//
// All Rights Reserved
//
// *************************************************************************

// Version: 5.0.0

#ifndef ___CosTransactionsOTS_skel_h__
#define ___CosTransactionsOTS_skel_h__

#include <CosTransactionsOTS.h>
#include <STAR/SkelForServerRequest.h>

//
// Module declare ::CosTransactions
//
namespace POA_CosTransactions
{

//
// Interface declare ::CosTransactions::TransactionFactory
//
class TransactionFactory : virtual public PortableServer::ServantBase,
                           virtual public STAR::SkelForServerRequest
{
    TransactionFactory(const TransactionFactory&);
    void operator=(const TransactionFactory&);

protected:

    //
    // ProtectedOperation declare create
    //
    static void _STAR_op_create(PortableServer::ServantBase *,STAR::Upcall_ptr);

public:

    TransactionFactory() { }

    virtual CORBA::Boolean _is_a(const char*)
        throw(CORBA::SystemException);

    virtual CORBA::RepositoryId _primary_interface(const PortableServer::ObjectId&,
                                                   PortableServer::POA_ptr);

    CosTransactions::TransactionFactory_ptr _this();

    virtual void _STAR_dispatch(STAR::Upcall_ptr);

    //
    // Operation declare create
    //
    virtual CosTransactions::Control_ptr create(CORBA::ULong time_out)
        throw(CosTransactions::TRANSACTION_REQUIRED,
              CosTransactions::TRANSACTION_ROLLEDBACK,
              CosTransactions::INVALID_TRANSACTION,
              CosTransactions::WRONG_TRANSACTION,
              CORBA::SystemException) = 0;
};

//
// Interface declare ::CosTransactions::Control
//
class Control : virtual public PortableServer::ServantBase,
                virtual public STAR::SkelForServerRequest
{
    Control(const Control&);
    void operator=(const Control&);

protected:

    //
    // ProtectedOperation declare get_terminator
    //
    static void _STAR_op_get_terminator(PortableServer::ServantBase *,STAR::Upcall_ptr);

    //
    // ProtectedOperation declare get_coordinator
    //
    static void _STAR_op_get_coordinator(PortableServer::ServantBase *,STAR::Upcall_ptr);

    //
    // ProtectedOperation declare release
    //
    static void _STAR_op_release(PortableServer::ServantBase *,STAR::Upcall_ptr);

public:

    Control() { }

    virtual CORBA::Boolean _is_a(const char*)
        throw(CORBA::SystemException);

    virtual CORBA::RepositoryId _primary_interface(const PortableServer::ObjectId&,
                                                   PortableServer::POA_ptr);

    CosTransactions::Control_ptr _this();

    virtual void _STAR_dispatch(STAR::Upcall_ptr);

    //
    // Operation declare get_terminator
    //
    virtual CosTransactions::Terminator_ptr get_terminator()
        throw(CosTransactions::Unavailable,
              CosTransactions::TRANSACTION_REQUIRED,
              CosTransactions::TRANSACTION_ROLLEDBACK,
              CosTransactions::INVALID_TRANSACTION,
              CosTransactions::WRONG_TRANSACTION,
              CORBA::SystemException) = 0;

    //
    // Operation declare get_coordinator
    //
    virtual CosTransactions::Coordinator_ptr get_coordinator()
        throw(CosTransactions::Unavailable,
              CosTransactions::TRANSACTION_REQUIRED,
              CosTransactions::TRANSACTION_ROLLEDBACK,
              CosTransactions::INVALID_TRANSACTION,
              CosTransactions::WRONG_TRANSACTION,
              CORBA::SystemException) = 0;

    //
    // Operation declare release
    //
    virtual void release()
        throw(CORBA::SystemException) = 0;
};

//
// Interface declare ::CosTransactions::Terminator
//
class Terminator : virtual public PortableServer::ServantBase,
                   virtual public STAR::SkelForServerRequest
{
    Terminator(const Terminator&);
    void operator=(const Terminator&);

protected:

    //
    // ProtectedOperation declare commit
    //
    static void _STAR_op_commit(PortableServer::ServantBase *,STAR::Upcall_ptr);

    //
    // ProtectedOperation declare rollback
    //
    static void _STAR_op_rollback(PortableServer::ServantBase *,STAR::Upcall_ptr);

    //
    // ProtectedOperation declare release
    //
    static void _STAR_op_release(PortableServer::ServantBase *,STAR::Upcall_ptr);

public:

    Terminator() { }

    virtual CORBA::Boolean _is_a(const char*)
        throw(CORBA::SystemException);

    virtual CORBA::RepositoryId _primary_interface(const PortableServer::ObjectId&,
                                                   PortableServer::POA_ptr);

    CosTransactions::Terminator_ptr _this();

    virtual void _STAR_dispatch(STAR::Upcall_ptr);

    //
    // Operation declare commit
    //
    virtual void commit(CORBA::Boolean report_heuristics)
        throw(CosTransactions::HeuristicMixed,
              CosTransactions::HeuristicHazard,
              CosTransactions::HeuristicRollback,
              CosTransactions::HeuristicCommit,
              CosTransactions::TRANSACTION_REQUIRED,
              CosTransactions::TRANSACTION_ROLLEDBACK,
              CosTransactions::INVALID_TRANSACTION,
              CosTransactions::WRONG_TRANSACTION,
              CORBA::SystemException) = 0;

    //
    // Operation declare rollback
    //
    virtual void rollback()
        throw(CosTransactions::TRANSACTION_REQUIRED,
              CosTransactions::TRANSACTION_ROLLEDBACK,
              CosTransactions::INVALID_TRANSACTION,
              CosTransactions::WRONG_TRANSACTION,
              CORBA::SystemException) = 0;

    //
    // Operation declare release
    //
    virtual void release()
        throw(CORBA::SystemException) = 0;
};

//
// Interface declare ::CosTransactions::Coordinator
//
class Coordinator : virtual public PortableServer::ServantBase,
                    virtual public STAR::SkelForServerRequest
{
    Coordinator(const Coordinator&);
    void operator=(const Coordinator&);

protected:

    //
    // ProtectedOperation declare get_status
    //
    static void _STAR_op_get_status(PortableServer::ServantBase *,STAR::Upcall_ptr);

    //
    // ProtectedOperation declare is_same_transaction
    //
    static void _STAR_op_is_same_transaction(PortableServer::ServantBase *,STAR::Upcall_ptr);

    //
    // ProtectedOperation declare register_resource
    //
    static void _STAR_op_register_resource(PortableServer::ServantBase *,STAR::Upcall_ptr);

    //
    // ProtectedOperation declare register_synchronization
    //
    static void _STAR_op_register_synchronization(PortableServer::ServantBase *,STAR::Upcall_ptr);

    //
    // ProtectedOperation declare rollback_only
    //
    static void _STAR_op_rollback_only(PortableServer::ServantBase *,STAR::Upcall_ptr);

    //
    // ProtectedOperation declare commit
    //
    static void _STAR_op_commit(PortableServer::ServantBase *,STAR::Upcall_ptr);

    //
    // ProtectedOperation declare rollback
    //
    static void _STAR_op_rollback(PortableServer::ServantBase *,STAR::Upcall_ptr);

    //
    // ProtectedOperation declare change_resourcevote
    //
    static void _STAR_op_change_resourcevote(PortableServer::ServantBase *,STAR::Upcall_ptr);

    //
    // ProtectedOperation declare release
    //
    static void _STAR_op_release(PortableServer::ServantBase *,STAR::Upcall_ptr);

public:

    Coordinator() { }

    virtual CORBA::Boolean _is_a(const char*)
        throw(CORBA::SystemException);

    virtual CORBA::RepositoryId _primary_interface(const PortableServer::ObjectId&,
                                                   PortableServer::POA_ptr);

    CosTransactions::Coordinator_ptr _this();

    virtual void _STAR_dispatch(STAR::Upcall_ptr);

    //
    // Operation declare get_status
    //
    virtual CosTransactions::Status get_status()
        throw(CosTransactions::TRANSACTION_REQUIRED,
              CosTransactions::TRANSACTION_ROLLEDBACK,
              CosTransactions::INVALID_TRANSACTION,
              CosTransactions::WRONG_TRANSACTION,
              CORBA::SystemException) = 0;

    //
    // Operation declare is_same_transaction
    //
    virtual CORBA::Boolean is_same_transaction(CosTransactions::Coordinator_ptr tc)
        throw(CosTransactions::TRANSACTION_REQUIRED,
              CosTransactions::TRANSACTION_ROLLEDBACK,
              CosTransactions::INVALID_TRANSACTION,
              CosTransactions::WRONG_TRANSACTION,
              CORBA::SystemException) = 0;

    //
    // Operation declare register_resource
    //
    virtual CosTransactions::RecoveryCoordinator_ptr register_resource(Resource_ptr r)
        throw(CosTransactions::Inactive,
              CosTransactions::TRANSACTION_REQUIRED,
              CosTransactions::TRANSACTION_ROLLEDBACK,
              CosTransactions::INVALID_TRANSACTION,
              CosTransactions::WRONG_TRANSACTION,
              CORBA::SystemException) = 0;

    //
    // Operation declare register_synchronization
    //
    virtual void register_synchronization(CosTransactions::Synchronization_ptr sync)
        throw(CosTransactions::Inactive,
              CosTransactions::SynchronizationUnavailable,
              CORBA::SystemException) = 0;

    //
    // Operation declare rollback_only
    //
    virtual void rollback_only()
        throw(CosTransactions::Inactive,
              CosTransactions::TRANSACTION_REQUIRED,
              CosTransactions::TRANSACTION_ROLLEDBACK,
              CosTransactions::INVALID_TRANSACTION,
              CosTransactions::WRONG_TRANSACTION,
              CORBA::SystemException) = 0;

    //
    // Operation declare commit
    //
    virtual void commit(CORBA::Boolean report_heuristics)
        throw(CosTransactions::TRANSACTION_REQUIRED,
              CosTransactions::TRANSACTION_ROLLEDBACK,
              CosTransactions::INVALID_TRANSACTION,
              CosTransactions::WRONG_TRANSACTION,
              CORBA::SystemException) = 0;

    //
    // Operation declare rollback
    //
    virtual void rollback()
        throw(CosTransactions::TRANSACTION_REQUIRED,
              CosTransactions::TRANSACTION_ROLLEDBACK,
              CosTransactions::INVALID_TRANSACTION,
              CosTransactions::WRONG_TRANSACTION,
              CORBA::SystemException) = 0;

    //
    // Operation declare change_resourcevote
    //
    virtual void change_resourcevote(Resource_ptr r,
                                     CosTransactions::ResourceVote rv)
        throw(CosTransactions::TRANSACTION_REQUIRED,
              CosTransactions::TRANSACTION_ROLLEDBACK,
              CosTransactions::INVALID_TRANSACTION,
              CosTransactions::WRONG_TRANSACTION,
              CORBA::SystemException) = 0;

    //
    // Operation declare release
    //
    virtual void release()
        throw(CORBA::SystemException) = 0;
};

//
// Interface declare ::CosTransactions::RecoveryCoordinator
//
class RecoveryCoordinator : virtual public PortableServer::ServantBase,
                            virtual public STAR::SkelForServerRequest
{
    RecoveryCoordinator(const RecoveryCoordinator&);
    void operator=(const RecoveryCoordinator&);

protected:

    //
    // ProtectedOperation declare replay_completion
    //
    static void _STAR_op_replay_completion(PortableServer::ServantBase *,STAR::Upcall_ptr);

    //
    // ProtectedOperation declare release
    //
    static void _STAR_op_release(PortableServer::ServantBase *,STAR::Upcall_ptr);

public:

    RecoveryCoordinator() { }

    virtual CORBA::Boolean _is_a(const char*)
        throw(CORBA::SystemException);

    virtual CORBA::RepositoryId _primary_interface(const PortableServer::ObjectId&,
                                                   PortableServer::POA_ptr);

    CosTransactions::RecoveryCoordinator_ptr _this();

    virtual void _STAR_dispatch(STAR::Upcall_ptr);

    //
    // Operation declare replay_completion
    //
    virtual CosTransactions::Status replay_completion(Resource_ptr r)
        throw(CosTransactions::NotPrepared,
              CosTransactions::TRANSACTION_REQUIRED,
              CosTransactions::TRANSACTION_ROLLEDBACK,
              CosTransactions::INVALID_TRANSACTION,
              CosTransactions::WRONG_TRANSACTION,
              CORBA::SystemException) = 0;

    //
    // Operation declare release
    //
    virtual void release()
        throw(CORBA::SystemException) = 0;
};

//
// Interface declare ::CosTransactions::TransactionalObject
//
class TransactionalObject : virtual public PortableServer::ServantBase,
                            virtual public STAR::SkelForServerRequest
{
    TransactionalObject(const TransactionalObject&);
    void operator=(const TransactionalObject&);

public:

    TransactionalObject() { }

    virtual CORBA::Boolean _is_a(const char*)
        throw(CORBA::SystemException);

    virtual CORBA::RepositoryId _primary_interface(const PortableServer::ObjectId&,
                                                   PortableServer::POA_ptr);

    CosTransactions::TransactionalObject_ptr _this();

    virtual void _STAR_dispatch(STAR::Upcall_ptr);
};

} // End of namespace POA_CosTransactions

#endif
