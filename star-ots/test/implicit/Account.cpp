// *************************************************************************
//
// This File Is Automatically Generated by the StarBusIDL-to-C++ Compiler !
//
// Copyright (c) 2003
// Network Information Security Institute,Computer College,NUDT.
// ChangSha,Hunan,PRC
//
// All Rights Reserved
//
// *************************************************************************

// Version: 5.0.0

#include <STAR/CORBAClient.h>
#include <STAR/CORBAServer.h>
#include <account.h>

STAR::TypeCodeConst _tc_Account(
"01a97d000e0000003000000001f0fd7f1900000049444c3a696d706c696369742f4163636f756"
"e743a312e30001f3400080000004163636f756e7400"
);

//
// Interface declare ::Account
//
const char* Account::ids_[] =
{
    "IDL:implicit/Account:1.0",
    0
};

void
STARDuplicate(Account_ptr p)
{
    if(p)
        p -> _STAR_incRef();
}

void
STARRelease(Account_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

Account_ptr
Account::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Account_ptr v = dynamic_cast<Account_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            Account_broker* val = new Account_broker;
            val -> _STAR_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Account_ptr
Account::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Account_ptr
Account::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Account_ptr v = dynamic_cast<Account_ptr>(p);
        if(v)
            return _duplicate(v);

        Account_broker* val = new Account_broker;
        val -> _STAR_copyFrom(p);
        return val;
    }

    return _nil();
}

Account_ptr
Account::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Account::_STAR_staticIds()
{
    return ids_;
}

void
STARMarshal(Account_ptr _star_v, STAR::OutputStreamImpl* _star_out)
{
    _star_out -> write_Object(_star_v);
}

void
STARUnmarshal(Account_ptr& _star_v, STAR::InputStreamImpl* _star_in)
{
    Account_var old = _star_v;
    CORBA::Object_var p = _star_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        Account_broker* _star_obj = new Account_broker;
        _star_obj -> _STAR_copyFrom(p);
        _star_v = _star_obj;
    }
    else
        _star_v = Account::_nil();
}

void
operator<<=(CORBA::Any& any, Account_ptr* v)
{
    any.replace(_tc_Account, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Account_ptr v)
{
    Account_ptr val = Account::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Account_ptr& v)
{
    if(any.check_type(_tc_Account))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Account_ptr>(val)))
            {
                Account_broker* obj = new Account_broker;
                obj -> _STAR_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Account::_nil();

        return true;
    }
    else
        return false;
}

const char**
Account_broker::_STAR_ids() const
{
    return ids_;
}

//
// Operation declare Account_broker::connect
//
void
Account_broker::connect()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("connect", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        break;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Account_broker::close
//
void
Account_broker::close()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("close", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        break;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Account_broker::sum
//
void
Account_broker::sum()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("sum", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        break;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Account_broker::deposit
//
void
Account_broker::deposit()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("deposit", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        break;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}

//
// Operation declare Account_broker::withdraw
//
void
Account_broker::withdraw()
{
    bool _star_retry = true;
    while(true)
    {
        try
        {
            STAR::StubBase_var _star_stubBase = _STAR_getStub();
            STAR::MarshalStub_ptr _star_stub = dynamic_cast<STAR::MarshalStub_ptr>(_star_stubBase.in());
            if (_star_stub!=NULL)
            {
                for(;;)
                {
                    STAR::Downcall_var _star_down = _star_stub->_STAR_createDowncall("withdraw", true);
                    try
                    {
                        _star_stub->_STAR_prePrepareHeader(_star_down);
                        _star_stub->_STAR_postPrepareHeader(_star_down);
                        _star_stub->_STAR_request(_star_down);
                        _star_stub->_STAR_preRemoveHeader(_star_down);
                        _star_stub->_STAR_postRemoveHeader(_star_down);
                        break;
                    }
                    catch(const STAR::FailureException& _star_ex)
                    {
                        _star_stub->_STAR_handleNetworkFailureException(_star_down, _star_ex);
                    }
                }
                #if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
                                    volatile int i = 1;
                                    i++;
                #endif
                                return;
            }
            else
            {
                    throw CORBA::INV_OBJREF();
            }
        }
        catch(const STAR::ExceptionBase& _star_ex)
        {
            _STAR_handleException(_star_ex, _star_retry);
        }
    }
}
