// *************************************************************************
//
// This File Is Automatically Generated by the StarBusIDL-to-C++ Compiler !
//
// Copyright (c) 2000
// Network Information Security Institute,Computer College,NUDT.
// ChangSha,Hunan,PRC
//
// All Rights Reserved
//
// *************************************************************************

// Version: 3.0.2

#ifndef ___CosTransactionsOTS_h__
#define ___CosTransactionsOTS_h__

class PG_ResourceFactory;
typedef PG_ResourceFactory* PG_ResourceFactory_ptr;
typedef PG_ResourceFactory* PG_ResourceFactoryRef;

extern STAR::TypeCodeConst _tc_PG_ResourceFactory;

class PG_Resource;
typedef PG_Resource* PG_Resource_ptr;
typedef PG_Resource* PG_ResourceRef;

extern STAR::TypeCodeConst _tc_PG_Resource;

namespace CosTransactions
{

class TransactionFactory;
typedef TransactionFactory* TransactionFactory_ptr;
typedef TransactionFactory* TransactionFactoryRef;

extern STAR::TypeCodeConst _tc_TransactionFactory;

class Control;
typedef Control* Control_ptr;
typedef Control* ControlRef;

extern STAR::TypeCodeConst _tc_Control;

class Terminator;
typedef Terminator* Terminator_ptr;
typedef Terminator* TerminatorRef;

extern STAR::TypeCodeConst _tc_Terminator;

class Coordinator;
typedef Coordinator* Coordinator_ptr;
typedef Coordinator* CoordinatorRef;

extern STAR::TypeCodeConst _tc_Coordinator;

class RecoveryCoordinator;
typedef RecoveryCoordinator* RecoveryCoordinator_ptr;
typedef RecoveryCoordinator* RecoveryCoordinatorRef;

extern STAR::TypeCodeConst _tc_RecoveryCoordinator;

class TransactionalObject;
typedef TransactionalObject* TransactionalObject_ptr;
typedef TransactionalObject* TransactionalObjectRef;

extern STAR::TypeCodeConst _tc_TransactionalObject;

} // End of namespace CosTransactions

void STARDuplicate(PG_ResourceFactory_ptr);
void STARRelease(PG_ResourceFactory_ptr);

void STARMarshal(PG_ResourceFactory_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(PG_ResourceFactory_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(PG_Resource_ptr);
void STARRelease(PG_Resource_ptr);

void STARMarshal(PG_Resource_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(PG_Resource_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(CosTransactions::TransactionFactory_ptr);
void STARRelease(CosTransactions::TransactionFactory_ptr);

void STARMarshal(CosTransactions::TransactionFactory_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(CosTransactions::TransactionFactory_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(CosTransactions::Control_ptr);
void STARRelease(CosTransactions::Control_ptr);

void STARMarshal(CosTransactions::Control_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(CosTransactions::Control_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(CosTransactions::Terminator_ptr);
void STARRelease(CosTransactions::Terminator_ptr);

void STARMarshal(CosTransactions::Terminator_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(CosTransactions::Terminator_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(CosTransactions::Coordinator_ptr);
void STARRelease(CosTransactions::Coordinator_ptr);

void STARMarshal(CosTransactions::Coordinator_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(CosTransactions::Coordinator_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(CosTransactions::RecoveryCoordinator_ptr);
void STARRelease(CosTransactions::RecoveryCoordinator_ptr);

void STARMarshal(CosTransactions::RecoveryCoordinator_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(CosTransactions::RecoveryCoordinator_ptr&, STAR::InputStreamImpl*);

void STARDuplicate(CosTransactions::TransactionalObject_ptr);
void STARRelease(CosTransactions::TransactionalObject_ptr);

void STARMarshal(CosTransactions::TransactionalObject_ptr, STAR::OutputStreamImpl*);
void STARUnmarshal(CosTransactions::TransactionalObject_ptr&, STAR::InputStreamImpl*);

typedef STAR::ObjVar< PG_ResourceFactory > PG_ResourceFactory_var;
typedef STAR::ObjOut< PG_ResourceFactory > PG_ResourceFactory_out;

typedef STAR::ObjVar< PG_Resource > PG_Resource_var;
typedef STAR::ObjOut< PG_Resource > PG_Resource_out;

namespace CosTransactions
{

typedef STAR::ObjVar< TransactionFactory > TransactionFactory_var;
typedef STAR::ObjOut< TransactionFactory > TransactionFactory_out;

typedef STAR::ObjVar< Control > Control_var;
typedef STAR::ObjOut< Control > Control_out;

typedef STAR::ObjVar< Terminator > Terminator_var;
typedef STAR::ObjOut< Terminator > Terminator_out;

typedef STAR::ObjVar< Coordinator > Coordinator_var;
typedef STAR::ObjOut< Coordinator > Coordinator_out;

typedef STAR::ObjVar< RecoveryCoordinator > RecoveryCoordinator_var;
typedef STAR::ObjOut< RecoveryCoordinator > RecoveryCoordinator_out;

typedef STAR::ObjVar< TransactionalObject > TransactionalObject_var;
typedef STAR::ObjOut< TransactionalObject > TransactionalObject_out;

} // End of namespace CosTransactions

//
// Module declare ::CosTransactions
//
namespace CosTransactions
{

//
// Enum declare ::CosTransactions::Status
//
enum Status
{
    StatusActive,
    StatusMarkedRollback,
    StatusPrepared,
    StatusCommitted,
    StatusRolledBack,
    StatusUnknown,
    StatusNoTransaction,
    StatusPreparing,
    StatusCommitting,
    StatusRollingBack
};

typedef Status& Status_out;

extern STAR::TypeCodeConst _tc_Status;

//
// Enum declare ::CosTransactions::Vote
//
enum Vote
{
    VoteCommit,
    VoteRollback,
    VoteReadOnly
};

typedef Vote& Vote_out;

extern STAR::TypeCodeConst _tc_Vote;

//
// Enum declare ::CosTransactions::ResourceVote
//
enum ResourceVote
{
    RV_Vote_Commit,
    RV_Vote_Rollback,
    RV_Vote_ReadOnly,
    RV_NotPrepared,
    RV_Committed,
    RV_RolledBack
};

typedef ResourceVote& ResourceVote_out;

extern STAR::TypeCodeConst _tc_ResourceVote;

//
// Exception declare ::CosTransactions::TRANSACTION_REQUIRED
//
struct TRANSACTION_REQUIRED : public CORBA::UserException
{
    TRANSACTION_REQUIRED() { }
    TRANSACTION_REQUIRED(const TRANSACTION_REQUIRED&);
    TRANSACTION_REQUIRED& operator=(const TRANSACTION_REQUIRED&);

    static TRANSACTION_REQUIRED* _downcast(CORBA::Exception*);
    static const TRANSACTION_REQUIRED* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(TRANSACTION_REQUIRED&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_TRANSACTION_REQUIRED;

//
// Exception declare ::CosTransactions::TRANSACTION_ROLLEDBACK
//
struct TRANSACTION_ROLLEDBACK : public CORBA::UserException
{
    TRANSACTION_ROLLEDBACK() { }
    TRANSACTION_ROLLEDBACK(const TRANSACTION_ROLLEDBACK&);
    TRANSACTION_ROLLEDBACK& operator=(const TRANSACTION_ROLLEDBACK&);

    static TRANSACTION_ROLLEDBACK* _downcast(CORBA::Exception*);
    static const TRANSACTION_ROLLEDBACK* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(TRANSACTION_ROLLEDBACK&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_TRANSACTION_ROLLEDBACK;

//
// Exception declare ::CosTransactions::INVALID_TRANSACTION
//
struct INVALID_TRANSACTION : public CORBA::UserException
{
    INVALID_TRANSACTION() { }
    INVALID_TRANSACTION(const INVALID_TRANSACTION&);
    INVALID_TRANSACTION& operator=(const INVALID_TRANSACTION&);

    static INVALID_TRANSACTION* _downcast(CORBA::Exception*);
    static const INVALID_TRANSACTION* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(INVALID_TRANSACTION&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_INVALID_TRANSACTION;

//
// Exception declare ::CosTransactions::WRONG_TRANSACTION
//
struct WRONG_TRANSACTION : public CORBA::UserException
{
    WRONG_TRANSACTION() { }
    WRONG_TRANSACTION(const WRONG_TRANSACTION&);
    WRONG_TRANSACTION& operator=(const WRONG_TRANSACTION&);

    static WRONG_TRANSACTION* _downcast(CORBA::Exception*);
    static const WRONG_TRANSACTION* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(WRONG_TRANSACTION&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_WRONG_TRANSACTION;

//
// Exception declare ::CosTransactions::HeuristicRollback
//
struct HeuristicRollback : public CORBA::UserException
{
    HeuristicRollback() { }
    HeuristicRollback(const HeuristicRollback&);
    HeuristicRollback& operator=(const HeuristicRollback&);

    static HeuristicRollback* _downcast(CORBA::Exception*);
    static const HeuristicRollback* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(HeuristicRollback&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_HeuristicRollback;

//
// Exception declare ::CosTransactions::HeuristicCommit
//
struct HeuristicCommit : public CORBA::UserException
{
    HeuristicCommit() { }
    HeuristicCommit(const HeuristicCommit&);
    HeuristicCommit& operator=(const HeuristicCommit&);

    static HeuristicCommit* _downcast(CORBA::Exception*);
    static const HeuristicCommit* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(HeuristicCommit&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_HeuristicCommit;

//
// Exception declare ::CosTransactions::HeuristicMixed
//
struct HeuristicMixed : public CORBA::UserException
{
    HeuristicMixed() { }
    HeuristicMixed(const HeuristicMixed&);
    HeuristicMixed& operator=(const HeuristicMixed&);

    static HeuristicMixed* _downcast(CORBA::Exception*);
    static const HeuristicMixed* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(HeuristicMixed&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_HeuristicMixed;

//
// Exception declare ::CosTransactions::HeuristicHazard
//
struct HeuristicHazard : public CORBA::UserException
{
    HeuristicHazard() { }
    HeuristicHazard(const HeuristicHazard&);
    HeuristicHazard& operator=(const HeuristicHazard&);

    static HeuristicHazard* _downcast(CORBA::Exception*);
    static const HeuristicHazard* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(HeuristicHazard&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_HeuristicHazard;

//
// Exception declare ::CosTransactions::SubtransactionsUnavailable
//
struct SubtransactionsUnavailable : public CORBA::UserException
{
    SubtransactionsUnavailable() { }
    SubtransactionsUnavailable(const SubtransactionsUnavailable&);
    SubtransactionsUnavailable& operator=(const SubtransactionsUnavailable&);

    static SubtransactionsUnavailable* _downcast(CORBA::Exception*);
    static const SubtransactionsUnavailable* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(SubtransactionsUnavailable&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_SubtransactionsUnavailable;

//
// Exception declare ::CosTransactions::NotSubtransaction
//
struct NotSubtransaction : public CORBA::UserException
{
    NotSubtransaction() { }
    NotSubtransaction(const NotSubtransaction&);
    NotSubtransaction& operator=(const NotSubtransaction&);

    static NotSubtransaction* _downcast(CORBA::Exception*);
    static const NotSubtransaction* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(NotSubtransaction&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_NotSubtransaction;

//
// Exception declare ::CosTransactions::Inactive
//
struct Inactive : public CORBA::UserException
{
    Inactive() { }
    Inactive(const Inactive&);
    Inactive& operator=(const Inactive&);

    static Inactive* _downcast(CORBA::Exception*);
    static const Inactive* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(Inactive&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_Inactive;

//
// Exception declare ::CosTransactions::NotPrepared
//
struct NotPrepared : public CORBA::UserException
{
    NotPrepared() { }
    NotPrepared(const NotPrepared&);
    NotPrepared& operator=(const NotPrepared&);

    static NotPrepared* _downcast(CORBA::Exception*);
    static const NotPrepared* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(NotPrepared&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_NotPrepared;

//
// Exception declare ::CosTransactions::NoTransaction
//
struct NoTransaction : public CORBA::UserException
{
    NoTransaction() { }
    NoTransaction(const NoTransaction&);
    NoTransaction& operator=(const NoTransaction&);

    static NoTransaction* _downcast(CORBA::Exception*);
    static const NoTransaction* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(NoTransaction&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_NoTransaction;

//
// Exception declare ::CosTransactions::InvalidControl
//
struct InvalidControl : public CORBA::UserException
{
    InvalidControl() { }
    InvalidControl(const InvalidControl&);
    InvalidControl& operator=(const InvalidControl&);

    static InvalidControl* _downcast(CORBA::Exception*);
    static const InvalidControl* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(InvalidControl&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_InvalidControl;

//
// Exception declare ::CosTransactions::Unavailable
//
struct Unavailable : public CORBA::UserException
{
    Unavailable() { }
    Unavailable(const Unavailable&);
    Unavailable& operator=(const Unavailable&);

    static Unavailable* _downcast(CORBA::Exception*);
    static const Unavailable* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(Unavailable&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_Unavailable;

//
// Exception declare ::CosTransactions::SynchronizationUnavailable
//
struct SynchronizationUnavailable : public CORBA::UserException
{
    SynchronizationUnavailable() { }
    SynchronizationUnavailable(const SynchronizationUnavailable&);
    SynchronizationUnavailable& operator=(const SynchronizationUnavailable&);

    static SynchronizationUnavailable* _downcast(CORBA::Exception*);
    static const SynchronizationUnavailable* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _STAR_clone() const;
    virtual void _STAR_insertInAny(CORBA::Any&);

    static void _STAR_unmarshal(SynchronizationUnavailable&, STAR::InputStreamImpl*);
};

extern STAR::TypeCodeConst _tc_SynchronizationUnavailable;

//
// Interface declare ::CosTransactions::TransactionFactory
//
class TransactionFactory : virtual public CORBA::Object
{
    TransactionFactory(const TransactionFactory&);
    void operator=(const TransactionFactory&);

    static const char* ids_[];

public:

    TransactionFactory() { }
    virtual ~TransactionFactory() { }

    typedef TransactionFactory_ptr _ptr_type;
    typedef TransactionFactory_var _var_type;

    static inline TransactionFactory_ptr
    _duplicate(TransactionFactory_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline TransactionFactory_ptr
    _nil()
    {
        return 0;
    }

    static TransactionFactory_ptr _narrow(CORBA::Object_ptr);
    static TransactionFactory_ptr _narrow(CORBA::AbstractBase_ptr);

    virtual const char** _STAR_ids() const;
    static const char** _STAR_staticIds();

    //
    // Operation declare ::CosTransactions::TransactionFactory::create
    //
    Control_ptr create(CORBA::ULong time_out);
};

//
// Interface declare ::CosTransactions::Control
//
class Control : virtual public CORBA::Object
{
    Control(const Control&);
    void operator=(const Control&);

    static const char* ids_[];

public:

    Control() { }
    virtual ~Control() { }

    typedef Control_ptr _ptr_type;
    typedef Control_var _var_type;

    static inline Control_ptr
    _duplicate(Control_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline Control_ptr
    _nil()
    {
        return 0;
    }

    static Control_ptr _narrow(CORBA::Object_ptr);
    static Control_ptr _narrow(CORBA::AbstractBase_ptr);

    virtual const char** _STAR_ids() const;
    static const char** _STAR_staticIds();

    //
    // Operation declare ::CosTransactions::Control::get_terminator
    //
    Terminator_ptr get_terminator();

    //
    // Operation declare ::CosTransactions::Control::get_coordinator
    //
    Coordinator_ptr get_coordinator();

    //
    // Operation declare ::CosTransactions::Control::release
    //
    void release();
};

//
// Interface declare ::CosTransactions::Terminator
//
class Terminator : virtual public CORBA::Object
{
    Terminator(const Terminator&);
    void operator=(const Terminator&);

    static const char* ids_[];

public:

    Terminator() { }
    virtual ~Terminator() { }

    typedef Terminator_ptr _ptr_type;
    typedef Terminator_var _var_type;

    static inline Terminator_ptr
    _duplicate(Terminator_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline Terminator_ptr
    _nil()
    {
        return 0;
    }

    static Terminator_ptr _narrow(CORBA::Object_ptr);
    static Terminator_ptr _narrow(CORBA::AbstractBase_ptr);

    virtual const char** _STAR_ids() const;
    static const char** _STAR_staticIds();

    //
    // Operation declare ::CosTransactions::Terminator::commit
    //
    void commit(CORBA::Boolean report_heuristics);

    //
    // Operation declare ::CosTransactions::Terminator::rollback
    //
    void rollback();

    //
    // Operation declare ::CosTransactions::Terminator::release
    //
    void release();
};

//
// Interface declare ::CosTransactions::Coordinator
//
class Coordinator : virtual public CORBA::Object
{
    Coordinator(const Coordinator&);
    void operator=(const Coordinator&);

    static const char* ids_[];

public:

    Coordinator() { }
    virtual ~Coordinator() { }

    typedef Coordinator_ptr _ptr_type;
    typedef Coordinator_var _var_type;

    static inline Coordinator_ptr
    _duplicate(Coordinator_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline Coordinator_ptr
    _nil()
    {
        return 0;
    }

    static Coordinator_ptr _narrow(CORBA::Object_ptr);
    static Coordinator_ptr _narrow(CORBA::AbstractBase_ptr);

    virtual const char** _STAR_ids() const;
    static const char** _STAR_staticIds();

    //
    // Struct declare ::CosTransactions::Coordinator::RCV
    //
    struct RCV;
    typedef STAR::VarVar< RCV > RCV_var;
    typedef STAR::VarOut< RCV > RCV_out;

    struct RCV
    {
#ifdef STAR_CLEAR_MEM
        RCV();
#else
        RCV() { }
#endif
        RCV(const RCV&);
        RCV& operator=(const RCV&);

        typedef RCV_var _var_type;

        PG_Resource_var r;
        RecoveryCoordinator_var rc;
        ResourceVote rv;

        void _STAR_marshal(STAR::OutputStreamImpl*) const;
        static void _STAR_unmarshal(RCV&, STAR::InputStreamImpl*);
    };

    static STAR::TypeCodeConst _tc_RCV;

    //
    // Sequence declare ::CosTransactions::Coordinator::RCVs
    //
    class STARUnique_RCVs { };

    typedef STAR::VarSeq< RCV, STARUnique_RCVs > RCVs;
    typedef STAR::SeqVar< STAR::VarSeq< RCV, STARUnique_RCVs > > RCVs_var;
    typedef STAR::SeqOut< STAR::VarSeq< RCV, STARUnique_RCVs > > RCVs_out;
    static STAR::TypeCodeConst _tc_RCVs;

    struct STARInfo_RCVs : public STAR::ConstructedInfo
    {
        STARInfo_RCVs() { }

        virtual void free(void* p) const
        {
            delete (RCVs*)p;
        }

        virtual void* dup(const void* p) const
        {
            return new RCVs(*(const RCVs*)p);
        }

        virtual void marshal(const void*, STAR::OutputStreamImpl*) const;
        virtual void unmarshal(void*, STAR::InputStreamImpl*) const;
    };

//	static void remove(RCVs_var RCVs_var_tmp,CORBA::ULong idx);//renyi 11 25 : added
//SuLiang add .
    typedef CosTransactions::Coordinator::RCVs* RCVs_ptr;
    static void remove(RCVs_ptr RCVs_var_tmp,CORBA::ULong idx);
//SuLiang add.

    //
    // Operation declare ::CosTransactions::Coordinator::get_status
    //
    Status get_status();

    //
    // Operation declare ::CosTransactions::Coordinator::is_same_transaction
    //
    CORBA::Boolean is_same_transaction(Coordinator_ptr tc);

    //
    // Operation declare ::CosTransactions::Coordinator::register_resource
    //
    RecoveryCoordinator_ptr register_resource(PG_Resource_ptr r);

    //
    // Operation declare ::CosTransactions::Coordinator::rollback_only
    //
    void rollback_only();

    //
    // Operation declare ::CosTransactions::Coordinator::commit
    //
    void commit(CORBA::Boolean report_heuristics);

    //
    // Operation declare ::CosTransactions::Coordinator::rollback
    //
    void rollback();

    //
    // Operation declare ::CosTransactions::Coordinator::change_resourcevote
    //
    void change_resourcevote(PG_Resource_ptr r,
                             ResourceVote rv);

    //
    // Operation declare ::CosTransactions::Coordinator::release
    //
    void release();
};

//
// Interface declare ::CosTransactions::RecoveryCoordinator
//
class RecoveryCoordinator : virtual public CORBA::Object
{
    RecoveryCoordinator(const RecoveryCoordinator&);
    void operator=(const RecoveryCoordinator&);

    static const char* ids_[];

public:

    RecoveryCoordinator() { }
    virtual ~RecoveryCoordinator() { }

    typedef RecoveryCoordinator_ptr _ptr_type;
    typedef RecoveryCoordinator_var _var_type;

    static inline RecoveryCoordinator_ptr
    _duplicate(RecoveryCoordinator_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline RecoveryCoordinator_ptr
    _nil()
    {
        return 0;
    }

    static RecoveryCoordinator_ptr _narrow(CORBA::Object_ptr);
    static RecoveryCoordinator_ptr _narrow(CORBA::AbstractBase_ptr);

    virtual const char** _STAR_ids() const;
    static const char** _STAR_staticIds();

    //
    // Operation declare ::CosTransactions::RecoveryCoordinator::replay_completion
    //
    Status replay_completion(PG_Resource_ptr r);

    //
    // Operation declare ::CosTransactions::RecoveryCoordinator::release
    //
    void release();
};

//
// Interface declare ::CosTransactions::TransactionalObject
//
class TransactionalObject : virtual public CORBA::Object
{
    TransactionalObject(const TransactionalObject&);
    void operator=(const TransactionalObject&);

    static const char* ids_[];

public:

    TransactionalObject() { }
    virtual ~TransactionalObject() { }

    typedef TransactionalObject_ptr _ptr_type;
    typedef TransactionalObject_var _var_type;

    static inline TransactionalObject_ptr
    _duplicate(TransactionalObject_ptr p)
    {
        if(p)
            p -> _STAR_incRef();
        return p;
    }

    static inline TransactionalObject_ptr
    _nil()
    {
        return 0;
    }

    static TransactionalObject_ptr _narrow(CORBA::Object_ptr);
    static TransactionalObject_ptr _narrow(CORBA::AbstractBase_ptr);

    virtual const char** _STAR_ids() const;
    static const char** _STAR_staticIds();
};

} // End of namespace CosTransactions

//
// Module declare ::CosTransactions
//
namespace OBV_CosTransactions
{

} // End of namespace OBV_CosTransactions

//
// Enum declare ::CosTransactions::Status
//
void operator<<=(CORBA::Any&, CosTransactions::Status);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::Status&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Status val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::Status& val)
{
    return any.in() >>= val;
}

//
// Enum declare ::CosTransactions::Vote
//
void operator<<=(CORBA::Any&, CosTransactions::Vote);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::Vote&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Vote val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::Vote& val)
{
    return any.in() >>= val;
}

//
// Enum declare ::CosTransactions::ResourceVote
//
void operator<<=(CORBA::Any&, CosTransactions::ResourceVote);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::ResourceVote&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::ResourceVote val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::ResourceVote& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::TRANSACTION_REQUIRED
//
void operator<<=(CORBA::Any&, CosTransactions::TRANSACTION_REQUIRED*);
void operator<<=(CORBA::Any&, const CosTransactions::TRANSACTION_REQUIRED&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::TRANSACTION_REQUIRED*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::TRANSACTION_REQUIRED* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::TRANSACTION_REQUIRED& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::TRANSACTION_REQUIRED*& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::TRANSACTION_ROLLEDBACK
//
void operator<<=(CORBA::Any&, CosTransactions::TRANSACTION_ROLLEDBACK*);
void operator<<=(CORBA::Any&, const CosTransactions::TRANSACTION_ROLLEDBACK&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::TRANSACTION_ROLLEDBACK*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::TRANSACTION_ROLLEDBACK* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::TRANSACTION_ROLLEDBACK& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::TRANSACTION_ROLLEDBACK*& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::INVALID_TRANSACTION
//
void operator<<=(CORBA::Any&, CosTransactions::INVALID_TRANSACTION*);
void operator<<=(CORBA::Any&, const CosTransactions::INVALID_TRANSACTION&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::INVALID_TRANSACTION*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::INVALID_TRANSACTION* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::INVALID_TRANSACTION& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::INVALID_TRANSACTION*& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::WRONG_TRANSACTION
//
void operator<<=(CORBA::Any&, CosTransactions::WRONG_TRANSACTION*);
void operator<<=(CORBA::Any&, const CosTransactions::WRONG_TRANSACTION&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::WRONG_TRANSACTION*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::WRONG_TRANSACTION* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::WRONG_TRANSACTION& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::WRONG_TRANSACTION*& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::HeuristicRollback
//
void operator<<=(CORBA::Any&, CosTransactions::HeuristicRollback*);
void operator<<=(CORBA::Any&, const CosTransactions::HeuristicRollback&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::HeuristicRollback*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::HeuristicRollback* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::HeuristicRollback& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::HeuristicRollback*& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::HeuristicCommit
//
void operator<<=(CORBA::Any&, CosTransactions::HeuristicCommit*);
void operator<<=(CORBA::Any&, const CosTransactions::HeuristicCommit&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::HeuristicCommit*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::HeuristicCommit* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::HeuristicCommit& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::HeuristicCommit*& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::HeuristicMixed
//
void operator<<=(CORBA::Any&, CosTransactions::HeuristicMixed*);
void operator<<=(CORBA::Any&, const CosTransactions::HeuristicMixed&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::HeuristicMixed*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::HeuristicMixed* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::HeuristicMixed& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::HeuristicMixed*& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::HeuristicHazard
//
void operator<<=(CORBA::Any&, CosTransactions::HeuristicHazard*);
void operator<<=(CORBA::Any&, const CosTransactions::HeuristicHazard&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::HeuristicHazard*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::HeuristicHazard* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::HeuristicHazard& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::HeuristicHazard*& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::SubtransactionsUnavailable
//
void operator<<=(CORBA::Any&, CosTransactions::SubtransactionsUnavailable*);
void operator<<=(CORBA::Any&, const CosTransactions::SubtransactionsUnavailable&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::SubtransactionsUnavailable*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::SubtransactionsUnavailable* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::SubtransactionsUnavailable& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::SubtransactionsUnavailable*& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::NotSubtransaction
//
void operator<<=(CORBA::Any&, CosTransactions::NotSubtransaction*);
void operator<<=(CORBA::Any&, const CosTransactions::NotSubtransaction&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::NotSubtransaction*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::NotSubtransaction* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::NotSubtransaction& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::NotSubtransaction*& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::Inactive
//
void operator<<=(CORBA::Any&, CosTransactions::Inactive*);
void operator<<=(CORBA::Any&, const CosTransactions::Inactive&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::Inactive*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Inactive* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::Inactive& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::Inactive*& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::NotPrepared
//
void operator<<=(CORBA::Any&, CosTransactions::NotPrepared*);
void operator<<=(CORBA::Any&, const CosTransactions::NotPrepared&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::NotPrepared*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::NotPrepared* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::NotPrepared& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::NotPrepared*& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::NoTransaction
//
void operator<<=(CORBA::Any&, CosTransactions::NoTransaction*);
void operator<<=(CORBA::Any&, const CosTransactions::NoTransaction&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::NoTransaction*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::NoTransaction* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::NoTransaction& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::NoTransaction*& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::InvalidControl
//
void operator<<=(CORBA::Any&, CosTransactions::InvalidControl*);
void operator<<=(CORBA::Any&, const CosTransactions::InvalidControl&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::InvalidControl*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::InvalidControl* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::InvalidControl& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::InvalidControl*& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::Unavailable
//
void operator<<=(CORBA::Any&, CosTransactions::Unavailable*);
void operator<<=(CORBA::Any&, const CosTransactions::Unavailable&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::Unavailable*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Unavailable* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::Unavailable& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::Unavailable*& val)
{
    return any.in() >>= val;
}

//
// Exception declare ::CosTransactions::SynchronizationUnavailable
//
void operator<<=(CORBA::Any&, CosTransactions::SynchronizationUnavailable*);
void operator<<=(CORBA::Any&, const CosTransactions::SynchronizationUnavailable&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::SynchronizationUnavailable*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::SynchronizationUnavailable* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::SynchronizationUnavailable& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::SynchronizationUnavailable*& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::CosTransactions::TransactionFactory
//
namespace CORBA
{

inline void
release(CosTransactions::TransactionFactory_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(CosTransactions::TransactionFactory_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, CosTransactions::TransactionFactory_ptr*);
void operator<<=(CORBA::Any&, CosTransactions::TransactionFactory_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::TransactionFactory_ptr&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::TransactionFactory_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::TransactionFactory_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::TransactionFactory_ptr& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::CosTransactions::Control
//
namespace CORBA
{

inline void
release(CosTransactions::Control_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(CosTransactions::Control_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, CosTransactions::Control_ptr*);
void operator<<=(CORBA::Any&, CosTransactions::Control_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::Control_ptr&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Control_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Control_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::Control_ptr& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::CosTransactions::Terminator
//
namespace CORBA
{

inline void
release(CosTransactions::Terminator_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(CosTransactions::Terminator_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, CosTransactions::Terminator_ptr*);
void operator<<=(CORBA::Any&, CosTransactions::Terminator_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::Terminator_ptr&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Terminator_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Terminator_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::Terminator_ptr& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::CosTransactions::Coordinator
//
namespace CORBA
{

inline void
release(CosTransactions::Coordinator_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(CosTransactions::Coordinator_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, CosTransactions::Coordinator_ptr*);
void operator<<=(CORBA::Any&, CosTransactions::Coordinator_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::Coordinator_ptr&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Coordinator_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Coordinator_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::Coordinator_ptr& val)
{
    return any.in() >>= val;
}

//
// Struct declare ::CosTransactions::Coordinator::RCV
//
void operator<<=(CORBA::Any&, CosTransactions::Coordinator::RCV*);
void operator<<=(CORBA::Any&, const CosTransactions::Coordinator::RCV&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::Coordinator::RCV*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Coordinator::RCV* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::Coordinator::RCV& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::Coordinator::RCV*& val)
{
    return any.in() >>= val;
}

//
// Sequence declare ::CosTransactions::Coordinator::RCVs
//
void operator<<=(CORBA::Any&, CosTransactions::Coordinator::RCVs*);
void operator<<=(CORBA::Any&, const CosTransactions::Coordinator::RCVs&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::Coordinator::RCVs*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Coordinator::RCVs* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::Coordinator::RCVs& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::Coordinator::RCVs*& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::CosTransactions::RecoveryCoordinator
//
namespace CORBA
{

inline void
release(CosTransactions::RecoveryCoordinator_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(CosTransactions::RecoveryCoordinator_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, CosTransactions::RecoveryCoordinator_ptr*);
void operator<<=(CORBA::Any&, CosTransactions::RecoveryCoordinator_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::RecoveryCoordinator_ptr&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::RecoveryCoordinator_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::RecoveryCoordinator_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::RecoveryCoordinator_ptr& val)
{
    return any.in() >>= val;
}

//
// Interface declare ::CosTransactions::TransactionalObject
//
namespace CORBA
{

inline void
release(CosTransactions::TransactionalObject_ptr p)
{
    if(p)
        p -> _STAR_decRef();
}

inline Boolean
is_nil(CosTransactions::TransactionalObject_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, CosTransactions::TransactionalObject_ptr*);
void operator<<=(CORBA::Any&, CosTransactions::TransactionalObject_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::TransactionalObject_ptr&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::TransactionalObject_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::TransactionalObject_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::TransactionalObject_ptr& val)
{
    return any.in() >>= val;
}

#endif
