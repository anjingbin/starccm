// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2001
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.1.0

#ifndef ___CosTransactionsCurrent_h__
#define ___CosTransactionsCurrent_h__

#include <OB/Current.h>
#include <CosTransactionsOTS.h>
#include <CosTransactionsPolicy.h>

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4010000L)
#       error ORBacus version mismatch!
#   endif
#endif

namespace CosTransactions
{

class Current;
typedef Current* Current_ptr;
typedef Current* CurrentRef;

} // End of namespace CosTransactions

void OBDuplicate(CosTransactions::Current_ptr);
void OBRelease(CosTransactions::Current_ptr);

void OBMarshal(CosTransactions::Current_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(CosTransactions::Current_ptr&, OB::InputStreamImpl*);

namespace CosTransactions
{

typedef OB::ObjVar< Current > Current_var;
typedef OB::ObjOut< Current > Current_out;

} // End of namespace CosTransactions

namespace OBStubImpl_CosTransactions
{

} // End of namespace OBStubImpl_CosTransactions

namespace OBStubImpl_CosTransactions
{

} // End of namespace OBStubImpl_CosTransactions

//
// IDL:CosTransactions:1.0
//
namespace CosTransactions
{

//
// IDL:CosTransactions/Current:1.0
//
class Current : virtual public ::CORBA::Current
{
    Current(const Current&);
    void operator=(const Current&);

protected:

    static const char* ids_[];

public:

    Current() { }
    virtual ~Current() { }

    typedef Current_ptr _ptr_type;
    typedef Current_var _var_type;

    static inline Current_ptr
    _duplicate(Current_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline Current_ptr
    _nil()
    {
        return 0;
    }

    static Current_ptr _narrow(CORBA::Object_ptr);

    static Current_ptr _narrow(CORBA::AbstractBase_ptr);


    //
    // IDL:CosTransactions/Current/begin:1.0
    //
    virtual void begin() = 0;

    //
    // IDL:CosTransactions/Current/commit:1.0
    //
    virtual void commit(CORBA::Boolean report_heuristics) = 0;

    //
    // IDL:CosTransactions/Current/rollback:1.0
    //
    virtual void rollback() = 0;

    //
    // IDL:CosTransactions/Current/rollback_only:1.0
    //
    virtual void rollback_only() = 0;

    //
    // IDL:CosTransactions/Current/get_status:1.0
    //
    virtual Status get_status() = 0;

    //
    // IDL:CosTransactions/Current/set_timeout:1.0
    //
    virtual void set_timeout(CORBA::ULong seconds) = 0;

    //
    // IDL:CosTransactions/Current/get_timeout:1.0
    //
    virtual CORBA::ULong get_timeout() = 0;

    //
    // IDL:CosTransactions/Current/get_control:1.0
    //
    virtual Control_ptr get_control() = 0;

    //
    // IDL:CosTransactions/Current/suspend:1.0
    //
    virtual Control_ptr suspend() = 0;

    //
    // IDL:CosTransactions/Current/resume:1.0
    //
    virtual void resume(Control_ptr which) = 0;
};

} // End of namespace CosTransactions

//
// IDL:CosTransactions:1.0
//
namespace OBProxy_CosTransactions
{

} // End of namespace OBProxy_CosTransactions

//
// IDL:CosTransactions:1.0
//
namespace OBStubImpl_CosTransactions
{

} // End of namespace OBStubImpl_CosTransactions

//
// IDL:CosTransactions:1.0
//
namespace OBMarshalStubImpl_CosTransactions
{

} // End of namespace OBMarshalStubImpl_CosTransactions

//
// IDL:CosTransactions:1.0
//
namespace OBV_CosTransactions
{

} // End of namespace OBV_CosTransactions

//
// IDL:CosTransactions/Current:1.0
//
namespace CORBA
{

inline void
release(::CosTransactions::Current_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::CosTransactions::Current_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

#endif
