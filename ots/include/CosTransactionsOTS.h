// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2001
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.1.0

#ifndef ___CosTransactionsOTS_h__
#define ___CosTransactionsOTS_h__

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4010000L)
#       error ORBacus version mismatch!
#   endif
#endif

class ResourceFactory;
typedef ResourceFactory* ResourceFactory_ptr;
typedef ResourceFactory* ResourceFactoryRef;

extern OB::TypeCodeConst _tc_ResourceFactory;

class Resource;
typedef Resource* Resource_ptr;
typedef Resource* ResourceRef;

extern OB::TypeCodeConst _tc_Resource;

namespace CosTransactions
{

class Synchronization;
typedef Synchronization* Synchronization_ptr;
typedef Synchronization* SynchronizationRef;

extern OB::TypeCodeConst _tc_Synchronization;

class TransactionFactory;
typedef TransactionFactory* TransactionFactory_ptr;
typedef TransactionFactory* TransactionFactoryRef;

extern OB::TypeCodeConst _tc_TransactionFactory;

class Control;
typedef Control* Control_ptr;
typedef Control* ControlRef;

extern OB::TypeCodeConst _tc_Control;

class Terminator;
typedef Terminator* Terminator_ptr;
typedef Terminator* TerminatorRef;

extern OB::TypeCodeConst _tc_Terminator;

class Coordinator;
typedef Coordinator* Coordinator_ptr;
typedef Coordinator* CoordinatorRef;

extern OB::TypeCodeConst _tc_Coordinator;

class RecoveryCoordinator;
typedef RecoveryCoordinator* RecoveryCoordinator_ptr;
typedef RecoveryCoordinator* RecoveryCoordinatorRef;

extern OB::TypeCodeConst _tc_RecoveryCoordinator;

class TransactionalObject;
typedef TransactionalObject* TransactionalObject_ptr;
typedef TransactionalObject* TransactionalObjectRef;

extern OB::TypeCodeConst _tc_TransactionalObject;

} // End of namespace CosTransactions

void OBDuplicate(ResourceFactory_ptr);
void OBRelease(ResourceFactory_ptr);

void OBMarshal(ResourceFactory_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(ResourceFactory_ptr&, OB::InputStreamImpl*);

void OBDuplicate(Resource_ptr);
void OBRelease(Resource_ptr);

void OBMarshal(Resource_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(Resource_ptr&, OB::InputStreamImpl*);

void OBDuplicate(CosTransactions::Synchronization_ptr);
void OBRelease(CosTransactions::Synchronization_ptr);

void OBMarshal(CosTransactions::Synchronization_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(CosTransactions::Synchronization_ptr&, OB::InputStreamImpl*);

void OBDuplicate(CosTransactions::TransactionFactory_ptr);
void OBRelease(CosTransactions::TransactionFactory_ptr);

void OBMarshal(CosTransactions::TransactionFactory_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(CosTransactions::TransactionFactory_ptr&, OB::InputStreamImpl*);

void OBDuplicate(CosTransactions::Control_ptr);
void OBRelease(CosTransactions::Control_ptr);

void OBMarshal(CosTransactions::Control_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(CosTransactions::Control_ptr&, OB::InputStreamImpl*);

void OBDuplicate(CosTransactions::Terminator_ptr);
void OBRelease(CosTransactions::Terminator_ptr);

void OBMarshal(CosTransactions::Terminator_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(CosTransactions::Terminator_ptr&, OB::InputStreamImpl*);

void OBDuplicate(CosTransactions::Coordinator_ptr);
void OBRelease(CosTransactions::Coordinator_ptr);

void OBMarshal(CosTransactions::Coordinator_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(CosTransactions::Coordinator_ptr&, OB::InputStreamImpl*);

void OBDuplicate(CosTransactions::RecoveryCoordinator_ptr);
void OBRelease(CosTransactions::RecoveryCoordinator_ptr);

void OBMarshal(CosTransactions::RecoveryCoordinator_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(CosTransactions::RecoveryCoordinator_ptr&, OB::InputStreamImpl*);

void OBDuplicate(CosTransactions::TransactionalObject_ptr);
void OBRelease(CosTransactions::TransactionalObject_ptr);

void OBMarshal(CosTransactions::TransactionalObject_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(CosTransactions::TransactionalObject_ptr&, OB::InputStreamImpl*);

typedef OB::ObjVar< ResourceFactory > ResourceFactory_var;
typedef OB::ObjOut< ResourceFactory > ResourceFactory_out;

typedef OB::ObjVar< Resource > Resource_var;
typedef OB::ObjOut< Resource > Resource_out;

namespace CosTransactions
{

typedef OB::ObjVar< Synchronization > Synchronization_var;
typedef OB::ObjOut< Synchronization > Synchronization_out;

typedef OB::ObjVar< TransactionFactory > TransactionFactory_var;
typedef OB::ObjOut< TransactionFactory > TransactionFactory_out;

typedef OB::ObjVar< Control > Control_var;
typedef OB::ObjOut< Control > Control_out;

typedef OB::ObjVar< Terminator > Terminator_var;
typedef OB::ObjOut< Terminator > Terminator_out;

typedef OB::ObjVar< Coordinator > Coordinator_var;
typedef OB::ObjOut< Coordinator > Coordinator_out;

typedef OB::ObjVar< RecoveryCoordinator > RecoveryCoordinator_var;
typedef OB::ObjOut< RecoveryCoordinator > RecoveryCoordinator_out;

typedef OB::ObjVar< TransactionalObject > TransactionalObject_var;
typedef OB::ObjOut< TransactionalObject > TransactionalObject_out;

} // End of namespace CosTransactions

class OBStubImpl_ResourceFactory;
typedef OBStubImpl_ResourceFactory* OBStubImpl_ResourceFactory_ptr;

class OBStubImpl_Resource;
typedef OBStubImpl_Resource* OBStubImpl_Resource_ptr;

namespace OBStubImpl_CosTransactions
{

class Synchronization;
typedef Synchronization* Synchronization_ptr;

class TransactionFactory;
typedef TransactionFactory* TransactionFactory_ptr;

class Control;
typedef Control* Control_ptr;

class Terminator;
typedef Terminator* Terminator_ptr;

class Coordinator;
typedef Coordinator* Coordinator_ptr;

class RecoveryCoordinator;
typedef RecoveryCoordinator* RecoveryCoordinator_ptr;

class TransactionalObject;
typedef TransactionalObject* TransactionalObject_ptr;

} // End of namespace OBStubImpl_CosTransactions

void OBDuplicate(OBStubImpl_ResourceFactory_ptr);
void OBRelease(OBStubImpl_ResourceFactory_ptr);

void OBDuplicate(OBStubImpl_Resource_ptr);
void OBRelease(OBStubImpl_Resource_ptr);

void OBDuplicate(OBStubImpl_CosTransactions::Synchronization_ptr);
void OBRelease(OBStubImpl_CosTransactions::Synchronization_ptr);

void OBDuplicate(OBStubImpl_CosTransactions::TransactionFactory_ptr);
void OBRelease(OBStubImpl_CosTransactions::TransactionFactory_ptr);

void OBDuplicate(OBStubImpl_CosTransactions::Control_ptr);
void OBRelease(OBStubImpl_CosTransactions::Control_ptr);

void OBDuplicate(OBStubImpl_CosTransactions::Terminator_ptr);
void OBRelease(OBStubImpl_CosTransactions::Terminator_ptr);

void OBDuplicate(OBStubImpl_CosTransactions::Coordinator_ptr);
void OBRelease(OBStubImpl_CosTransactions::Coordinator_ptr);

void OBDuplicate(OBStubImpl_CosTransactions::RecoveryCoordinator_ptr);
void OBRelease(OBStubImpl_CosTransactions::RecoveryCoordinator_ptr);

void OBDuplicate(OBStubImpl_CosTransactions::TransactionalObject_ptr);
void OBRelease(OBStubImpl_CosTransactions::TransactionalObject_ptr);

typedef OB::ObjVar< OBStubImpl_ResourceFactory > OBStubImpl_ResourceFactory_var;

typedef OB::ObjVar< OBStubImpl_Resource > OBStubImpl_Resource_var;

namespace OBStubImpl_CosTransactions
{

typedef OB::ObjVar< Synchronization > Synchronization_var;

typedef OB::ObjVar< TransactionFactory > TransactionFactory_var;

typedef OB::ObjVar< Control > Control_var;

typedef OB::ObjVar< Terminator > Terminator_var;

typedef OB::ObjVar< Coordinator > Coordinator_var;

typedef OB::ObjVar< RecoveryCoordinator > RecoveryCoordinator_var;

typedef OB::ObjVar< TransactionalObject > TransactionalObject_var;

} // End of namespace OBStubImpl_CosTransactions

//
// IDL:CosTransactions:1.0
//
namespace CosTransactions
{

//
// IDL:CosTransactions/Status:1.0
//
enum Status
{
    StatusActive,
    StatusMarkedRollback,
    StatusPrepared,
    StatusCommitted,
    StatusRolledBack,
    StatusUnknown,
    StatusNoTransaction,
    StatusPreparing,
    StatusCommitting,
    StatusRollingBack
};

typedef Status& Status_out;

extern OB::TypeCodeConst _tc_Status;

//
// IDL:CosTransactions/Vote:1.0
//
enum Vote
{
    VoteCommit,
    VoteRollback,
    VoteReadOnly
};

typedef Vote& Vote_out;

extern OB::TypeCodeConst _tc_Vote;

//
// IDL:CosTransactions/ResourceVote:1.0
//
enum ResourceVote
{
    RV_Vote_Commit,
    RV_Vote_Rollback,
    RV_Vote_ReadOnly,
    RV_NotPrepared,
    RV_Committed,
    RV_RolledBack
};

typedef ResourceVote& ResourceVote_out;

extern OB::TypeCodeConst _tc_ResourceVote;

//
// IDL:CosTransactions/TRANSACTION_REQUIRED:1.0
//
struct TRANSACTION_REQUIRED : public CORBA::UserException
{
    TRANSACTION_REQUIRED() { }
    TRANSACTION_REQUIRED(const TRANSACTION_REQUIRED&);
    TRANSACTION_REQUIRED& operator=(const TRANSACTION_REQUIRED&);

    static TRANSACTION_REQUIRED* _downcast(CORBA::Exception*);
    static const TRANSACTION_REQUIRED* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(TRANSACTION_REQUIRED&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_TRANSACTION_REQUIRED;

//
// IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0
//
struct TRANSACTION_ROLLEDBACK : public CORBA::UserException
{
    TRANSACTION_ROLLEDBACK() { }
    TRANSACTION_ROLLEDBACK(const TRANSACTION_ROLLEDBACK&);
    TRANSACTION_ROLLEDBACK& operator=(const TRANSACTION_ROLLEDBACK&);

    static TRANSACTION_ROLLEDBACK* _downcast(CORBA::Exception*);
    static const TRANSACTION_ROLLEDBACK* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(TRANSACTION_ROLLEDBACK&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_TRANSACTION_ROLLEDBACK;

//
// IDL:CosTransactions/INVALID_TRANSACTION:1.0
//
struct INVALID_TRANSACTION : public CORBA::UserException
{
    INVALID_TRANSACTION() { }
    INVALID_TRANSACTION(const INVALID_TRANSACTION&);
    INVALID_TRANSACTION& operator=(const INVALID_TRANSACTION&);

    static INVALID_TRANSACTION* _downcast(CORBA::Exception*);
    static const INVALID_TRANSACTION* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(INVALID_TRANSACTION&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_INVALID_TRANSACTION;

//
// IDL:CosTransactions/WRONG_TRANSACTION:1.0
//
struct WRONG_TRANSACTION : public CORBA::UserException
{
    WRONG_TRANSACTION() { }
    WRONG_TRANSACTION(const WRONG_TRANSACTION&);
    WRONG_TRANSACTION& operator=(const WRONG_TRANSACTION&);

    static WRONG_TRANSACTION* _downcast(CORBA::Exception*);
    static const WRONG_TRANSACTION* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(WRONG_TRANSACTION&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_WRONG_TRANSACTION;

//
// IDL:CosTransactions/HeuristicRollback:1.0
//
struct HeuristicRollback : public CORBA::UserException
{
    HeuristicRollback() { }
    HeuristicRollback(const HeuristicRollback&);
    HeuristicRollback& operator=(const HeuristicRollback&);

    static HeuristicRollback* _downcast(CORBA::Exception*);
    static const HeuristicRollback* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(HeuristicRollback&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_HeuristicRollback;

//
// IDL:CosTransactions/HeuristicCommit:1.0
//
struct HeuristicCommit : public CORBA::UserException
{
    HeuristicCommit() { }
    HeuristicCommit(const HeuristicCommit&);
    HeuristicCommit& operator=(const HeuristicCommit&);

    static HeuristicCommit* _downcast(CORBA::Exception*);
    static const HeuristicCommit* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(HeuristicCommit&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_HeuristicCommit;

//
// IDL:CosTransactions/HeuristicMixed:1.0
//
struct HeuristicMixed : public CORBA::UserException
{
    HeuristicMixed() { }
    HeuristicMixed(const HeuristicMixed&);
    HeuristicMixed& operator=(const HeuristicMixed&);

    static HeuristicMixed* _downcast(CORBA::Exception*);
    static const HeuristicMixed* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(HeuristicMixed&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_HeuristicMixed;

//
// IDL:CosTransactions/HeuristicHazard:1.0
//
struct HeuristicHazard : public CORBA::UserException
{
    HeuristicHazard() { }
    HeuristicHazard(const HeuristicHazard&);
    HeuristicHazard& operator=(const HeuristicHazard&);

    static HeuristicHazard* _downcast(CORBA::Exception*);
    static const HeuristicHazard* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(HeuristicHazard&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_HeuristicHazard;

//
// IDL:CosTransactions/SubtransactionsUnavailable:1.0
//
struct SubtransactionsUnavailable : public CORBA::UserException
{
    SubtransactionsUnavailable() { }
    SubtransactionsUnavailable(const SubtransactionsUnavailable&);
    SubtransactionsUnavailable& operator=(const SubtransactionsUnavailable&);

    static SubtransactionsUnavailable* _downcast(CORBA::Exception*);
    static const SubtransactionsUnavailable* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(SubtransactionsUnavailable&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_SubtransactionsUnavailable;

//
// IDL:CosTransactions/NotSubtransaction:1.0
//
struct NotSubtransaction : public CORBA::UserException
{
    NotSubtransaction() { }
    NotSubtransaction(const NotSubtransaction&);
    NotSubtransaction& operator=(const NotSubtransaction&);

    static NotSubtransaction* _downcast(CORBA::Exception*);
    static const NotSubtransaction* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(NotSubtransaction&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_NotSubtransaction;

//
// IDL:CosTransactions/Inactive:1.0
//
struct Inactive : public CORBA::UserException
{
    Inactive() { }
    Inactive(const Inactive&);
    Inactive& operator=(const Inactive&);

    static Inactive* _downcast(CORBA::Exception*);
    static const Inactive* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(Inactive&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_Inactive;

//
// IDL:CosTransactions/NotPrepared:1.0
//
struct NotPrepared : public CORBA::UserException
{
    NotPrepared() { }
    NotPrepared(const NotPrepared&);
    NotPrepared& operator=(const NotPrepared&);

    static NotPrepared* _downcast(CORBA::Exception*);
    static const NotPrepared* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(NotPrepared&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_NotPrepared;

//
// IDL:CosTransactions/NoTransaction:1.0
//
struct NoTransaction : public CORBA::UserException
{
    NoTransaction() { }
    NoTransaction(const NoTransaction&);
    NoTransaction& operator=(const NoTransaction&);

    static NoTransaction* _downcast(CORBA::Exception*);
    static const NoTransaction* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(NoTransaction&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_NoTransaction;

//
// IDL:CosTransactions/InvalidControl:1.0
//
struct InvalidControl : public CORBA::UserException
{
    InvalidControl() { }
    InvalidControl(const InvalidControl&);
    InvalidControl& operator=(const InvalidControl&);

    static InvalidControl* _downcast(CORBA::Exception*);
    static const InvalidControl* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(InvalidControl&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_InvalidControl;

//
// IDL:CosTransactions/Unavailable:1.0
//
struct Unavailable : public CORBA::UserException
{
    Unavailable() { }
    Unavailable(const Unavailable&);
    Unavailable& operator=(const Unavailable&);

    static Unavailable* _downcast(CORBA::Exception*);
    static const Unavailable* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(Unavailable&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_Unavailable;

//
// IDL:CosTransactions/SynchronizationUnavailable:1.0
//
struct SynchronizationUnavailable : public CORBA::UserException
{
    SynchronizationUnavailable() { }
    SynchronizationUnavailable(const SynchronizationUnavailable&);
    SynchronizationUnavailable& operator=(const SynchronizationUnavailable&);

    static SynchronizationUnavailable* _downcast(CORBA::Exception*);
    static const SynchronizationUnavailable* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    static void _OB_unmarshal(SynchronizationUnavailable&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_SynchronizationUnavailable;

//
// IDL:CosTransactions/TransactionFactory:1.0
//
class TransactionFactory : virtual public CORBA::Object
{
    TransactionFactory(const TransactionFactory&);
    void operator=(const TransactionFactory&);

protected:

    static const char* ids_[];

public:

    TransactionFactory() { }
    virtual ~TransactionFactory() { }

    typedef TransactionFactory_ptr _ptr_type;
    typedef TransactionFactory_var _var_type;

    static inline TransactionFactory_ptr
    _duplicate(TransactionFactory_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline TransactionFactory_ptr
    _nil()
    {
        return 0;
    }

    static TransactionFactory_ptr _narrow(CORBA::Object_ptr);
    static TransactionFactory_ptr _unchecked_narrow(CORBA::Object_ptr);

    static TransactionFactory_ptr _narrow(CORBA::AbstractBase_ptr);
    static TransactionFactory_ptr _unchecked_narrow(CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:CosTransactions/TransactionFactory/create:1.0
    //
    virtual Control_ptr create(CORBA::ULong time_out) = 0;
};

//
// IDL:CosTransactions/Control:1.0
//
class Control : virtual public CORBA::Object
{
    Control(const Control&);
    void operator=(const Control&);

protected:

    static const char* ids_[];

public:

    Control() { }
    virtual ~Control() { }

    typedef Control_ptr _ptr_type;
    typedef Control_var _var_type;

    static inline Control_ptr
    _duplicate(Control_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline Control_ptr
    _nil()
    {
        return 0;
    }

    static Control_ptr _narrow(CORBA::Object_ptr);
    static Control_ptr _unchecked_narrow(CORBA::Object_ptr);

    static Control_ptr _narrow(CORBA::AbstractBase_ptr);
    static Control_ptr _unchecked_narrow(CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:CosTransactions/Control/get_terminator:1.0
    //
    virtual Terminator_ptr get_terminator() = 0;

    //
    // IDL:CosTransactions/Control/get_coordinator:1.0
    //
    virtual Coordinator_ptr get_coordinator() = 0;

    //
    // IDL:CosTransactions/Control/release:1.0
    //
    virtual void release() = 0;
};

//
// IDL:CosTransactions/Terminator:1.0
//
class Terminator : virtual public CORBA::Object
{
    Terminator(const Terminator&);
    void operator=(const Terminator&);

protected:

    static const char* ids_[];

public:

    Terminator() { }
    virtual ~Terminator() { }

    typedef Terminator_ptr _ptr_type;
    typedef Terminator_var _var_type;

    static inline Terminator_ptr
    _duplicate(Terminator_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline Terminator_ptr
    _nil()
    {
        return 0;
    }

    static Terminator_ptr _narrow(CORBA::Object_ptr);
    static Terminator_ptr _unchecked_narrow(CORBA::Object_ptr);

    static Terminator_ptr _narrow(CORBA::AbstractBase_ptr);
    static Terminator_ptr _unchecked_narrow(CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:CosTransactions/Terminator/commit:1.0
    //
    virtual void commit(CORBA::Boolean report_heuristics) = 0;

    //
    // IDL:CosTransactions/Terminator/rollback:1.0
    //
    virtual void rollback() = 0;

    //
    // IDL:CosTransactions/Terminator/release:1.0
    //
    virtual void release() = 0;
};

//
// IDL:CosTransactions/Coordinator:1.0
//
class Coordinator : virtual public CORBA::Object
{
    Coordinator(const Coordinator&);
    void operator=(const Coordinator&);

protected:

    static const char* ids_[];

public:

    Coordinator() { }
    virtual ~Coordinator() { }

    typedef Coordinator_ptr _ptr_type;
    typedef Coordinator_var _var_type;

    static inline Coordinator_ptr
    _duplicate(Coordinator_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline Coordinator_ptr
    _nil()
    {
        return 0;
    }

    static Coordinator_ptr _narrow(CORBA::Object_ptr);
    static Coordinator_ptr _unchecked_narrow(CORBA::Object_ptr);

    static Coordinator_ptr _narrow(CORBA::AbstractBase_ptr);
    static Coordinator_ptr _unchecked_narrow(CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:CosTransactions/Coordinator/RCV:1.0
    //
    struct RCV;
    typedef OB::VarVar< RCV > RCV_var;
    typedef OB::VarOut< RCV > RCV_out;

    struct RCV
    {
#ifdef OB_CLEAR_MEM
        RCV();
#else
        RCV() { }
#endif
        RCV(const RCV&);
        RCV& operator=(const RCV&);

        typedef RCV_var _var_type;

        ::Resource_var r;
        RecoveryCoordinator_var rc;
        ResourceVote rv;

        void _OB_marshal(OB::OutputStreamImpl*) const;
        static void _OB_unmarshal(RCV&, OB::InputStreamImpl*);
    };

    static OB::TypeCodeConst _tc_RCV;

    //
    // IDL:CosTransactions/Coordinator/RCVs:1.0
    //
    class OBUnique_RCVs { };

    typedef OB::VarSeq< RCV, OBUnique_RCVs > RCVs;
    typedef OB::SeqVar< OB::VarSeq< RCV, OBUnique_RCVs > > RCVs_var;
    typedef OB::SeqOut< OB::VarSeq< RCV, OBUnique_RCVs > > RCVs_out;
    static OB::TypeCodeConst _tc_RCVs;

    struct OBInfo_RCVs : public OB::ConstructedInfo
    {
        OBInfo_RCVs() { }

        virtual void free(void* p) const
        {
            delete (RCVs*)p;
        }

        virtual void* dup(const void* p) const
        {
            return new RCVs(*(const RCVs*)p);
        }

        virtual void marshal(const void*, OB::OutputStreamImpl*) const;
        virtual void unmarshal(void*, OB::InputStreamImpl*) const;
    };

#ifndef LITE_VERSION
//	static void remove(RCVs_var RCVs_var_tmp,CORBA::ULong idx);//renyi 11 25 : added
//SuLiang add .
    typedef CosTransactions::Coordinator::RCVs* RCVs_ptr;
    static void remove(RCVs_ptr RCVs_var_tmp,CORBA::ULong idx);
//SuLiang add.
#endif
    //
    // IDL:CosTransactions/Coordinator/get_status:1.0
    //
    virtual Status get_status() = 0;

    //
    // IDL:CosTransactions/Coordinator/is_same_transaction:1.0
    //
    virtual CORBA::Boolean is_same_transaction(Coordinator_ptr tc) = 0;

    //
    // IDL:CosTransactions/Coordinator/register_resource:1.0
    //
    virtual RecoveryCoordinator_ptr register_resource(::Resource_ptr r) = 0;

    //
    // IDL:CosTransactions/Coordinator/register_synchronization:1.0
    //
    virtual void register_synchronization(Synchronization_ptr sync) = 0;

    //
    // IDL:CosTransactions/Coordinator/rollback_only:1.0
    //
    virtual void rollback_only() = 0;

    //
    // IDL:CosTransactions/Coordinator/commit:1.0
    //
    virtual void commit(CORBA::Boolean report_heuristics) = 0;

    //
    // IDL:CosTransactions/Coordinator/rollback:1.0
    //
    virtual void rollback() = 0;

    //
    // IDL:CosTransactions/Coordinator/change_resourcevote:1.0
    //
    virtual void change_resourcevote(::Resource_ptr r,
                                     ResourceVote rv) = 0;

    //
    // IDL:CosTransactions/Coordinator/release:1.0
    //
    virtual void release() = 0;
};

//
// IDL:CosTransactions/RecoveryCoordinator:1.0
//
class RecoveryCoordinator : virtual public CORBA::Object
{
    RecoveryCoordinator(const RecoveryCoordinator&);
    void operator=(const RecoveryCoordinator&);

protected:

    static const char* ids_[];

public:

    RecoveryCoordinator() { }
    virtual ~RecoveryCoordinator() { }

    typedef RecoveryCoordinator_ptr _ptr_type;
    typedef RecoveryCoordinator_var _var_type;

    static inline RecoveryCoordinator_ptr
    _duplicate(RecoveryCoordinator_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline RecoveryCoordinator_ptr
    _nil()
    {
        return 0;
    }

    static RecoveryCoordinator_ptr _narrow(CORBA::Object_ptr);
    static RecoveryCoordinator_ptr _unchecked_narrow(CORBA::Object_ptr);

    static RecoveryCoordinator_ptr _narrow(CORBA::AbstractBase_ptr);
    static RecoveryCoordinator_ptr _unchecked_narrow(CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:CosTransactions/RecoveryCoordinator/replay_completion:1.0
    //
    virtual Status replay_completion(::Resource_ptr r) = 0;

    //
    // IDL:CosTransactions/RecoveryCoordinator/release:1.0
    //
    virtual void release() = 0;
};

//
// IDL:CosTransactions/TransactionalObject:1.0
//
class TransactionalObject : virtual public CORBA::Object
{
    TransactionalObject(const TransactionalObject&);
    void operator=(const TransactionalObject&);

protected:

    static const char* ids_[];

public:

    TransactionalObject() { }
    virtual ~TransactionalObject() { }

    typedef TransactionalObject_ptr _ptr_type;
    typedef TransactionalObject_var _var_type;

    static inline TransactionalObject_ptr
    _duplicate(TransactionalObject_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline TransactionalObject_ptr
    _nil()
    {
        return 0;
    }

    static TransactionalObject_ptr _narrow(CORBA::Object_ptr);
    static TransactionalObject_ptr _unchecked_narrow(CORBA::Object_ptr);

    static TransactionalObject_ptr _narrow(CORBA::AbstractBase_ptr);
    static TransactionalObject_ptr _unchecked_narrow(CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();
};

} // End of namespace CosTransactions

//
// IDL:CosTransactions:1.0
//
namespace OBProxy_CosTransactions
{

//
// IDL:CosTransactions/TransactionFactory:1.0
//
class TransactionFactory : virtual public ::CosTransactions::TransactionFactory,
                           virtual public OBCORBA::Object
{
    TransactionFactory(const TransactionFactory&);
    void operator=(const TransactionFactory&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    TransactionFactory() { }
    virtual ~TransactionFactory() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:CosTransactions/TransactionFactory/create:1.0
    //
    ::CosTransactions::Control_ptr create(CORBA::ULong time_out);
};

//
// IDL:CosTransactions/Control:1.0
//
class Control : virtual public ::CosTransactions::Control,
                virtual public OBCORBA::Object
{
    Control(const Control&);
    void operator=(const Control&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    Control() { }
    virtual ~Control() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:CosTransactions/Control/get_terminator:1.0
    //
    ::CosTransactions::Terminator_ptr get_terminator();

    //
    // IDL:CosTransactions/Control/get_coordinator:1.0
    //
    ::CosTransactions::Coordinator_ptr get_coordinator();

    //
    // IDL:CosTransactions/Control/release:1.0
    //
    void release();
};

//
// IDL:CosTransactions/Terminator:1.0
//
class Terminator : virtual public ::CosTransactions::Terminator,
                   virtual public OBCORBA::Object
{
    Terminator(const Terminator&);
    void operator=(const Terminator&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    Terminator() { }
    virtual ~Terminator() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:CosTransactions/Terminator/commit:1.0
    //
    void commit(CORBA::Boolean report_heuristics);

    //
    // IDL:CosTransactions/Terminator/rollback:1.0
    //
    void rollback();

    //
    // IDL:CosTransactions/Terminator/release:1.0
    //
    void release();
};

//
// IDL:CosTransactions/Coordinator:1.0
//
class Coordinator : virtual public ::CosTransactions::Coordinator,
                    virtual public OBCORBA::Object
{
    Coordinator(const Coordinator&);
    void operator=(const Coordinator&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    Coordinator() { }
    virtual ~Coordinator() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:CosTransactions/Coordinator/get_status:1.0
    //
    ::CosTransactions::Status get_status();

    //
    // IDL:CosTransactions/Coordinator/is_same_transaction:1.0
    //
    CORBA::Boolean is_same_transaction(::CosTransactions::Coordinator_ptr tc);

    //
    // IDL:CosTransactions/Coordinator/register_resource:1.0
    //
    ::CosTransactions::RecoveryCoordinator_ptr register_resource(::Resource_ptr r);

    //
    // IDL:CosTransactions/Coordinator/register_synchronization:1.0
    //
    void register_synchronization(::CosTransactions::Synchronization_ptr sync);

    //
    // IDL:CosTransactions/Coordinator/rollback_only:1.0
    //
    void rollback_only();

    //
    // IDL:CosTransactions/Coordinator/commit:1.0
    //
    void commit(CORBA::Boolean report_heuristics);

    //
    // IDL:CosTransactions/Coordinator/rollback:1.0
    //
    void rollback();

    //
    // IDL:CosTransactions/Coordinator/change_resourcevote:1.0
    //
    void change_resourcevote(::Resource_ptr r,
                             ::CosTransactions::ResourceVote rv);

    //
    // IDL:CosTransactions/Coordinator/release:1.0
    //
    void release();
};

//
// IDL:CosTransactions/RecoveryCoordinator:1.0
//
class RecoveryCoordinator : virtual public ::CosTransactions::RecoveryCoordinator,
                            virtual public OBCORBA::Object
{
    RecoveryCoordinator(const RecoveryCoordinator&);
    void operator=(const RecoveryCoordinator&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    RecoveryCoordinator() { }
    virtual ~RecoveryCoordinator() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:CosTransactions/RecoveryCoordinator/replay_completion:1.0
    //
    ::CosTransactions::Status replay_completion(::Resource_ptr r);

    //
    // IDL:CosTransactions/RecoveryCoordinator/release:1.0
    //
    void release();
};

//
// IDL:CosTransactions/TransactionalObject:1.0
//
class TransactionalObject : virtual public ::CosTransactions::TransactionalObject,
                            virtual public OBCORBA::Object
{
    TransactionalObject(const TransactionalObject&);
    void operator=(const TransactionalObject&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    TransactionalObject() { }
    virtual ~TransactionalObject() { }

    virtual const char** _OB_ids() const;
};

} // End of namespace OBProxy_CosTransactions

//
// IDL:CosTransactions:1.0
//
namespace OBStubImpl_CosTransactions
{

//
// IDL:CosTransactions/TransactionFactory:1.0
//
class TransactionFactory : virtual public OB::StubImplBase
{
    TransactionFactory(const TransactionFactory&);
    void operator=(const TransactionFactory&);

protected:

    TransactionFactory() { }

public:

    static inline TransactionFactory_ptr
    _duplicate(TransactionFactory_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline TransactionFactory_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:CosTransactions/TransactionFactory/create:1.0
    //
    virtual ::CosTransactions::Control_ptr create(CORBA::ULong time_out) = 0;
};

//
// IDL:CosTransactions/Control:1.0
//
class Control : virtual public OB::StubImplBase
{
    Control(const Control&);
    void operator=(const Control&);

protected:

    Control() { }

public:

    static inline Control_ptr
    _duplicate(Control_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline Control_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:CosTransactions/Control/get_terminator:1.0
    //
    virtual ::CosTransactions::Terminator_ptr get_terminator() = 0;

    //
    // IDL:CosTransactions/Control/get_coordinator:1.0
    //
    virtual ::CosTransactions::Coordinator_ptr get_coordinator() = 0;

    //
    // IDL:CosTransactions/Control/release:1.0
    //
    virtual void release() = 0;
};

//
// IDL:CosTransactions/Terminator:1.0
//
class Terminator : virtual public OB::StubImplBase
{
    Terminator(const Terminator&);
    void operator=(const Terminator&);

protected:

    Terminator() { }

public:

    static inline Terminator_ptr
    _duplicate(Terminator_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline Terminator_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:CosTransactions/Terminator/commit:1.0
    //
    virtual void commit(CORBA::Boolean report_heuristics) = 0;

    //
    // IDL:CosTransactions/Terminator/rollback:1.0
    //
    virtual void rollback() = 0;

    //
    // IDL:CosTransactions/Terminator/release:1.0
    //
    virtual void release() = 0;
};

//
// IDL:CosTransactions/Coordinator:1.0
//
class Coordinator : virtual public OB::StubImplBase
{
    Coordinator(const Coordinator&);
    void operator=(const Coordinator&);

protected:

    Coordinator() { }

public:

    static inline Coordinator_ptr
    _duplicate(Coordinator_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline Coordinator_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:CosTransactions/Coordinator/get_status:1.0
    //
    virtual ::CosTransactions::Status get_status() = 0;

    //
    // IDL:CosTransactions/Coordinator/is_same_transaction:1.0
    //
    virtual CORBA::Boolean is_same_transaction(::CosTransactions::Coordinator_ptr tc) = 0;

    //
    // IDL:CosTransactions/Coordinator/register_resource:1.0
    //
    virtual ::CosTransactions::RecoveryCoordinator_ptr register_resource(::Resource_ptr r) = 0;

    //
    // IDL:CosTransactions/Coordinator/register_synchronization:1.0
    //
    virtual void register_synchronization(::CosTransactions::Synchronization_ptr sync) = 0;

    //
    // IDL:CosTransactions/Coordinator/rollback_only:1.0
    //
    virtual void rollback_only() = 0;

    //
    // IDL:CosTransactions/Coordinator/commit:1.0
    //
    virtual void commit(CORBA::Boolean report_heuristics) = 0;

    //
    // IDL:CosTransactions/Coordinator/rollback:1.0
    //
    virtual void rollback() = 0;

    //
    // IDL:CosTransactions/Coordinator/change_resourcevote:1.0
    //
    virtual void change_resourcevote(::Resource_ptr r,
                                     ::CosTransactions::ResourceVote rv) = 0;

    //
    // IDL:CosTransactions/Coordinator/release:1.0
    //
    virtual void release() = 0;
};

//
// IDL:CosTransactions/RecoveryCoordinator:1.0
//
class RecoveryCoordinator : virtual public OB::StubImplBase
{
    RecoveryCoordinator(const RecoveryCoordinator&);
    void operator=(const RecoveryCoordinator&);

protected:

    RecoveryCoordinator() { }

public:

    static inline RecoveryCoordinator_ptr
    _duplicate(RecoveryCoordinator_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline RecoveryCoordinator_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:CosTransactions/RecoveryCoordinator/replay_completion:1.0
    //
    virtual ::CosTransactions::Status replay_completion(::Resource_ptr r) = 0;

    //
    // IDL:CosTransactions/RecoveryCoordinator/release:1.0
    //
    virtual void release() = 0;
};

//
// IDL:CosTransactions/TransactionalObject:1.0
//
class TransactionalObject : virtual public OB::StubImplBase
{
    TransactionalObject(const TransactionalObject&);
    void operator=(const TransactionalObject&);

protected:

    TransactionalObject() { }

public:

    static inline TransactionalObject_ptr
    _duplicate(TransactionalObject_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline TransactionalObject_ptr
    _nil()
    {
        return 0;
    }
};

} // End of namespace OBStubImpl_CosTransactions

//
// IDL:CosTransactions:1.0
//
namespace OBMarshalStubImpl_CosTransactions
{

//
// IDL:CosTransactions/TransactionFactory:1.0
//
class TransactionFactory : virtual public OBStubImpl_CosTransactions::TransactionFactory,
                           virtual public OB::MarshalStubImpl
{
    TransactionFactory(const TransactionFactory&);
    void operator=(const TransactionFactory&);

protected:

    TransactionFactory() { }
    friend class OBProxy_CosTransactions::TransactionFactory;

public:

    //
    // IDL:CosTransactions/TransactionFactory/create:1.0
    //
    virtual ::CosTransactions::Control_ptr create(CORBA::ULong time_out);
};

//
// IDL:CosTransactions/Control:1.0
//
class Control : virtual public OBStubImpl_CosTransactions::Control,
                virtual public OB::MarshalStubImpl
{
    Control(const Control&);
    void operator=(const Control&);

protected:

    Control() { }
    friend class OBProxy_CosTransactions::Control;

public:

    //
    // IDL:CosTransactions/Control/get_terminator:1.0
    //
    virtual ::CosTransactions::Terminator_ptr get_terminator();

    //
    // IDL:CosTransactions/Control/get_coordinator:1.0
    //
    virtual ::CosTransactions::Coordinator_ptr get_coordinator();

    //
    // IDL:CosTransactions/Control/release:1.0
    //
    virtual void release();
};

//
// IDL:CosTransactions/Terminator:1.0
//
class Terminator : virtual public OBStubImpl_CosTransactions::Terminator,
                   virtual public OB::MarshalStubImpl
{
    Terminator(const Terminator&);
    void operator=(const Terminator&);

protected:

    Terminator() { }
    friend class OBProxy_CosTransactions::Terminator;

public:

    //
    // IDL:CosTransactions/Terminator/commit:1.0
    //
    virtual void commit(CORBA::Boolean report_heuristics);

    //
    // IDL:CosTransactions/Terminator/rollback:1.0
    //
    virtual void rollback();

    //
    // IDL:CosTransactions/Terminator/release:1.0
    //
    virtual void release();
};

//
// IDL:CosTransactions/Coordinator:1.0
//
class Coordinator : virtual public OBStubImpl_CosTransactions::Coordinator,
                    virtual public OB::MarshalStubImpl
{
    Coordinator(const Coordinator&);
    void operator=(const Coordinator&);

protected:

    Coordinator() { }
    friend class OBProxy_CosTransactions::Coordinator;

public:

    //
    // IDL:CosTransactions/Coordinator/get_status:1.0
    //
    virtual ::CosTransactions::Status get_status();

    //
    // IDL:CosTransactions/Coordinator/is_same_transaction:1.0
    //
    virtual CORBA::Boolean is_same_transaction(::CosTransactions::Coordinator_ptr tc);

    //
    // IDL:CosTransactions/Coordinator/register_resource:1.0
    //
    virtual ::CosTransactions::RecoveryCoordinator_ptr register_resource(::Resource_ptr r);

    //
    // IDL:CosTransactions/Coordinator/register_synchronization:1.0
    //
    virtual void register_synchronization(::CosTransactions::Synchronization_ptr sync);

    //
    // IDL:CosTransactions/Coordinator/rollback_only:1.0
    //
    virtual void rollback_only();

    //
    // IDL:CosTransactions/Coordinator/commit:1.0
    //
    virtual void commit(CORBA::Boolean report_heuristics);

    //
    // IDL:CosTransactions/Coordinator/rollback:1.0
    //
    virtual void rollback();

    //
    // IDL:CosTransactions/Coordinator/change_resourcevote:1.0
    //
    virtual void change_resourcevote(::Resource_ptr r,
                                     ::CosTransactions::ResourceVote rv);

    //
    // IDL:CosTransactions/Coordinator/release:1.0
    //
    virtual void release();
};

//
// IDL:CosTransactions/RecoveryCoordinator:1.0
//
class RecoveryCoordinator : virtual public OBStubImpl_CosTransactions::RecoveryCoordinator,
                            virtual public OB::MarshalStubImpl
{
    RecoveryCoordinator(const RecoveryCoordinator&);
    void operator=(const RecoveryCoordinator&);

protected:

    RecoveryCoordinator() { }
    friend class OBProxy_CosTransactions::RecoveryCoordinator;

public:

    //
    // IDL:CosTransactions/RecoveryCoordinator/replay_completion:1.0
    //
    virtual ::CosTransactions::Status replay_completion(::Resource_ptr r);

    //
    // IDL:CosTransactions/RecoveryCoordinator/release:1.0
    //
    virtual void release();
};

//
// IDL:CosTransactions/TransactionalObject:1.0
//
class TransactionalObject : virtual public OBStubImpl_CosTransactions::TransactionalObject,
                            virtual public OB::MarshalStubImpl
{
    TransactionalObject(const TransactionalObject&);
    void operator=(const TransactionalObject&);

protected:

    TransactionalObject() { }
    friend class OBProxy_CosTransactions::TransactionalObject;

public:
};

} // End of namespace OBMarshalStubImpl_CosTransactions

//
// IDL:CosTransactions:1.0
//
namespace OBV_CosTransactions
{

} // End of namespace OBV_CosTransactions

//
// IDL:CosTransactions/Status:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::Status);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::Status&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Status val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::Status& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/Vote:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::Vote);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::Vote&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Vote val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::Vote& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/ResourceVote:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::ResourceVote);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::ResourceVote&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::ResourceVote val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::ResourceVote& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/TRANSACTION_REQUIRED:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::TRANSACTION_REQUIRED*);
void operator<<=(CORBA::Any&, const CosTransactions::TRANSACTION_REQUIRED&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::TRANSACTION_REQUIRED*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::TRANSACTION_REQUIRED* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::TRANSACTION_REQUIRED& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::TRANSACTION_REQUIRED*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::TRANSACTION_ROLLEDBACK*);
void operator<<=(CORBA::Any&, const CosTransactions::TRANSACTION_ROLLEDBACK&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::TRANSACTION_ROLLEDBACK*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::TRANSACTION_ROLLEDBACK* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::TRANSACTION_ROLLEDBACK& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::TRANSACTION_ROLLEDBACK*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/INVALID_TRANSACTION:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::INVALID_TRANSACTION*);
void operator<<=(CORBA::Any&, const CosTransactions::INVALID_TRANSACTION&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::INVALID_TRANSACTION*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::INVALID_TRANSACTION* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::INVALID_TRANSACTION& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::INVALID_TRANSACTION*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/WRONG_TRANSACTION:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::WRONG_TRANSACTION*);
void operator<<=(CORBA::Any&, const CosTransactions::WRONG_TRANSACTION&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::WRONG_TRANSACTION*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::WRONG_TRANSACTION* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::WRONG_TRANSACTION& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::WRONG_TRANSACTION*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/HeuristicRollback:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::HeuristicRollback*);
void operator<<=(CORBA::Any&, const CosTransactions::HeuristicRollback&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::HeuristicRollback*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::HeuristicRollback* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::HeuristicRollback& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::HeuristicRollback*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/HeuristicCommit:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::HeuristicCommit*);
void operator<<=(CORBA::Any&, const CosTransactions::HeuristicCommit&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::HeuristicCommit*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::HeuristicCommit* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::HeuristicCommit& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::HeuristicCommit*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/HeuristicMixed:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::HeuristicMixed*);
void operator<<=(CORBA::Any&, const CosTransactions::HeuristicMixed&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::HeuristicMixed*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::HeuristicMixed* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::HeuristicMixed& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::HeuristicMixed*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/HeuristicHazard:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::HeuristicHazard*);
void operator<<=(CORBA::Any&, const CosTransactions::HeuristicHazard&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::HeuristicHazard*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::HeuristicHazard* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::HeuristicHazard& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::HeuristicHazard*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/SubtransactionsUnavailable:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::SubtransactionsUnavailable*);
void operator<<=(CORBA::Any&, const CosTransactions::SubtransactionsUnavailable&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::SubtransactionsUnavailable*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::SubtransactionsUnavailable* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::SubtransactionsUnavailable& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::SubtransactionsUnavailable*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/NotSubtransaction:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::NotSubtransaction*);
void operator<<=(CORBA::Any&, const CosTransactions::NotSubtransaction&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::NotSubtransaction*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::NotSubtransaction* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::NotSubtransaction& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::NotSubtransaction*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/Inactive:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::Inactive*);
void operator<<=(CORBA::Any&, const CosTransactions::Inactive&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::Inactive*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Inactive* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::Inactive& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::Inactive*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/NotPrepared:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::NotPrepared*);
void operator<<=(CORBA::Any&, const CosTransactions::NotPrepared&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::NotPrepared*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::NotPrepared* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::NotPrepared& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::NotPrepared*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/NoTransaction:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::NoTransaction*);
void operator<<=(CORBA::Any&, const CosTransactions::NoTransaction&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::NoTransaction*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::NoTransaction* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::NoTransaction& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::NoTransaction*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/InvalidControl:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::InvalidControl*);
void operator<<=(CORBA::Any&, const CosTransactions::InvalidControl&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::InvalidControl*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::InvalidControl* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::InvalidControl& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::InvalidControl*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/Unavailable:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::Unavailable*);
void operator<<=(CORBA::Any&, const CosTransactions::Unavailable&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::Unavailable*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Unavailable* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::Unavailable& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::Unavailable*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/SynchronizationUnavailable:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::SynchronizationUnavailable*);
void operator<<=(CORBA::Any&, const CosTransactions::SynchronizationUnavailable&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::SynchronizationUnavailable*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::SynchronizationUnavailable* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::SynchronizationUnavailable& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::SynchronizationUnavailable*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/TransactionFactory:1.0
//
namespace CORBA
{

inline void
release(::CosTransactions::TransactionFactory_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::CosTransactions::TransactionFactory_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_CosTransactions::TransactionFactory_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_CosTransactions::TransactionFactory_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, CosTransactions::TransactionFactory_ptr*);
void operator<<=(CORBA::Any&, CosTransactions::TransactionFactory_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::TransactionFactory_ptr&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::TransactionFactory_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::TransactionFactory_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::TransactionFactory_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/Control:1.0
//
namespace CORBA
{

inline void
release(::CosTransactions::Control_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::CosTransactions::Control_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_CosTransactions::Control_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_CosTransactions::Control_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, CosTransactions::Control_ptr*);
void operator<<=(CORBA::Any&, CosTransactions::Control_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::Control_ptr&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Control_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Control_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::Control_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/Terminator:1.0
//
namespace CORBA
{

inline void
release(::CosTransactions::Terminator_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::CosTransactions::Terminator_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_CosTransactions::Terminator_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_CosTransactions::Terminator_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, CosTransactions::Terminator_ptr*);
void operator<<=(CORBA::Any&, CosTransactions::Terminator_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::Terminator_ptr&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Terminator_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Terminator_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::Terminator_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/Coordinator:1.0
//
namespace CORBA
{

inline void
release(::CosTransactions::Coordinator_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::CosTransactions::Coordinator_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_CosTransactions::Coordinator_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_CosTransactions::Coordinator_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, CosTransactions::Coordinator_ptr*);
void operator<<=(CORBA::Any&, CosTransactions::Coordinator_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::Coordinator_ptr&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Coordinator_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Coordinator_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::Coordinator_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/Coordinator/RCV:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::Coordinator::RCV*);
void operator<<=(CORBA::Any&, const CosTransactions::Coordinator::RCV&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::Coordinator::RCV*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Coordinator::RCV* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::Coordinator::RCV& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::Coordinator::RCV*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/Coordinator/RCVs:1.0
//
void operator<<=(CORBA::Any&, CosTransactions::Coordinator::RCVs*);
void operator<<=(CORBA::Any&, const CosTransactions::Coordinator::RCVs&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CosTransactions::Coordinator::RCVs*&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::Coordinator::RCVs* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CosTransactions::Coordinator::RCVs& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CosTransactions::Coordinator::RCVs*& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/RecoveryCoordinator:1.0
//
namespace CORBA
{

inline void
release(::CosTransactions::RecoveryCoordinator_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::CosTransactions::RecoveryCoordinator_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_CosTransactions::RecoveryCoordinator_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_CosTransactions::RecoveryCoordinator_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, CosTransactions::RecoveryCoordinator_ptr*);
void operator<<=(CORBA::Any&, CosTransactions::RecoveryCoordinator_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::RecoveryCoordinator_ptr&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::RecoveryCoordinator_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::RecoveryCoordinator_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::RecoveryCoordinator_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:CosTransactions/TransactionalObject:1.0
//
namespace CORBA
{

inline void
release(::CosTransactions::TransactionalObject_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::CosTransactions::TransactionalObject_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_CosTransactions::TransactionalObject_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_CosTransactions::TransactionalObject_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, CosTransactions::TransactionalObject_ptr*);
void operator<<=(CORBA::Any&, CosTransactions::TransactionalObject_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, CosTransactions::TransactionalObject_ptr&);

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::TransactionalObject_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, CosTransactions::TransactionalObject_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CosTransactions::TransactionalObject_ptr& val)
{
    return any.in() >>= val;
}

#endif
