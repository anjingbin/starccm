// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2001
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.1.0

#include <OB/CORBAClient.h>
#include <CosTransactionsOTS.h>

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4010000L)
#       error ORBacus version mismatch!
#   endif
#endif

namespace CosTransactions
{

::OB::TypeCodeConst _tc_Status(
"010000001100000016010000010000001f00000049444c3a436f735472616e73616374696f6e7"
"32f5374617475733a312e3000100700000053746174757300000a0000000d0000005374617475"
"7341637469766500000000150000005374617475734d61726b6564526f6c6c6261636b0000000"
"00f0000005374617475735072657061726564000010000000537461747573436f6d6d69747465"
"640011000000537461747573526f6c6c65644261636b000000000e000000537461747573556e6"
"b6e6f776e008100140000005374617475734e6f5472616e73616374696f6e0010000000537461"
"747573507265706172696e670011000000537461747573436f6d6d697474696e6700000000120"
"00000537461747573526f6c6c696e674261636b00"
);

::OB::TypeCodeConst _tc_Vote(
"01000000110000006d000000010000001d00000049444c3a436f735472616e73616374696f6e7"
"32f566f74653a312e300030001005000000566f746500730000030000000b000000566f746543"
"6f6d6d697400650d000000566f7465526f6c6c6261636b006b65640d000000566f74655265616"
"44f6e6c7900"
);

::OB::TypeCodeConst _tc_ResourceVote(
"0100000011000000c6000000010000002500000049444c3a436f735472616e73616374696f6e7"
"32f5265736f75726365566f74653a312e30006f74650d0000005265736f75726365566f746500"
"6f6d6d060000000f00000052565f566f74655f436f6d6d697400641100000052565f566f74655"
"f526f6c6c6261636b007350721100000052565f566f74655f526561644f6e6c79006d69740f00"
"000052565f4e6f74507265706172656400640d00000052565f436f6d6d69747465640073556e0"
"e00000052565f526f6c6c65644261636b00"
);

::OB::TypeCodeConst _tc_TRANSACTION_REQUIRED(
"010000001600000058000000010000002d00000049444c3a436f735472616e73616374696f6e7"
"32f5452414e53414354494f4e5f52455155495245443a312e300065736f150000005452414e53"
"414354494f4e5f52455155495245440074655f00000000"
);

::OB::TypeCodeConst _tc_TRANSACTION_ROLLEDBACK(
"010000001600000058000000012e81002f00000049444c3a436f735472616e73616374696f6e7"
"32f5452414e53414354494f4e5f524f4c4c45444241434b3a312e300010170000005452414e53"
"414354494f4e5f524f4c4c45444241434b001000000000"
);

::OB::TypeCodeConst _tc_INVALID_TRANSACTION(
"010000001600000050000000012e81002c00000049444c3a436f735472616e73616374696f6e7"
"32f494e56414c49445f5452414e53414354494f4e3a312e300014000000494e56414c49445f54"
"52414e53414354494f4e0000000000"
);

::OB::TypeCodeConst _tc_WRONG_TRANSACTION(
"010000001600000050000000011481002a00000049444c3a436f735472616e73616374696f6e7"
"32f57524f4e475f5452414e53414354494f4e3a312e300034001200000057524f4e475f545241"
"4e53414354494f4e00340000000000"
);

::OB::TypeCodeConst _tc_HeuristicRollback(
"010000001600000050000000011481002a00000049444c3a436f735472616e73616374696f6e7"
"32f486575726973746963526f6c6c6261636b3a312e3000340012000000486575726973746963"
"526f6c6c6261636b00340000000000"
);

::OB::TypeCodeConst _tc_HeuristicCommit(
"010000001600000048000000011481002800000049444c3a436f735472616e73616374696f6e7"
"32f486575726973746963436f6d6d69743a312e300010000000486575726973746963436f6d6d"
"69740000000000"
);

::OB::TypeCodeConst _tc_HeuristicMixed(
"010000001600000048000000011481002700000049444c3a436f735472616e73616374696f6e7"
"32f4865757269737469634d697865643a312e3000000f0000004865757269737469634d697865"
"64001000000000"
);

::OB::TypeCodeConst _tc_HeuristicHazard(
"010000001600000048000000011481002800000049444c3a436f735472616e73616374696f6e7"
"32f48657572697374696348617a6172643a312e30001000000048657572697374696348617a61"
"72640000000000"
);

::OB::TypeCodeConst _tc_SubtransactionsUnavailable(
"010000001600000060000000011481003300000049444c3a436f735472616e73616374696f6e7"
"32f5375627472616e73616374696f6e73556e617661696c61626c653a312e3000101b00000053"
"75627472616e73616374696f6e73556e617661696c61626c65000000000000"
);

::OB::TypeCodeConst _tc_NotSubtransaction(
"010000001600000050000000011481002a00000049444c3a436f735472616e73616374696f6e7"
"32f4e6f745375627472616e73616374696f6e3a312e30003400120000004e6f74537562747261"
"6e73616374696f6e00340000000000"
);

::OB::TypeCodeConst _tc_Inactive(
"010000001600000040000000011481002100000049444c3a436f735472616e73616374696f6e7"
"32f496e6163746976653a312e300014060009000000496e616374697665008e251000000000"
);

::OB::TypeCodeConst _tc_NotPrepared(
"010000001600000040000000011181002400000049444c3a436f735472616e73616374696f6e7"
"32f4e6f7450726570617265643a312e30000c0000004e6f7450726570617265640000000000"
);

::OB::TypeCodeConst _tc_NoTransaction(
"010000001600000048000000011181002600000049444c3a436f735472616e73616374696f6e7"
"32f4e6f5472616e73616374696f6e3a312e300000000e0000004e6f5472616e73616374696f6e"
"00201000000000"
);

::OB::TypeCodeConst _tc_InvalidControl(
"010000001600000048000000011481002700000049444c3a436f735472616e73616374696f6e7"
"32f496e76616c6964436f6e74726f6c3a312e3000000f000000496e76616c6964436f6e74726f"
"6c001000000000"
);

::OB::TypeCodeConst _tc_Unavailable(
"010000001600000040000000011481002400000049444c3a436f735472616e73616374696f6e7"
"32f556e617661696c61626c653a312e30000c000000556e617661696c61626c650000000000"
);

::OB::TypeCodeConst _tc_SynchronizationUnavailable(
"010000001600000060000000011181003300000049444c3a436f735472616e73616374696f6e7"
"32f53796e6368726f6e697a6174696f6e556e617661696c61626c653a312e3000101b00000053"
"796e6368726f6e697a6174696f6e556e617661696c61626c65000000000000"
);

::OB::TypeCodeConst _tc_TransactionFactory(
"010000000e0000004b000000011481002b00000049444c3a436f735472616e73616374696f6e7"
"32f5472616e73616374696f6e466163746f72793a312e300000130000005472616e7361637469"
"6f6e466163746f727900"
);

::OB::TypeCodeConst _tc_Control(
"010000000e00000034000000010a81002000000049444c3a436f735472616e73616374696f6e7"
"32f436f6e74726f6c3a312e300008000000436f6e74726f6c00"
);

::OB::TypeCodeConst _tc_Terminator(
"010000000e0000003b000000010b81002300000049444c3a436f735472616e73616374696f6e7"
"32f5465726d696e61746f723a312e3000000b0000005465726d696e61746f7200"
);

::OB::TypeCodeConst _tc_Coordinator(
"010000000e0000003c000000011181002400000049444c3a436f735472616e73616374696f6e7"
"32f436f6f7264696e61746f723a312e30000c000000436f6f7264696e61746f7200"
);

::OB::TypeCodeConst Coordinator::_tc_RCV(
"01e912000f000000aa01000001e912002800000049444c3a436f735472616e73616374696f6e7"
"32f436f6f7264696e61746f722f5243563a312e30000400000052435600030000000200000072"
"0012000e00000029000000011f34001100000049444c3a5265736f757263653a312e300000000"
"0090000005265736f757263650014810003000000726300100e0000004c00000001e020102c00"
"000049444c3a436f735472616e73616374696f6e732f5265636f76657279436f6f7264696e617"
"46f723a312e3000140000005265636f76657279436f6f7264696e61746f720003000000727600"
"0011000000c6000000010000002500000049444c3a436f735472616e73616374696f6e732f526"
"5736f75726365566f74653a312e30000000000d0000005265736f75726365566f746500ea1200"
"060000000f00000052565f566f74655f436f6d6d697400001100000052565f566f74655f526f6"
"c6c6261636b000000001100000052565f566f74655f526561644f6e6c79000000000f00000052"
"565f4e6f74507265706172656400100d00000052565f436f6d6d697474656400ea12000e00000"
"052565f526f6c6c65644261636b00"
);

::OB::TypeCodeConst Coordinator::_tc_RCVs(
"010000001500000004020000012981002900000049444c3a436f735472616e73616374696f6e7"
"32f436f6f7264696e61746f722f524356733a312e3000393400050000005243567300e9120013"
"000000bc010000011e34000f000000aa010000012881002800000049444c3a436f735472616e7"
"3616374696f6e732f436f6f7264696e61746f722f5243563a312e300004000000524356000300"
"0000020000007200e6770e00000029000000010000001100000049444c3a5265736f757263653"
"a312e3000000000090000005265736f757263650039340003000000726300000e0000004c0000"
"00010000002c00000049444c3a436f735472616e73616374696f6e732f5265636f76657279436"
"f6f7264696e61746f723a312e3000140000005265636f76657279436f6f7264696e61746f7200"
"030000007276007711000000c6000000010000002500000049444c3a436f735472616e7361637"
"4696f6e732f5265736f75726365566f74653a312e30000000000d0000005265736f7572636556"
"6f746500000000060000000f00000052565f566f74655f436f6d6d697400001100000052565f5"
"66f74655f526f6c6c6261636b000000001100000052565f566f74655f526561644f6e6c790002"
"00000f00000052565f4e6f74507265706172656400000d00000052565f436f6d6d69747465640"
"03934000e00000052565f526f6c6c65644261636b00000000000000"
);

::OB::TypeCodeConst _tc_RecoveryCoordinator(
"013436390e0000004c000000013332662c00000049444c3a436f735472616e73616374696f6e7"
"32f5265636f76657279436f6f7264696e61746f723a312e3000140000005265636f7665727943"
"6f6f7264696e61746f7200"
);

::OB::TypeCodeConst _tc_TransactionalObject(
"010000000e0000004c000000010a81002c00000049444c3a436f735472616e73616374696f6e7"
"32f5472616e73616374696f6e616c4f626a6563743a312e3000140000005472616e7361637469"
"6f6e616c4f626a65637400"
);

} // End of namespace CosTransactions

//
// IDL:CosTransactions/Status:1.0
//
void
operator<<=(CORBA::Any& any, CosTransactions::Status v)
{
    any.replace(CosTransactions::_tc_Status, new CORBA::ULong((CORBA::ULong)v), true);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::Status& v)
{
    if(any.check_type(CosTransactions::_tc_Status))
    {
        v = (CosTransactions::Status)(*(CORBA::ULong*)any.value());
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/Vote:1.0
//
void
operator<<=(CORBA::Any& any, CosTransactions::Vote v)
{
    any.replace(CosTransactions::_tc_Vote, new CORBA::ULong((CORBA::ULong)v), true);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::Vote& v)
{
    if(any.check_type(CosTransactions::_tc_Vote))
    {
        v = (CosTransactions::Vote)(*(CORBA::ULong*)any.value());
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/ResourceVote:1.0
//
void
operator<<=(CORBA::Any& any, CosTransactions::ResourceVote v)
{
    any.replace(CosTransactions::_tc_ResourceVote, new CORBA::ULong((CORBA::ULong)v), true);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::ResourceVote& v)
{
    if(any.check_type(CosTransactions::_tc_ResourceVote))
    {
        v = (CosTransactions::ResourceVote)(*(CORBA::ULong*)any.value());
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/TRANSACTION_REQUIRED:1.0
//
CosTransactions::TRANSACTION_REQUIRED::TRANSACTION_REQUIRED(const TRANSACTION_REQUIRED& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::TRANSACTION_REQUIRED&
CosTransactions::TRANSACTION_REQUIRED::operator=(const TRANSACTION_REQUIRED&)
{
    return *this;
}

CosTransactions::TRANSACTION_REQUIRED*
CosTransactions::TRANSACTION_REQUIRED::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<TRANSACTION_REQUIRED*>(p);
}

const CosTransactions::TRANSACTION_REQUIRED*
CosTransactions::TRANSACTION_REQUIRED::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const TRANSACTION_REQUIRED*>(p);
}

const char*
CosTransactions::TRANSACTION_REQUIRED::_name() const
{
    return "TRANSACTION_REQUIRED";
}

const char*
CosTransactions::TRANSACTION_REQUIRED::_rep_id() const
{
    return "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0";
}

char*
CosTransactions::TRANSACTION_REQUIRED::_to_string() const
{
    return _OB_defaultToString("CosTransactions::TRANSACTION_REQUIRED");
}

CORBA::Exception*
CosTransactions::TRANSACTION_REQUIRED::_OB_clone() const
{
    return new TRANSACTION_REQUIRED(*this);
}

void
CosTransactions::TRANSACTION_REQUIRED::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(TRANSACTION_REQUIRED&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::TRANSACTION_REQUIRED* v)
{
    static const OB::Info< CosTransactions::TRANSACTION_REQUIRED > info;
    any.replace(CosTransactions::_tc_TRANSACTION_REQUIRED, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::TRANSACTION_REQUIRED& v)
{
    any <<= new CosTransactions::TRANSACTION_REQUIRED(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::TRANSACTION_REQUIRED*& v)
{
    if(any.check_type(CosTransactions::_tc_TRANSACTION_REQUIRED))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::TRANSACTION_REQUIRED* val = new CosTransactions::TRANSACTION_REQUIRED;
            CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::TRANSACTION_REQUIRED*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0
//
CosTransactions::TRANSACTION_ROLLEDBACK::TRANSACTION_ROLLEDBACK(const TRANSACTION_ROLLEDBACK& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::TRANSACTION_ROLLEDBACK&
CosTransactions::TRANSACTION_ROLLEDBACK::operator=(const TRANSACTION_ROLLEDBACK&)
{
    return *this;
}

CosTransactions::TRANSACTION_ROLLEDBACK*
CosTransactions::TRANSACTION_ROLLEDBACK::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<TRANSACTION_ROLLEDBACK*>(p);
}

const CosTransactions::TRANSACTION_ROLLEDBACK*
CosTransactions::TRANSACTION_ROLLEDBACK::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const TRANSACTION_ROLLEDBACK*>(p);
}

const char*
CosTransactions::TRANSACTION_ROLLEDBACK::_name() const
{
    return "TRANSACTION_ROLLEDBACK";
}

const char*
CosTransactions::TRANSACTION_ROLLEDBACK::_rep_id() const
{
    return "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0";
}

char*
CosTransactions::TRANSACTION_ROLLEDBACK::_to_string() const
{
    return _OB_defaultToString("CosTransactions::TRANSACTION_ROLLEDBACK");
}

CORBA::Exception*
CosTransactions::TRANSACTION_ROLLEDBACK::_OB_clone() const
{
    return new TRANSACTION_ROLLEDBACK(*this);
}

void
CosTransactions::TRANSACTION_ROLLEDBACK::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(TRANSACTION_ROLLEDBACK&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::TRANSACTION_ROLLEDBACK* v)
{
    static const OB::Info< CosTransactions::TRANSACTION_ROLLEDBACK > info;
    any.replace(CosTransactions::_tc_TRANSACTION_ROLLEDBACK, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::TRANSACTION_ROLLEDBACK& v)
{
    any <<= new CosTransactions::TRANSACTION_ROLLEDBACK(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::TRANSACTION_ROLLEDBACK*& v)
{
    if(any.check_type(CosTransactions::_tc_TRANSACTION_ROLLEDBACK))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::TRANSACTION_ROLLEDBACK* val = new CosTransactions::TRANSACTION_ROLLEDBACK;
            CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::TRANSACTION_ROLLEDBACK*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/INVALID_TRANSACTION:1.0
//
CosTransactions::INVALID_TRANSACTION::INVALID_TRANSACTION(const INVALID_TRANSACTION& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::INVALID_TRANSACTION&
CosTransactions::INVALID_TRANSACTION::operator=(const INVALID_TRANSACTION&)
{
    return *this;
}

CosTransactions::INVALID_TRANSACTION*
CosTransactions::INVALID_TRANSACTION::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<INVALID_TRANSACTION*>(p);
}

const CosTransactions::INVALID_TRANSACTION*
CosTransactions::INVALID_TRANSACTION::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const INVALID_TRANSACTION*>(p);
}

const char*
CosTransactions::INVALID_TRANSACTION::_name() const
{
    return "INVALID_TRANSACTION";
}

const char*
CosTransactions::INVALID_TRANSACTION::_rep_id() const
{
    return "IDL:CosTransactions/INVALID_TRANSACTION:1.0";
}

char*
CosTransactions::INVALID_TRANSACTION::_to_string() const
{
    return _OB_defaultToString("CosTransactions::INVALID_TRANSACTION");
}

CORBA::Exception*
CosTransactions::INVALID_TRANSACTION::_OB_clone() const
{
    return new INVALID_TRANSACTION(*this);
}

void
CosTransactions::INVALID_TRANSACTION::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(INVALID_TRANSACTION&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::INVALID_TRANSACTION* v)
{
    static const OB::Info< CosTransactions::INVALID_TRANSACTION > info;
    any.replace(CosTransactions::_tc_INVALID_TRANSACTION, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::INVALID_TRANSACTION& v)
{
    any <<= new CosTransactions::INVALID_TRANSACTION(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::INVALID_TRANSACTION*& v)
{
    if(any.check_type(CosTransactions::_tc_INVALID_TRANSACTION))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::INVALID_TRANSACTION* val = new CosTransactions::INVALID_TRANSACTION;
            CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::INVALID_TRANSACTION*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/WRONG_TRANSACTION:1.0
//
CosTransactions::WRONG_TRANSACTION::WRONG_TRANSACTION(const WRONG_TRANSACTION& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::WRONG_TRANSACTION&
CosTransactions::WRONG_TRANSACTION::operator=(const WRONG_TRANSACTION&)
{
    return *this;
}

CosTransactions::WRONG_TRANSACTION*
CosTransactions::WRONG_TRANSACTION::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<WRONG_TRANSACTION*>(p);
}

const CosTransactions::WRONG_TRANSACTION*
CosTransactions::WRONG_TRANSACTION::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const WRONG_TRANSACTION*>(p);
}

const char*
CosTransactions::WRONG_TRANSACTION::_name() const
{
    return "WRONG_TRANSACTION";
}

const char*
CosTransactions::WRONG_TRANSACTION::_rep_id() const
{
    return "IDL:CosTransactions/WRONG_TRANSACTION:1.0";
}

char*
CosTransactions::WRONG_TRANSACTION::_to_string() const
{
    return _OB_defaultToString("CosTransactions::WRONG_TRANSACTION");
}

CORBA::Exception*
CosTransactions::WRONG_TRANSACTION::_OB_clone() const
{
    return new WRONG_TRANSACTION(*this);
}

void
CosTransactions::WRONG_TRANSACTION::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(WRONG_TRANSACTION&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::WRONG_TRANSACTION* v)
{
    static const OB::Info< CosTransactions::WRONG_TRANSACTION > info;
    any.replace(CosTransactions::_tc_WRONG_TRANSACTION, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::WRONG_TRANSACTION& v)
{
    any <<= new CosTransactions::WRONG_TRANSACTION(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::WRONG_TRANSACTION*& v)
{
    if(any.check_type(CosTransactions::_tc_WRONG_TRANSACTION))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::WRONG_TRANSACTION* val = new CosTransactions::WRONG_TRANSACTION;
            CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::WRONG_TRANSACTION*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/HeuristicRollback:1.0
//
CosTransactions::HeuristicRollback::HeuristicRollback(const HeuristicRollback& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::HeuristicRollback&
CosTransactions::HeuristicRollback::operator=(const HeuristicRollback&)
{
    return *this;
}

CosTransactions::HeuristicRollback*
CosTransactions::HeuristicRollback::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<HeuristicRollback*>(p);
}

const CosTransactions::HeuristicRollback*
CosTransactions::HeuristicRollback::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const HeuristicRollback*>(p);
}

const char*
CosTransactions::HeuristicRollback::_name() const
{
    return "HeuristicRollback";
}

const char*
CosTransactions::HeuristicRollback::_rep_id() const
{
    return "IDL:CosTransactions/HeuristicRollback:1.0";
}

char*
CosTransactions::HeuristicRollback::_to_string() const
{
    return _OB_defaultToString("CosTransactions::HeuristicRollback");
}

CORBA::Exception*
CosTransactions::HeuristicRollback::_OB_clone() const
{
    return new HeuristicRollback(*this);
}

void
CosTransactions::HeuristicRollback::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::HeuristicRollback::_OB_unmarshal(HeuristicRollback&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/HeuristicRollback:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::HeuristicRollback* v)
{
    static const OB::Info< CosTransactions::HeuristicRollback > info;
    any.replace(CosTransactions::_tc_HeuristicRollback, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::HeuristicRollback& v)
{
    any <<= new CosTransactions::HeuristicRollback(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::HeuristicRollback*& v)
{
    if(any.check_type(CosTransactions::_tc_HeuristicRollback))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::HeuristicRollback* val = new CosTransactions::HeuristicRollback;
            CosTransactions::HeuristicRollback::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::HeuristicRollback*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/HeuristicCommit:1.0
//
CosTransactions::HeuristicCommit::HeuristicCommit(const HeuristicCommit& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::HeuristicCommit&
CosTransactions::HeuristicCommit::operator=(const HeuristicCommit&)
{
    return *this;
}

CosTransactions::HeuristicCommit*
CosTransactions::HeuristicCommit::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<HeuristicCommit*>(p);
}

const CosTransactions::HeuristicCommit*
CosTransactions::HeuristicCommit::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const HeuristicCommit*>(p);
}

const char*
CosTransactions::HeuristicCommit::_name() const
{
    return "HeuristicCommit";
}

const char*
CosTransactions::HeuristicCommit::_rep_id() const
{
    return "IDL:CosTransactions/HeuristicCommit:1.0";
}

char*
CosTransactions::HeuristicCommit::_to_string() const
{
    return _OB_defaultToString("CosTransactions::HeuristicCommit");
}

CORBA::Exception*
CosTransactions::HeuristicCommit::_OB_clone() const
{
    return new HeuristicCommit(*this);
}

void
CosTransactions::HeuristicCommit::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::HeuristicCommit::_OB_unmarshal(HeuristicCommit&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/HeuristicCommit:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::HeuristicCommit* v)
{
    static const OB::Info< CosTransactions::HeuristicCommit > info;
    any.replace(CosTransactions::_tc_HeuristicCommit, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::HeuristicCommit& v)
{
    any <<= new CosTransactions::HeuristicCommit(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::HeuristicCommit*& v)
{
    if(any.check_type(CosTransactions::_tc_HeuristicCommit))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::HeuristicCommit* val = new CosTransactions::HeuristicCommit;
            CosTransactions::HeuristicCommit::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::HeuristicCommit*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/HeuristicMixed:1.0
//
CosTransactions::HeuristicMixed::HeuristicMixed(const HeuristicMixed& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::HeuristicMixed&
CosTransactions::HeuristicMixed::operator=(const HeuristicMixed&)
{
    return *this;
}

CosTransactions::HeuristicMixed*
CosTransactions::HeuristicMixed::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<HeuristicMixed*>(p);
}

const CosTransactions::HeuristicMixed*
CosTransactions::HeuristicMixed::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const HeuristicMixed*>(p);
}

const char*
CosTransactions::HeuristicMixed::_name() const
{
    return "HeuristicMixed";
}

const char*
CosTransactions::HeuristicMixed::_rep_id() const
{
    return "IDL:CosTransactions/HeuristicMixed:1.0";
}

char*
CosTransactions::HeuristicMixed::_to_string() const
{
    return _OB_defaultToString("CosTransactions::HeuristicMixed");
}

CORBA::Exception*
CosTransactions::HeuristicMixed::_OB_clone() const
{
    return new HeuristicMixed(*this);
}

void
CosTransactions::HeuristicMixed::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::HeuristicMixed::_OB_unmarshal(HeuristicMixed&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/HeuristicMixed:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::HeuristicMixed* v)
{
    static const OB::Info< CosTransactions::HeuristicMixed > info;
    any.replace(CosTransactions::_tc_HeuristicMixed, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::HeuristicMixed& v)
{
    any <<= new CosTransactions::HeuristicMixed(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::HeuristicMixed*& v)
{
    if(any.check_type(CosTransactions::_tc_HeuristicMixed))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::HeuristicMixed* val = new CosTransactions::HeuristicMixed;
            CosTransactions::HeuristicMixed::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::HeuristicMixed*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/HeuristicHazard:1.0
//
CosTransactions::HeuristicHazard::HeuristicHazard(const HeuristicHazard& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::HeuristicHazard&
CosTransactions::HeuristicHazard::operator=(const HeuristicHazard&)
{
    return *this;
}

CosTransactions::HeuristicHazard*
CosTransactions::HeuristicHazard::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<HeuristicHazard*>(p);
}

const CosTransactions::HeuristicHazard*
CosTransactions::HeuristicHazard::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const HeuristicHazard*>(p);
}

const char*
CosTransactions::HeuristicHazard::_name() const
{
    return "HeuristicHazard";
}

const char*
CosTransactions::HeuristicHazard::_rep_id() const
{
    return "IDL:CosTransactions/HeuristicHazard:1.0";
}

char*
CosTransactions::HeuristicHazard::_to_string() const
{
    return _OB_defaultToString("CosTransactions::HeuristicHazard");
}

CORBA::Exception*
CosTransactions::HeuristicHazard::_OB_clone() const
{
    return new HeuristicHazard(*this);
}

void
CosTransactions::HeuristicHazard::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::HeuristicHazard::_OB_unmarshal(HeuristicHazard&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/HeuristicHazard:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::HeuristicHazard* v)
{
    static const OB::Info< CosTransactions::HeuristicHazard > info;
    any.replace(CosTransactions::_tc_HeuristicHazard, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::HeuristicHazard& v)
{
    any <<= new CosTransactions::HeuristicHazard(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::HeuristicHazard*& v)
{
    if(any.check_type(CosTransactions::_tc_HeuristicHazard))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::HeuristicHazard* val = new CosTransactions::HeuristicHazard;
            CosTransactions::HeuristicHazard::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::HeuristicHazard*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/SubtransactionsUnavailable:1.0
//
CosTransactions::SubtransactionsUnavailable::SubtransactionsUnavailable(const SubtransactionsUnavailable& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::SubtransactionsUnavailable&
CosTransactions::SubtransactionsUnavailable::operator=(const SubtransactionsUnavailable&)
{
    return *this;
}

CosTransactions::SubtransactionsUnavailable*
CosTransactions::SubtransactionsUnavailable::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<SubtransactionsUnavailable*>(p);
}

const CosTransactions::SubtransactionsUnavailable*
CosTransactions::SubtransactionsUnavailable::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const SubtransactionsUnavailable*>(p);
}

const char*
CosTransactions::SubtransactionsUnavailable::_name() const
{
    return "SubtransactionsUnavailable";
}

const char*
CosTransactions::SubtransactionsUnavailable::_rep_id() const
{
    return "IDL:CosTransactions/SubtransactionsUnavailable:1.0";
}

char*
CosTransactions::SubtransactionsUnavailable::_to_string() const
{
    return _OB_defaultToString("CosTransactions::SubtransactionsUnavailable");
}

CORBA::Exception*
CosTransactions::SubtransactionsUnavailable::_OB_clone() const
{
    return new SubtransactionsUnavailable(*this);
}

void
CosTransactions::SubtransactionsUnavailable::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::SubtransactionsUnavailable::_OB_unmarshal(SubtransactionsUnavailable&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/SubtransactionsUnavailable:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::SubtransactionsUnavailable* v)
{
    static const OB::Info< CosTransactions::SubtransactionsUnavailable > info;
    any.replace(CosTransactions::_tc_SubtransactionsUnavailable, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::SubtransactionsUnavailable& v)
{
    any <<= new CosTransactions::SubtransactionsUnavailable(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::SubtransactionsUnavailable*& v)
{
    if(any.check_type(CosTransactions::_tc_SubtransactionsUnavailable))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::SubtransactionsUnavailable* val = new CosTransactions::SubtransactionsUnavailable;
            CosTransactions::SubtransactionsUnavailable::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::SubtransactionsUnavailable*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/NotSubtransaction:1.0
//
CosTransactions::NotSubtransaction::NotSubtransaction(const NotSubtransaction& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::NotSubtransaction&
CosTransactions::NotSubtransaction::operator=(const NotSubtransaction&)
{
    return *this;
}

CosTransactions::NotSubtransaction*
CosTransactions::NotSubtransaction::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<NotSubtransaction*>(p);
}

const CosTransactions::NotSubtransaction*
CosTransactions::NotSubtransaction::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const NotSubtransaction*>(p);
}

const char*
CosTransactions::NotSubtransaction::_name() const
{
    return "NotSubtransaction";
}

const char*
CosTransactions::NotSubtransaction::_rep_id() const
{
    return "IDL:CosTransactions/NotSubtransaction:1.0";
}

char*
CosTransactions::NotSubtransaction::_to_string() const
{
    return _OB_defaultToString("CosTransactions::NotSubtransaction");
}

CORBA::Exception*
CosTransactions::NotSubtransaction::_OB_clone() const
{
    return new NotSubtransaction(*this);
}

void
CosTransactions::NotSubtransaction::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::NotSubtransaction::_OB_unmarshal(NotSubtransaction&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/NotSubtransaction:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::NotSubtransaction* v)
{
    static const OB::Info< CosTransactions::NotSubtransaction > info;
    any.replace(CosTransactions::_tc_NotSubtransaction, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::NotSubtransaction& v)
{
    any <<= new CosTransactions::NotSubtransaction(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::NotSubtransaction*& v)
{
    if(any.check_type(CosTransactions::_tc_NotSubtransaction))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::NotSubtransaction* val = new CosTransactions::NotSubtransaction;
            CosTransactions::NotSubtransaction::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::NotSubtransaction*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/Inactive:1.0
//
CosTransactions::Inactive::Inactive(const Inactive& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::Inactive&
CosTransactions::Inactive::operator=(const Inactive&)
{
    return *this;
}

CosTransactions::Inactive*
CosTransactions::Inactive::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<Inactive*>(p);
}

const CosTransactions::Inactive*
CosTransactions::Inactive::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const Inactive*>(p);
}

const char*
CosTransactions::Inactive::_name() const
{
    return "Inactive";
}

const char*
CosTransactions::Inactive::_rep_id() const
{
    return "IDL:CosTransactions/Inactive:1.0";
}

char*
CosTransactions::Inactive::_to_string() const
{
    return _OB_defaultToString("CosTransactions::Inactive");
}

CORBA::Exception*
CosTransactions::Inactive::_OB_clone() const
{
    return new Inactive(*this);
}

void
CosTransactions::Inactive::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::Inactive::_OB_unmarshal(Inactive&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/Inactive:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::Inactive* v)
{
    static const OB::Info< CosTransactions::Inactive > info;
    any.replace(CosTransactions::_tc_Inactive, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::Inactive& v)
{
    any <<= new CosTransactions::Inactive(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::Inactive*& v)
{
    if(any.check_type(CosTransactions::_tc_Inactive))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::Inactive* val = new CosTransactions::Inactive;
            CosTransactions::Inactive::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::Inactive*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/NotPrepared:1.0
//
CosTransactions::NotPrepared::NotPrepared(const NotPrepared& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::NotPrepared&
CosTransactions::NotPrepared::operator=(const NotPrepared&)
{
    return *this;
}

CosTransactions::NotPrepared*
CosTransactions::NotPrepared::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<NotPrepared*>(p);
}

const CosTransactions::NotPrepared*
CosTransactions::NotPrepared::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const NotPrepared*>(p);
}

const char*
CosTransactions::NotPrepared::_name() const
{
    return "NotPrepared";
}

const char*
CosTransactions::NotPrepared::_rep_id() const
{
    return "IDL:CosTransactions/NotPrepared:1.0";
}

char*
CosTransactions::NotPrepared::_to_string() const
{
    return _OB_defaultToString("CosTransactions::NotPrepared");
}

CORBA::Exception*
CosTransactions::NotPrepared::_OB_clone() const
{
    return new NotPrepared(*this);
}

void
CosTransactions::NotPrepared::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::NotPrepared::_OB_unmarshal(NotPrepared&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/NotPrepared:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::NotPrepared* v)
{
    static const OB::Info< CosTransactions::NotPrepared > info;
    any.replace(CosTransactions::_tc_NotPrepared, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::NotPrepared& v)
{
    any <<= new CosTransactions::NotPrepared(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::NotPrepared*& v)
{
    if(any.check_type(CosTransactions::_tc_NotPrepared))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::NotPrepared* val = new CosTransactions::NotPrepared;
            CosTransactions::NotPrepared::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::NotPrepared*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/NoTransaction:1.0
//
CosTransactions::NoTransaction::NoTransaction(const NoTransaction& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::NoTransaction&
CosTransactions::NoTransaction::operator=(const NoTransaction&)
{
    return *this;
}

CosTransactions::NoTransaction*
CosTransactions::NoTransaction::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<NoTransaction*>(p);
}

const CosTransactions::NoTransaction*
CosTransactions::NoTransaction::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const NoTransaction*>(p);
}

const char*
CosTransactions::NoTransaction::_name() const
{
    return "NoTransaction";
}

const char*
CosTransactions::NoTransaction::_rep_id() const
{
    return "IDL:CosTransactions/NoTransaction:1.0";
}

char*
CosTransactions::NoTransaction::_to_string() const
{
    return _OB_defaultToString("CosTransactions::NoTransaction");
}

CORBA::Exception*
CosTransactions::NoTransaction::_OB_clone() const
{
    return new NoTransaction(*this);
}

void
CosTransactions::NoTransaction::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::NoTransaction::_OB_unmarshal(NoTransaction&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/NoTransaction:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::NoTransaction* v)
{
    static const OB::Info< CosTransactions::NoTransaction > info;
    any.replace(CosTransactions::_tc_NoTransaction, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::NoTransaction& v)
{
    any <<= new CosTransactions::NoTransaction(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::NoTransaction*& v)
{
    if(any.check_type(CosTransactions::_tc_NoTransaction))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::NoTransaction* val = new CosTransactions::NoTransaction;
            CosTransactions::NoTransaction::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::NoTransaction*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/InvalidControl:1.0
//
CosTransactions::InvalidControl::InvalidControl(const InvalidControl& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::InvalidControl&
CosTransactions::InvalidControl::operator=(const InvalidControl&)
{
    return *this;
}

CosTransactions::InvalidControl*
CosTransactions::InvalidControl::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<InvalidControl*>(p);
}

const CosTransactions::InvalidControl*
CosTransactions::InvalidControl::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const InvalidControl*>(p);
}

const char*
CosTransactions::InvalidControl::_name() const
{
    return "InvalidControl";
}

const char*
CosTransactions::InvalidControl::_rep_id() const
{
    return "IDL:CosTransactions/InvalidControl:1.0";
}

char*
CosTransactions::InvalidControl::_to_string() const
{
    return _OB_defaultToString("CosTransactions::InvalidControl");
}

CORBA::Exception*
CosTransactions::InvalidControl::_OB_clone() const
{
    return new InvalidControl(*this);
}

void
CosTransactions::InvalidControl::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::InvalidControl::_OB_unmarshal(InvalidControl&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/InvalidControl:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::InvalidControl* v)
{
    static const OB::Info< CosTransactions::InvalidControl > info;
    any.replace(CosTransactions::_tc_InvalidControl, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::InvalidControl& v)
{
    any <<= new CosTransactions::InvalidControl(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::InvalidControl*& v)
{
    if(any.check_type(CosTransactions::_tc_InvalidControl))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::InvalidControl* val = new CosTransactions::InvalidControl;
            CosTransactions::InvalidControl::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::InvalidControl*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/Unavailable:1.0
//
CosTransactions::Unavailable::Unavailable(const Unavailable& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::Unavailable&
CosTransactions::Unavailable::operator=(const Unavailable&)
{
    return *this;
}

CosTransactions::Unavailable*
CosTransactions::Unavailable::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<Unavailable*>(p);
}

const CosTransactions::Unavailable*
CosTransactions::Unavailable::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const Unavailable*>(p);
}

const char*
CosTransactions::Unavailable::_name() const
{
    return "Unavailable";
}

const char*
CosTransactions::Unavailable::_rep_id() const
{
    return "IDL:CosTransactions/Unavailable:1.0";
}

char*
CosTransactions::Unavailable::_to_string() const
{
    return _OB_defaultToString("CosTransactions::Unavailable");
}

CORBA::Exception*
CosTransactions::Unavailable::_OB_clone() const
{
    return new Unavailable(*this);
}

void
CosTransactions::Unavailable::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::Unavailable::_OB_unmarshal(Unavailable&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/Unavailable:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::Unavailable* v)
{
    static const OB::Info< CosTransactions::Unavailable > info;
    any.replace(CosTransactions::_tc_Unavailable, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::Unavailable& v)
{
    any <<= new CosTransactions::Unavailable(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::Unavailable*& v)
{
    if(any.check_type(CosTransactions::_tc_Unavailable))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::Unavailable* val = new CosTransactions::Unavailable;
            CosTransactions::Unavailable::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::Unavailable*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/SynchronizationUnavailable:1.0
//
CosTransactions::SynchronizationUnavailable::SynchronizationUnavailable(const SynchronizationUnavailable& _ob_a)
    : CORBA::UserException(_ob_a)
{
}

CosTransactions::SynchronizationUnavailable&
CosTransactions::SynchronizationUnavailable::operator=(const SynchronizationUnavailable&)
{
    return *this;
}

CosTransactions::SynchronizationUnavailable*
CosTransactions::SynchronizationUnavailable::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<SynchronizationUnavailable*>(p);
}

const CosTransactions::SynchronizationUnavailable*
CosTransactions::SynchronizationUnavailable::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const SynchronizationUnavailable*>(p);
}

const char*
CosTransactions::SynchronizationUnavailable::_name() const
{
    return "SynchronizationUnavailable";
}

const char*
CosTransactions::SynchronizationUnavailable::_rep_id() const
{
    return "IDL:CosTransactions/SynchronizationUnavailable:1.0";
}

char*
CosTransactions::SynchronizationUnavailable::_to_string() const
{
    return _OB_defaultToString("CosTransactions::SynchronizationUnavailable");
}

CORBA::Exception*
CosTransactions::SynchronizationUnavailable::_OB_clone() const
{
    return new SynchronizationUnavailable(*this);
}

void
CosTransactions::SynchronizationUnavailable::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
CosTransactions::SynchronizationUnavailable::_OB_unmarshal(SynchronizationUnavailable&, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:CosTransactions/SynchronizationUnavailable:1.0") == 0);
}

void
operator<<=(CORBA::Any& any, CosTransactions::SynchronizationUnavailable* v)
{
    static const OB::Info< CosTransactions::SynchronizationUnavailable > info;
    any.replace(CosTransactions::_tc_SynchronizationUnavailable, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::SynchronizationUnavailable& v)
{
    any <<= new CosTransactions::SynchronizationUnavailable(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::SynchronizationUnavailable*& v)
{
    if(any.check_type(CosTransactions::_tc_SynchronizationUnavailable))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::SynchronizationUnavailable* val = new CosTransactions::SynchronizationUnavailable;
            CosTransactions::SynchronizationUnavailable::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::SynchronizationUnavailable*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/TransactionFactory:1.0
//
const char* CosTransactions::TransactionFactory::ids_[] =
{
    "IDL:CosTransactions/TransactionFactory:1.0",
    0
};

void
OBDuplicate(CosTransactions::TransactionFactory_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(CosTransactions::TransactionFactory_ptr p)
{
    if(p)
        p -> _remove_ref();
}

CosTransactions::TransactionFactory_ptr
CosTransactions::TransactionFactory::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        TransactionFactory_ptr v = dynamic_cast<TransactionFactory_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_CosTransactions::TransactionFactory* val = new OBProxy_CosTransactions::TransactionFactory;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

CosTransactions::TransactionFactory_ptr
CosTransactions::TransactionFactory::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        TransactionFactory_ptr v = dynamic_cast<TransactionFactory_ptr>(p);
        if(v)
            return _duplicate(v);

        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

CosTransactions::TransactionFactory_ptr
CosTransactions::TransactionFactory::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        TransactionFactory_ptr v = dynamic_cast<TransactionFactory_ptr>(p);
        if(v)
            return _duplicate(v);

        OBProxy_CosTransactions::TransactionFactory* val = new OBProxy_CosTransactions::TransactionFactory;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

CosTransactions::TransactionFactory_ptr
CosTransactions::TransactionFactory::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
CosTransactions::TransactionFactory::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(CosTransactions::TransactionFactory_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(CosTransactions::TransactionFactory_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    CosTransactions::TransactionFactory_var old = _ob_v;
    CORBA::Object_var p = _ob_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        OBProxy_CosTransactions::TransactionFactory* _ob_obj = new OBProxy_CosTransactions::TransactionFactory;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = CosTransactions::TransactionFactory::_nil();
}

void
operator<<=(CORBA::Any& any, CosTransactions::TransactionFactory_ptr* v)
{
    any.replace(CosTransactions::_tc_TransactionFactory, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, CosTransactions::TransactionFactory_ptr v)
{
    CosTransactions::TransactionFactory_ptr val = CosTransactions::TransactionFactory::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::TransactionFactory_ptr& v)
{
    if(any.check_type(CosTransactions::_tc_TransactionFactory))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<CosTransactions::TransactionFactory_ptr>(val)))
            {
                OBProxy_CosTransactions::TransactionFactory* obj = new OBProxy_CosTransactions::TransactionFactory;
                obj -> _OB_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = CosTransactions::TransactionFactory::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/Control:1.0
//
const char* CosTransactions::Control::ids_[] =
{
    "IDL:CosTransactions/Control:1.0",
    0
};

void
OBDuplicate(CosTransactions::Control_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(CosTransactions::Control_ptr p)
{
    if(p)
        p -> _remove_ref();
}

CosTransactions::Control_ptr
CosTransactions::Control::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Control_ptr v = dynamic_cast<Control_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_CosTransactions::Control* val = new OBProxy_CosTransactions::Control;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

CosTransactions::Control_ptr
CosTransactions::Control::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Control_ptr v = dynamic_cast<Control_ptr>(p);
        if(v)
            return _duplicate(v);

        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

CosTransactions::Control_ptr
CosTransactions::Control::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Control_ptr v = dynamic_cast<Control_ptr>(p);
        if(v)
            return _duplicate(v);

        OBProxy_CosTransactions::Control* val = new OBProxy_CosTransactions::Control;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

CosTransactions::Control_ptr
CosTransactions::Control::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
CosTransactions::Control::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(CosTransactions::Control_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(CosTransactions::Control_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    CosTransactions::Control_var old = _ob_v;
    CORBA::Object_var p = _ob_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        OBProxy_CosTransactions::Control* _ob_obj = new OBProxy_CosTransactions::Control;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = CosTransactions::Control::_nil();
}

void
operator<<=(CORBA::Any& any, CosTransactions::Control_ptr* v)
{
    any.replace(CosTransactions::_tc_Control, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, CosTransactions::Control_ptr v)
{
    CosTransactions::Control_ptr val = CosTransactions::Control::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::Control_ptr& v)
{
    if(any.check_type(CosTransactions::_tc_Control))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<CosTransactions::Control_ptr>(val)))
            {
                OBProxy_CosTransactions::Control* obj = new OBProxy_CosTransactions::Control;
                obj -> _OB_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = CosTransactions::Control::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/Terminator:1.0
//
const char* CosTransactions::Terminator::ids_[] =
{
    "IDL:CosTransactions/Terminator:1.0",
    0
};

void
OBDuplicate(CosTransactions::Terminator_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(CosTransactions::Terminator_ptr p)
{
    if(p)
        p -> _remove_ref();
}

CosTransactions::Terminator_ptr
CosTransactions::Terminator::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Terminator_ptr v = dynamic_cast<Terminator_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_CosTransactions::Terminator* val = new OBProxy_CosTransactions::Terminator;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

CosTransactions::Terminator_ptr
CosTransactions::Terminator::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Terminator_ptr v = dynamic_cast<Terminator_ptr>(p);
        if(v)
            return _duplicate(v);

        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

CosTransactions::Terminator_ptr
CosTransactions::Terminator::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Terminator_ptr v = dynamic_cast<Terminator_ptr>(p);
        if(v)
            return _duplicate(v);

        OBProxy_CosTransactions::Terminator* val = new OBProxy_CosTransactions::Terminator;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

CosTransactions::Terminator_ptr
CosTransactions::Terminator::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
CosTransactions::Terminator::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(CosTransactions::Terminator_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(CosTransactions::Terminator_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    CosTransactions::Terminator_var old = _ob_v;
    CORBA::Object_var p = _ob_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        OBProxy_CosTransactions::Terminator* _ob_obj = new OBProxy_CosTransactions::Terminator;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = CosTransactions::Terminator::_nil();
}

void
operator<<=(CORBA::Any& any, CosTransactions::Terminator_ptr* v)
{
    any.replace(CosTransactions::_tc_Terminator, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, CosTransactions::Terminator_ptr v)
{
    CosTransactions::Terminator_ptr val = CosTransactions::Terminator::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::Terminator_ptr& v)
{
    if(any.check_type(CosTransactions::_tc_Terminator))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<CosTransactions::Terminator_ptr>(val)))
            {
                OBProxy_CosTransactions::Terminator* obj = new OBProxy_CosTransactions::Terminator;
                obj -> _OB_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = CosTransactions::Terminator::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/Coordinator:1.0
//
const char* CosTransactions::Coordinator::ids_[] =
{
    "IDL:CosTransactions/Coordinator:1.0",
    0
};

void
OBDuplicate(CosTransactions::Coordinator_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(CosTransactions::Coordinator_ptr p)
{
    if(p)
        p -> _remove_ref();
}

CosTransactions::Coordinator_ptr
CosTransactions::Coordinator::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Coordinator_ptr v = dynamic_cast<Coordinator_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_CosTransactions::Coordinator* val = new OBProxy_CosTransactions::Coordinator;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

CosTransactions::Coordinator_ptr
CosTransactions::Coordinator::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Coordinator_ptr v = dynamic_cast<Coordinator_ptr>(p);
        if(v)
            return _duplicate(v);

        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

CosTransactions::Coordinator_ptr
CosTransactions::Coordinator::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Coordinator_ptr v = dynamic_cast<Coordinator_ptr>(p);
        if(v)
            return _duplicate(v);

        OBProxy_CosTransactions::Coordinator* val = new OBProxy_CosTransactions::Coordinator;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

CosTransactions::Coordinator_ptr
CosTransactions::Coordinator::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
CosTransactions::Coordinator::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(CosTransactions::Coordinator_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(CosTransactions::Coordinator_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    CosTransactions::Coordinator_var old = _ob_v;
    CORBA::Object_var p = _ob_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        OBProxy_CosTransactions::Coordinator* _ob_obj = new OBProxy_CosTransactions::Coordinator;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = CosTransactions::Coordinator::_nil();
}

void
operator<<=(CORBA::Any& any, CosTransactions::Coordinator_ptr* v)
{
    any.replace(CosTransactions::_tc_Coordinator, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, CosTransactions::Coordinator_ptr v)
{
    CosTransactions::Coordinator_ptr val = CosTransactions::Coordinator::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::Coordinator_ptr& v)
{
    if(any.check_type(CosTransactions::_tc_Coordinator))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<CosTransactions::Coordinator_ptr>(val)))
            {
                OBProxy_CosTransactions::Coordinator* obj = new OBProxy_CosTransactions::Coordinator;
                obj -> _OB_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = CosTransactions::Coordinator::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/Coordinator/RCV:1.0
//
#ifdef OB_CLEAR_MEM
CosTransactions::Coordinator::RCV::RCV()
{
    memset(&rv, 0, sizeof(rv));
}
#endif

CosTransactions::Coordinator::RCV::RCV(const RCV& _ob_a)
    : r(_ob_a.r),
      rc(_ob_a.rc),
      rv(_ob_a.rv)
{
}

CosTransactions::Coordinator::RCV&
CosTransactions::Coordinator::RCV::operator=(const RCV& _ob_a)
{
    if(this != &_ob_a)
    {
        r = _ob_a.r;
        rc = _ob_a.rc;
        rv = _ob_a.rv;
    }
    return *this;
}

void
CosTransactions::Coordinator::RCV::_OB_marshal(OB::OutputStreamImpl* _ob_out) const
{
    OBMarshal(r, _ob_out);
    OBMarshal(rc, _ob_out);
    _ob_out -> write_ulong((CORBA::ULong)rv);
}

void
CosTransactions::Coordinator::RCV::_OB_unmarshal(RCV& _ob_v, OB::InputStreamImpl* _ob_in)
{
    OBUnmarshal(_ob_v.r.inout(), _ob_in);
    OBUnmarshal(_ob_v.rc.inout(), _ob_in);
    _ob_v.rv = (ResourceVote)_ob_in -> read_ulong();
}

void
operator<<=(CORBA::Any& any, CosTransactions::Coordinator::RCV* v)
{
    static const OB::Info< CosTransactions::Coordinator::RCV > info;
    any.replace(CosTransactions::Coordinator::_tc_RCV, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::Coordinator::RCV& v)
{
    any <<= new CosTransactions::Coordinator::RCV(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::Coordinator::RCV*& v)
{
    if(any.check_type(CosTransactions::Coordinator::_tc_RCV))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::Coordinator::RCV* val = new CosTransactions::Coordinator::RCV;
            CosTransactions::Coordinator::RCV::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::Coordinator::RCV*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/Coordinator/RCVs:1.0
//
void
CosTransactions::Coordinator::OBInfo_RCVs::marshal(const void* _ob_v, OB::OutputStreamImpl* _ob_out) const
{
    const ::CosTransactions::Coordinator::RCVs& _ob_seq = *(const ::CosTransactions::Coordinator::RCVs*)_ob_v;
    CORBA::ULong _ob_len0 = _ob_seq.length();
    _ob_out -> write_ulong(_ob_len0);
    ::CosTransactions::Coordinator::RCV const * _ob_buf0 = _ob_seq.get_buffer();
    for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        _ob_buf0[_ob_i0]._OB_marshal(_ob_out);
    }
}

void
CosTransactions::Coordinator::OBInfo_RCVs::unmarshal(void* _ob_v, OB::InputStreamImpl* _ob_in) const
{
    ::CosTransactions::Coordinator::RCVs& _ob_seq = *(::CosTransactions::Coordinator::RCVs*)_ob_v;
    CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
    _ob_seq.length(_ob_len0);
    ::CosTransactions::Coordinator::RCV * _ob_buf0 = _ob_seq.get_buffer();
    for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::CosTransactions::Coordinator::RCV::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
    }
}

void
operator<<=(CORBA::Any& any, CosTransactions::Coordinator::RCVs* v)
{
    static const CosTransactions::Coordinator::OBInfo_RCVs info;
    any.replace(CosTransactions::Coordinator::_tc_RCVs, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const CosTransactions::Coordinator::RCVs& v)
{
    any <<= new CosTransactions::Coordinator::RCVs(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CosTransactions::Coordinator::RCVs*& v)
{
    if(any.check_type(CosTransactions::Coordinator::_tc_RCVs))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            CosTransactions::Coordinator::RCVs* val = new CosTransactions::Coordinator::RCVs;
            CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
            (*val).length(_ob_len0);
            ::CosTransactions::Coordinator::RCV * _ob_buf0 = (*val).get_buffer();
            for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
            {
                ::CosTransactions::Coordinator::RCV::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
            }
            (CORBA::Any&)any <<= val;
        }

        v = (CosTransactions::Coordinator::RCVs*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/RecoveryCoordinator:1.0
//
const char* CosTransactions::RecoveryCoordinator::ids_[] =
{
    "IDL:CosTransactions/RecoveryCoordinator:1.0",
    0
};

void
OBDuplicate(CosTransactions::RecoveryCoordinator_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(CosTransactions::RecoveryCoordinator_ptr p)
{
    if(p)
        p -> _remove_ref();
}

CosTransactions::RecoveryCoordinator_ptr
CosTransactions::RecoveryCoordinator::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        RecoveryCoordinator_ptr v = dynamic_cast<RecoveryCoordinator_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_CosTransactions::RecoveryCoordinator* val = new OBProxy_CosTransactions::RecoveryCoordinator;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

CosTransactions::RecoveryCoordinator_ptr
CosTransactions::RecoveryCoordinator::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        RecoveryCoordinator_ptr v = dynamic_cast<RecoveryCoordinator_ptr>(p);
        if(v)
            return _duplicate(v);

        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

CosTransactions::RecoveryCoordinator_ptr
CosTransactions::RecoveryCoordinator::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        RecoveryCoordinator_ptr v = dynamic_cast<RecoveryCoordinator_ptr>(p);
        if(v)
            return _duplicate(v);

        OBProxy_CosTransactions::RecoveryCoordinator* val = new OBProxy_CosTransactions::RecoveryCoordinator;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

CosTransactions::RecoveryCoordinator_ptr
CosTransactions::RecoveryCoordinator::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
CosTransactions::RecoveryCoordinator::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(CosTransactions::RecoveryCoordinator_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(CosTransactions::RecoveryCoordinator_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    CosTransactions::RecoveryCoordinator_var old = _ob_v;
    CORBA::Object_var p = _ob_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        OBProxy_CosTransactions::RecoveryCoordinator* _ob_obj = new OBProxy_CosTransactions::RecoveryCoordinator;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = CosTransactions::RecoveryCoordinator::_nil();
}

void
operator<<=(CORBA::Any& any, CosTransactions::RecoveryCoordinator_ptr* v)
{
    any.replace(CosTransactions::_tc_RecoveryCoordinator, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, CosTransactions::RecoveryCoordinator_ptr v)
{
    CosTransactions::RecoveryCoordinator_ptr val = CosTransactions::RecoveryCoordinator::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::RecoveryCoordinator_ptr& v)
{
    if(any.check_type(CosTransactions::_tc_RecoveryCoordinator))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<CosTransactions::RecoveryCoordinator_ptr>(val)))
            {
                OBProxy_CosTransactions::RecoveryCoordinator* obj = new OBProxy_CosTransactions::RecoveryCoordinator;
                obj -> _OB_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = CosTransactions::RecoveryCoordinator::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/TransactionalObject:1.0
//
const char* CosTransactions::TransactionalObject::ids_[] =
{
    "IDL:CosTransactions/TransactionalObject:1.0",
    0
};

void
OBDuplicate(CosTransactions::TransactionalObject_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(CosTransactions::TransactionalObject_ptr p)
{
    if(p)
        p -> _remove_ref();
}

CosTransactions::TransactionalObject_ptr
CosTransactions::TransactionalObject::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        TransactionalObject_ptr v = dynamic_cast<TransactionalObject_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_CosTransactions::TransactionalObject* val = new OBProxy_CosTransactions::TransactionalObject;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

CosTransactions::TransactionalObject_ptr
CosTransactions::TransactionalObject::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        TransactionalObject_ptr v = dynamic_cast<TransactionalObject_ptr>(p);
        if(v)
            return _duplicate(v);

        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

CosTransactions::TransactionalObject_ptr
CosTransactions::TransactionalObject::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        TransactionalObject_ptr v = dynamic_cast<TransactionalObject_ptr>(p);
        if(v)
            return _duplicate(v);

        OBProxy_CosTransactions::TransactionalObject* val = new OBProxy_CosTransactions::TransactionalObject;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

CosTransactions::TransactionalObject_ptr
CosTransactions::TransactionalObject::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
CosTransactions::TransactionalObject::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(CosTransactions::TransactionalObject_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(CosTransactions::TransactionalObject_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    CosTransactions::TransactionalObject_var old = _ob_v;
    CORBA::Object_var p = _ob_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        OBProxy_CosTransactions::TransactionalObject* _ob_obj = new OBProxy_CosTransactions::TransactionalObject;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = CosTransactions::TransactionalObject::_nil();
}

void
operator<<=(CORBA::Any& any, CosTransactions::TransactionalObject_ptr* v)
{
    any.replace(CosTransactions::_tc_TransactionalObject, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, CosTransactions::TransactionalObject_ptr v)
{
    CosTransactions::TransactionalObject_ptr val = CosTransactions::TransactionalObject::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CosTransactions::TransactionalObject_ptr& v)
{
    if(any.check_type(CosTransactions::_tc_TransactionalObject))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<CosTransactions::TransactionalObject_ptr>(val)))
            {
                OBProxy_CosTransactions::TransactionalObject* obj = new OBProxy_CosTransactions::TransactionalObject;
                obj -> _OB_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = CosTransactions::TransactionalObject::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:CosTransactions/TransactionFactory:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_CosTransactions::TransactionFactory::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_CosTransactions::TransactionFactory;
}

const char**
OBProxy_CosTransactions::TransactionFactory::_OB_ids() const
{
    return ::CosTransactions::TransactionFactory::ids_;
}

//
// IDL:CosTransactions/TransactionFactory/create:1.0
//
::CosTransactions::Control_ptr
OBProxy_CosTransactions::TransactionFactory::create(CORBA::ULong _ob_a0)
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::TransactionFactory_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::TransactionFactory_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> create(_ob_a0);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/Control:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_CosTransactions::Control::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_CosTransactions::Control;
}

const char**
OBProxy_CosTransactions::Control::_OB_ids() const
{
    return ::CosTransactions::Control::ids_;
}

//
// IDL:CosTransactions/Control/get_terminator:1.0
//
::CosTransactions::Terminator_ptr
OBProxy_CosTransactions::Control::get_terminator()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::Control_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::Control_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> get_terminator();
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/Control/get_coordinator:1.0
//
::CosTransactions::Coordinator_ptr
OBProxy_CosTransactions::Control::get_coordinator()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::Control_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::Control_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> get_coordinator();
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/Control/release:1.0
//
void
OBProxy_CosTransactions::Control::release()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::Control_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::Control_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> release();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/Terminator:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_CosTransactions::Terminator::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_CosTransactions::Terminator;
}

const char**
OBProxy_CosTransactions::Terminator::_OB_ids() const
{
    return ::CosTransactions::Terminator::ids_;
}

//
// IDL:CosTransactions/Terminator/commit:1.0
//
void
OBProxy_CosTransactions::Terminator::commit(CORBA::Boolean _ob_a0)
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::Terminator_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::Terminator_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> commit(_ob_a0);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/Terminator/rollback:1.0
//
void
OBProxy_CosTransactions::Terminator::rollback()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::Terminator_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::Terminator_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> rollback();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/Terminator/release:1.0
//
void
OBProxy_CosTransactions::Terminator::release()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::Terminator_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::Terminator_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> release();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/Coordinator:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_CosTransactions::Coordinator::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_CosTransactions::Coordinator;
}

const char**
OBProxy_CosTransactions::Coordinator::_OB_ids() const
{
    return ::CosTransactions::Coordinator::ids_;
}

//renyi 11 25 : added
void 
CosTransactions::Coordinator::remove(RCVs_ptr RCVs_var_tmp,CORBA::ULong idx)
{
	CORBA::ULong tmp_len = RCVs_var_tmp->length();

	if (tmp_len != 1)
//		for(CORBA::ULong i = idx;i < tmp_len;i++)
//Suliang add.
		for(CORBA::ULong i = idx;i < tmp_len-1;i++)
//Suliang add.
			{
				RCVs_var_tmp[i] = RCVs_var_tmp[i+1];

				
//				CORBA::ULong j = tmp_len-1;
//				RCVs_var_tmp -> length(j);
			}
	else 
	{
		RCVs_var_tmp -> length(0);	
	} //end of if
}

//
// IDL:CosTransactions/Coordinator/get_status:1.0
//
::CosTransactions::Status
OBProxy_CosTransactions::Coordinator::get_status()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::Coordinator_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::Coordinator_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> get_status();
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/is_same_transaction:1.0
//
CORBA::Boolean
OBProxy_CosTransactions::Coordinator::is_same_transaction(::CosTransactions::Coordinator_ptr _ob_a0)
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::Coordinator_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::Coordinator_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> is_same_transaction(_ob_a0);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/register_resource:1.0
//
::CosTransactions::RecoveryCoordinator_ptr
OBProxy_CosTransactions::Coordinator::register_resource(::Resource_ptr _ob_a0)
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::Coordinator_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::Coordinator_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> register_resource(_ob_a0);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/register_synchronization:1.0
//
void
OBProxy_CosTransactions::Coordinator::register_synchronization(::CosTransactions::Synchronization_ptr _ob_a0)
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::Coordinator_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::Coordinator_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> register_synchronization(_ob_a0);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/rollback_only:1.0
//
void
OBProxy_CosTransactions::Coordinator::rollback_only()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::Coordinator_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::Coordinator_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> rollback_only();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/commit:1.0
//
void
OBProxy_CosTransactions::Coordinator::commit(CORBA::Boolean _ob_a0)
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::Coordinator_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::Coordinator_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> commit(_ob_a0);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/rollback:1.0
//
void
OBProxy_CosTransactions::Coordinator::rollback()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::Coordinator_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::Coordinator_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> rollback();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/change_resourcevote:1.0
//
void
OBProxy_CosTransactions::Coordinator::change_resourcevote(::Resource_ptr _ob_a0,
                                                          ::CosTransactions::ResourceVote _ob_a1)
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::Coordinator_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::Coordinator_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> change_resourcevote(_ob_a0, _ob_a1);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/release:1.0
//
void
OBProxy_CosTransactions::Coordinator::release()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::Coordinator_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::Coordinator_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> release();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/RecoveryCoordinator:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_CosTransactions::RecoveryCoordinator::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_CosTransactions::RecoveryCoordinator;
}

const char**
OBProxy_CosTransactions::RecoveryCoordinator::_OB_ids() const
{
    return ::CosTransactions::RecoveryCoordinator::ids_;
}

//
// IDL:CosTransactions/RecoveryCoordinator/replay_completion:1.0
//
::CosTransactions::Status
OBProxy_CosTransactions::RecoveryCoordinator::replay_completion(::Resource_ptr _ob_a0)
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::RecoveryCoordinator_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::RecoveryCoordinator_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> replay_completion(_ob_a0);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/RecoveryCoordinator/release:1.0
//
void
OBProxy_CosTransactions::RecoveryCoordinator::release()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_CosTransactions::RecoveryCoordinator_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_CosTransactions::RecoveryCoordinator_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> release();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:CosTransactions/TransactionalObject:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_CosTransactions::TransactionalObject::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_CosTransactions::TransactionalObject;
}

const char**
OBProxy_CosTransactions::TransactionalObject::_OB_ids() const
{
    return ::CosTransactions::TransactionalObject::ids_;
}

//
// IDL:CosTransactions/TransactionFactory:1.0
//
void
OBDuplicate(OBStubImpl_CosTransactions::TransactionFactory_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_CosTransactions::TransactionFactory_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:CosTransactions/Control:1.0
//
void
OBDuplicate(OBStubImpl_CosTransactions::Control_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_CosTransactions::Control_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:CosTransactions/Terminator:1.0
//
void
OBDuplicate(OBStubImpl_CosTransactions::Terminator_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_CosTransactions::Terminator_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:CosTransactions/Coordinator:1.0
//
void
OBDuplicate(OBStubImpl_CosTransactions::Coordinator_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_CosTransactions::Coordinator_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:CosTransactions/RecoveryCoordinator:1.0
//
void
OBDuplicate(OBStubImpl_CosTransactions::RecoveryCoordinator_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_CosTransactions::RecoveryCoordinator_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:CosTransactions/TransactionalObject:1.0
//
void
OBDuplicate(OBStubImpl_CosTransactions::TransactionalObject_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_CosTransactions::TransactionalObject_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:CosTransactions/TransactionFactory/create:1.0
//
::CosTransactions::Control_ptr
OBMarshalStubImpl_CosTransactions::TransactionFactory::create(CORBA::ULong _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("create", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_ulong(_ob_a0);
            }
            catch(const CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::CosTransactions::Control_var _ob_r;
                try
                {
                    OBUnmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/Control/get_terminator:1.0
//
::CosTransactions::Terminator_ptr
OBMarshalStubImpl_CosTransactions::Control::get_terminator()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("get_terminator", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/Unavailable:1.0") == 0)
                    {
                        ::CosTransactions::Unavailable _ob_except;
                        ::CosTransactions::Unavailable::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::CosTransactions::Terminator_var _ob_r;
                try
                {
                    OBUnmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/Control/get_coordinator:1.0
//
::CosTransactions::Coordinator_ptr
OBMarshalStubImpl_CosTransactions::Control::get_coordinator()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("get_coordinator", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/Unavailable:1.0") == 0)
                    {
                        ::CosTransactions::Unavailable _ob_except;
                        ::CosTransactions::Unavailable::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::CosTransactions::Coordinator_var _ob_r;
                try
                {
                    OBUnmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/Control/release:1.0
//
void
OBMarshalStubImpl_CosTransactions::Control::release()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("release", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/Terminator/commit:1.0
//
void
OBMarshalStubImpl_CosTransactions::Terminator::commit(CORBA::Boolean _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("commit", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_boolean(_ob_a0);
            }
            catch(const CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/HeuristicMixed:1.0") == 0)
                    {
                        ::CosTransactions::HeuristicMixed _ob_except;
                        ::CosTransactions::HeuristicMixed::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/HeuristicHazard:1.0") == 0)
                    {
                        ::CosTransactions::HeuristicHazard _ob_except;
                        ::CosTransactions::HeuristicHazard::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/HeuristicRollback:1.0") == 0)
                    {
                        ::CosTransactions::HeuristicRollback _ob_except;
                        ::CosTransactions::HeuristicRollback::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/HeuristicCommit:1.0") == 0)
                    {
                        ::CosTransactions::HeuristicCommit _ob_except;
                        ::CosTransactions::HeuristicCommit::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/Terminator/rollback:1.0
//
void
OBMarshalStubImpl_CosTransactions::Terminator::rollback()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("rollback", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/Terminator/release:1.0
//
void
OBMarshalStubImpl_CosTransactions::Terminator::release()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("release", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/get_status:1.0
//
::CosTransactions::Status
OBMarshalStubImpl_CosTransactions::Coordinator::get_status()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("get_status", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::CosTransactions::Status _ob_r;
                try
                {
                    _ob_r = (::CosTransactions::Status)_ob_in -> read_ulong();
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/is_same_transaction:1.0
//
CORBA::Boolean
OBMarshalStubImpl_CosTransactions::Coordinator::is_same_transaction(::CosTransactions::Coordinator_ptr _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("is_same_transaction", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                OBMarshal(_ob_a0, _ob_out);
            }
            catch(const CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                CORBA::Boolean _ob_r;
                try
                {
                    _ob_r = _ob_in -> read_boolean();
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/register_resource:1.0
//
::CosTransactions::RecoveryCoordinator_ptr
OBMarshalStubImpl_CosTransactions::Coordinator::register_resource(::Resource_ptr _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("register_resource", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                OBMarshal(_ob_a0, _ob_out);
            }
            catch(const CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/Inactive:1.0") == 0)
                    {
                        ::CosTransactions::Inactive _ob_except;
                        ::CosTransactions::Inactive::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::CosTransactions::RecoveryCoordinator_var _ob_r;
                try
                {
                    OBUnmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/register_synchronization:1.0
//
void
OBMarshalStubImpl_CosTransactions::Coordinator::register_synchronization(::CosTransactions::Synchronization_ptr _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("register_synchronization", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                OBMarshal(_ob_a0, _ob_out);
            }
            catch(const CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/Inactive:1.0") == 0)
                    {
                        ::CosTransactions::Inactive _ob_except;
                        ::CosTransactions::Inactive::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/SynchronizationUnavailable:1.0") == 0)
                    {
                        ::CosTransactions::SynchronizationUnavailable _ob_except;
                        ::CosTransactions::SynchronizationUnavailable::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/rollback_only:1.0
//
void
OBMarshalStubImpl_CosTransactions::Coordinator::rollback_only()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("rollback_only", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/Inactive:1.0") == 0)
                    {
                        ::CosTransactions::Inactive _ob_except;
                        ::CosTransactions::Inactive::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/commit:1.0
//
void
OBMarshalStubImpl_CosTransactions::Coordinator::commit(CORBA::Boolean _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("commit", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_boolean(_ob_a0);
            }
            catch(const CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/rollback:1.0
//
void
OBMarshalStubImpl_CosTransactions::Coordinator::rollback()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("rollback", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/change_resourcevote:1.0
//
void
OBMarshalStubImpl_CosTransactions::Coordinator::change_resourcevote(::Resource_ptr _ob_a0,
                                                                    ::CosTransactions::ResourceVote _ob_a1)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("change_resourcevote", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                OBMarshal(_ob_a0, _ob_out);
                _ob_out -> write_ulong((CORBA::ULong)_ob_a1);
            }
            catch(const CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/Coordinator/release:1.0
//
void
OBMarshalStubImpl_CosTransactions::Coordinator::release()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("release", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/RecoveryCoordinator/replay_completion:1.0
//
::CosTransactions::Status
OBMarshalStubImpl_CosTransactions::RecoveryCoordinator::replay_completion(::Resource_ptr _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("replay_completion", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                OBMarshal(_ob_a0, _ob_out);
            }
            catch(const CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/NotPrepared:1.0") == 0)
                    {
                        ::CosTransactions::NotPrepared _ob_except;
                        ::CosTransactions::NotPrepared::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::CosTransactions::Status _ob_r;
                try
                {
                    _ob_r = (::CosTransactions::Status)_ob_in -> read_ulong();
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:CosTransactions/RecoveryCoordinator/release:1.0
//
void
OBMarshalStubImpl_CosTransactions::RecoveryCoordinator::release()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("release", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}
