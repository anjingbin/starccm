// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2001
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.1.0

#include <OB/CORBAClient.h>
#include <Resource.h>

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4010000L)
#       error ORBacus version mismatch!
#   endif
#endif

::OB::TypeCodeConst _tc_ResourceFactory(
"01497f000e0000003400000001f812001800000049444c3a5265736f75726365466163746f727"
"93a312e3000100000005265736f75726365466163746f727900"
);

::OB::TypeCodeConst _tc_Resource(
"01f812000e0000002900000001af80001100000049444c3a5265736f757263653a312e3000373"
"400090000005265736f7572636500"
);

//
// IDL:ResourceFactory:1.0
//
const char* ResourceFactory::ids_[] =
{
    "IDL:ResourceFactory:1.0",
    0
};

void
OBDuplicate(ResourceFactory_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(ResourceFactory_ptr p)
{
    if(p)
        p -> _remove_ref();
}

ResourceFactory_ptr
ResourceFactory::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        ResourceFactory_ptr v = dynamic_cast<ResourceFactory_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_ResourceFactory* val = new OBProxy_ResourceFactory;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

ResourceFactory_ptr
ResourceFactory::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        ResourceFactory_ptr v = dynamic_cast<ResourceFactory_ptr>(p);
        if(v)
            return _duplicate(v);

        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

ResourceFactory_ptr
ResourceFactory::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        ResourceFactory_ptr v = dynamic_cast<ResourceFactory_ptr>(p);
        if(v)
            return _duplicate(v);

        OBProxy_ResourceFactory* val = new OBProxy_ResourceFactory;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

ResourceFactory_ptr
ResourceFactory::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
ResourceFactory::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(ResourceFactory_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(ResourceFactory_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    ResourceFactory_var old = _ob_v;
    CORBA::Object_var p = _ob_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        OBProxy_ResourceFactory* _ob_obj = new OBProxy_ResourceFactory;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = ResourceFactory::_nil();
}

void
operator<<=(CORBA::Any& any, ResourceFactory_ptr* v)
{
    any.replace(_tc_ResourceFactory, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, ResourceFactory_ptr v)
{
    ResourceFactory_ptr val = ResourceFactory::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, ResourceFactory_ptr& v)
{
    if(any.check_type(_tc_ResourceFactory))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<ResourceFactory_ptr>(val)))
            {
                OBProxy_ResourceFactory* obj = new OBProxy_ResourceFactory;
                obj -> _OB_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = ResourceFactory::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:Resource:1.0
//
const char* Resource::ids_[] =
{
    "IDL:Resource:1.0",
    "IDL:PG_Resource:1.0",
    0
};

void
OBDuplicate(Resource_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(Resource_ptr p)
{
    if(p)
        p -> _remove_ref();
}

Resource_ptr
Resource::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Resource_ptr v = dynamic_cast<Resource_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_Resource* val = new OBProxy_Resource;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Resource_ptr
Resource::_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Resource_ptr v = dynamic_cast<Resource_ptr>(p);
        if(v)
            return _duplicate(v);

        CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Resource_ptr
Resource::_unchecked_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Resource_ptr v = dynamic_cast<Resource_ptr>(p);
        if(v)
            return _duplicate(v);

        OBProxy_Resource* val = new OBProxy_Resource;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

Resource_ptr
Resource::_unchecked_narrow(CORBA::AbstractBase_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Resource::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(Resource_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(Resource_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    Resource_var old = _ob_v;
    CORBA::Object_var p = _ob_in -> read_Object();

    if(!CORBA::is_nil(p))
    {
        OBProxy_Resource* _ob_obj = new OBProxy_Resource;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = Resource::_nil();
}

void
operator<<=(CORBA::Any& any, Resource_ptr* v)
{
    any.replace(_tc_Resource, (CORBA::Object_ptr)*v, true);
}

void
operator<<=(CORBA::Any& any, Resource_ptr v)
{
    Resource_ptr val = Resource::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Resource_ptr& v)
{
    if(any.check_type(_tc_Resource))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.value();

        if(!CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast<Resource_ptr>(val)))
            {
                OBProxy_Resource* obj = new OBProxy_Resource;
                obj -> _OB_copyFrom(val);
                v = obj;
                (CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Resource::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:ResourceFactory:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_ResourceFactory::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_ResourceFactory;
}

const char**
OBProxy_ResourceFactory::_OB_ids() const
{
    return ::ResourceFactory::ids_;
}

//
// IDL:ResourceFactory/create:1.0
//
::Resource_ptr
OBProxy_ResourceFactory::create(CORBA::Short _ob_a0)
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_ResourceFactory_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_ResourceFactory_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> create(_ob_a0);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:Resource:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_Resource::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_Resource;
}

const char**
OBProxy_Resource::_OB_ids() const
{
    return ::Resource::ids_;
}

//
// IDL:Resource/prepare:1.0
//
::CosTransactions::Vote
OBProxy_Resource::prepare()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Resource_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_Resource_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> prepare();
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:Resource/rollback:1.0
//
void
OBProxy_Resource::rollback()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Resource_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_Resource_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> rollback();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:Resource/commit:1.0
//
void
OBProxy_Resource::commit()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Resource_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_Resource_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> commit();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:Resource/commit_one_phase:1.0
//
void
OBProxy_Resource::commit_one_phase()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Resource_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_Resource_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> commit_one_phase();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:Resource/forget:1.0
//
void
OBProxy_Resource::forget()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Resource_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_Resource_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> forget();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:Resource/release:1.0
//
void
OBProxy_Resource::release()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Resource_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_Resource_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> release();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:Resource/BeginTrans:1.0
//
CORBA::Boolean
OBProxy_Resource::BeginTrans()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Resource_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_Resource_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> BeginTrans();
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:Resource/set_recoverycoordinator:1.0
//
void
OBProxy_Resource::set_recoverycoordinator(::CosTransactions::RecoveryCoordinator_ptr _ob_a0)
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Resource_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_Resource_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> set_recoverycoordinator(_ob_a0);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:Resource/heuristic_decision:1.0
//
void
OBProxy_Resource::heuristic_decision()
{
    CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Resource_ptr _ob_stubImpl = dynamic_cast< OBStubImpl_Resource_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> heuristic_decision();
#if defined(__GNUC__) && defined(__OPTIMIZE__) // COMPILERFIX
            volatile int i = 1;
            i++;
#endif
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:ResourceFactory:1.0
//
void
OBDuplicate(OBStubImpl_ResourceFactory_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_ResourceFactory_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:Resource:1.0
//
void
OBDuplicate(OBStubImpl_Resource_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_Resource_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:ResourceFactory/create:1.0
//
::Resource_ptr
OBMarshalStubImpl_ResourceFactory::create(CORBA::Short _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("create", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_short(_ob_a0);
            }
            catch(const CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::Resource_var _ob_r;
                try
                {
                    OBUnmarshal(_ob_r.inout(), _ob_in);
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:Resource/prepare:1.0
//
::CosTransactions::Vote
OBMarshalStubImpl_Resource::prepare()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("prepare", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/HeuristicMixed:1.0") == 0)
                    {
                        ::CosTransactions::HeuristicMixed _ob_except;
                        ::CosTransactions::HeuristicMixed::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/HeuristicHazard:1.0") == 0)
                    {
                        ::CosTransactions::HeuristicHazard _ob_except;
                        ::CosTransactions::HeuristicHazard::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::CosTransactions::Vote _ob_r;
                try
                {
                    _ob_r = (::CosTransactions::Vote)_ob_in -> read_ulong();
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:Resource/rollback:1.0
//
void
OBMarshalStubImpl_Resource::rollback()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("rollback", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/HeuristicCommit:1.0") == 0)
                    {
                        ::CosTransactions::HeuristicCommit _ob_except;
                        ::CosTransactions::HeuristicCommit::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/HeuristicMixed:1.0") == 0)
                    {
                        ::CosTransactions::HeuristicMixed _ob_except;
                        ::CosTransactions::HeuristicMixed::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/HeuristicHazard:1.0") == 0)
                    {
                        ::CosTransactions::HeuristicHazard _ob_except;
                        ::CosTransactions::HeuristicHazard::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:Resource/commit:1.0
//
void
OBMarshalStubImpl_Resource::commit()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("commit", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/NotPrepared:1.0") == 0)
                    {
                        ::CosTransactions::NotPrepared _ob_except;
                        ::CosTransactions::NotPrepared::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/HeuristicRollback:1.0") == 0)
                    {
                        ::CosTransactions::HeuristicRollback _ob_except;
                        ::CosTransactions::HeuristicRollback::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/HeuristicMixed:1.0") == 0)
                    {
                        ::CosTransactions::HeuristicMixed _ob_except;
                        ::CosTransactions::HeuristicMixed::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/HeuristicHazard:1.0") == 0)
                    {
                        ::CosTransactions::HeuristicHazard _ob_except;
                        ::CosTransactions::HeuristicHazard::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:Resource/commit_one_phase:1.0
//
void
OBMarshalStubImpl_Resource::commit_one_phase()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("commit_one_phase", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/HeuristicHazard:1.0") == 0)
                    {
                        ::CosTransactions::HeuristicHazard _ob_except;
                        ::CosTransactions::HeuristicHazard::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:Resource/forget:1.0
//
void
OBMarshalStubImpl_Resource::forget()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("forget", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:Resource/release:1.0
//
void
OBMarshalStubImpl_Resource::release()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("release", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:Resource/BeginTrans:1.0
//
CORBA::Boolean
OBMarshalStubImpl_Resource::BeginTrans()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("BeginTrans", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                CORBA::Boolean _ob_r;
                try
                {
                    _ob_r = _ob_in -> read_boolean();
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:Resource/set_recoverycoordinator:1.0
//
void
OBMarshalStubImpl_Resource::set_recoverycoordinator(::CosTransactions::RecoveryCoordinator_ptr _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("set_recoverycoordinator", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                OBMarshal(_ob_a0, _ob_out);
            }
            catch(const CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:Resource/heuristic_decision:1.0
//
void
OBMarshalStubImpl_Resource::heuristic_decision()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("heuristic_decision", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                try
                {
                    CORBA::String_var _ob_id = _OB_unmarshalExceptionId(_ob_down);
                    if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_REQUIRED:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_REQUIRED _ob_except;
                        ::CosTransactions::TRANSACTION_REQUIRED::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/TRANSACTION_ROLLEDBACK:1.0") == 0)
                    {
                        ::CosTransactions::TRANSACTION_ROLLEDBACK _ob_except;
                        ::CosTransactions::TRANSACTION_ROLLEDBACK::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/INVALID_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::INVALID_TRANSACTION _ob_except;
                        ::CosTransactions::INVALID_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                    else if(strcmp(_ob_id, "IDL:CosTransactions/WRONG_TRANSACTION:1.0") == 0)
                    {
                        ::CosTransactions::WRONG_TRANSACTION _ob_except;
                        ::CosTransactions::WRONG_TRANSACTION::_OB_unmarshal(_ob_except, _ob_in);
                        _OB_setUserException(_ob_down, _ob_except);
                    }
                }
                catch(const CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                _OB_postUnmarshal(_ob_down);
                return;
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}
