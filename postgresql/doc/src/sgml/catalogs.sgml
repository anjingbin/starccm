<!--
 Documentation of the system catalogs, directed toward PostgreSQL developers
 $Header: /home/hjcvs/OB-CCM-1.0/postgresql/doc/src/sgml/catalogs.sgml,v 1.2 2004/07/05 08:55:11 SuLiang Exp $
 -->

<chapter id="catalogs">
 <title>System Catalogs</title>

 <sect1 id="catalogs-overview">
  <title>Overview</title>

  <para>
   The system catalogs are the place where a relational database
   management system stores schema metadata, such as information about
   tables and columns, and internal bookkeeping information.
   <productname>PostgreSQL</productname>'s system catalogs are regular
   tables.  You can drop and recreate the tables, add columns, insert
   and update values, and severely mess up your system that way.
   Normally one should not change the system catalogs by hand, there
   are always SQL commands to do that.  (For example, <command>CREATE
   DATABASE</command> inserts a row into the
   <structname>pg_database</structname> catalog -- and actually
   creates the database on disk.)  There are some exceptions for
   esoteric operations, such as adding index access methods.
  </para>

  <table>
   <title>System Catalogs</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Catalog Name</entry>
      <entry>Purpose</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>pg_aggregate</entry>
      <entry>aggregate functions</entry>
     </row>

     <row>
      <entry>pg_am</entry>
      <entry>index access methods</entry>
     </row>

     <row>
      <entry>pg_amop</entry>
      <entry>access method operators</entry>
     </row>

     <row>
      <entry>pg_amproc</entry>
      <entry>access method support procedures</entry>
     </row>

     <row>
      <entry>pg_attrdef</entry>
      <entry>column default values</entry>
     </row>

     <row>
      <entry>pg_attribute</entry>
      <entry>table columns (<quote>attributes</quote>, <quote>fields</quote>)</entry>
     </row>

     <row>
      <entry>pg_class</entry>
      <entry>tables, indexes, sequences (<quote>relations</quote>)</entry>
     </row>

     <row>
      <entry>pg_database</entry>
      <entry>databases within this database cluster</entry>
     </row>

     <row>
      <entry>pg_description</entry>
      <entry>descriptions or comments on database objects</entry>
     </row>

     <row>
      <entry>pg_group</entry>
      <entry>groups of database users</entry>
     </row>

     <row>
      <entry>pg_index</entry>
      <entry>additional index information</entry>
     </row>

     <row>
      <entry>pg_inherits</entry>
      <entry>table inheritance hierarchy</entry>
     </row>

     <row>
      <entry>pg_language</entry>
      <entry>languages for writing functions</entry>
     </row>

     <row>
      <entry>pg_largeobject</entry>
      <entry>large objects</entry>
     </row>

     <row>
      <entry>pg_listener</entry>
      <entry>asynchronous notification</entry>
     </row>

     <row>
      <entry>pg_opclass</entry>
      <entry>index access method operator classes</entry>
     </row>

     <row>
      <entry>pg_operator</entry>
      <entry>operators</entry>
     </row>

     <row>
      <entry>pg_proc</entry>
      <entry>functions and procedures</entry>
     </row>

     <row>
      <entry>pg_relcheck</entry>
      <entry>check constraints</entry>
     </row>

     <row>
      <entry>pg_rewrite</entry>
      <entry>query rewriter rules</entry>
     </row>

     <row>
      <entry>pg_shadow</entry>
      <entry>database users</entry>
     </row>

     <row>
      <entry>pg_statistic</entry>
      <entry>optimizer statistics</entry>
     </row>

     <row>
      <entry>pg_trigger</entry>
      <entry>triggers</entry>
     </row>

     <row>
      <entry>pg_type</entry>
      <entry>data types</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   More detailed documentation of most catalogs follow below.  The
   catalogs that relate to index access methods are explained in the
   <citetitle>Programmer's Guide</citetitle>.
  </para>

 </sect1>


 <sect1 id="catalog-pg-aggregate">
  <title>pg_aggregate</title>

  <para>
   <structname>pg_aggregate</structname> stores information about
   aggregate functions.  An aggregate function is a function that
   operates on a set of values (typically one column from each row
   that matches a query condition) and returns a single value computed
   from all these values.  Typical aggregate functions are
   <function>sum</function>, <function>count</function>, and
   <function>max</function>.
  </para>

  <table>
   <title>pg_aggregate Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>aggname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the aggregate function</entry>
     </row>
     <row>
      <entry>aggowner</entry>
      <entry><type>int4</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>Owner (creator) of the aggregate function</entry>
     </row>
     <row>
      <entry>aggtransfn</entry>
      <entry><type>regproc</type> (function)</entry>
      <entry>pg_proc.oid</entry>
      <entry>Transition function</entry>
     </row>
     <row>
      <entry>aggfinalfn</entry>
      <entry><type>regproc</type> (function)</entry>
      <entry>pg_proc.oid</entry>
      <entry>Final function</entry>
     </row>
     <row>
      <entry>aggbasetype</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>The input datatype for this aggregate function</entry>
     </row>
     <row>
      <entry>aggtranstype</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>The type of the aggregate function's internal transition (state) data</entry>
     </row>
     <row>
      <entry>aggfinaltype</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>The type of the result</entry>
     </row>
     <row>
      <entry>agginitval</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       The initial value of the transition state.  This is a text
       field containing the initial value in its external string
       representation.  If the field is NULL, the transition state
       value starts out NULL.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   New aggregate functions are registered with the <command>CREATE
   AGGREGATE</command> command.  See the <citetitle>Programmer's
   Guide</citetitle> for more information about writing aggregate
   functions and the meaning of the transition functions, etc.
  </para>

  <para>
   An aggregate function is identified through name
   <emphasis>and</emphasis> argument type.  Hence aggname and aggbasetype
   are the composite primary key.
  </para>

 </sect1>


 <sect1 id="catalog-pg-attrdef">
  <title>pg_attrdef</title>

  <para>
   This catalog stores column default values.  The main information
   about columns is stored in <structname>pg_attribute</structname>
   (see below).  Only columns that explicitly specify a default value
   (when the table is created or the column is added) will have an
   entry here.
  </para>

  <table>
   <title>pg_attrdef Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>adrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The table this column belongs to</entry>
     </row>

     <row>
      <entry>adnum</entry>
      <entry><type>int2</type></entry>
      <entry>pg_attribute.attnum</entry>
      <entry>The number of the column</entry>
     </row>

     <row>
      <entry>adbin</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>An internal representation of the column default value</entry>
     </row>

     <row>
      <entry>adsrc</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>A human-readable representation of the default value</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-attribute">
  <title>pg_attribute</title>

  <para>
   <structname>pg_attribute</structname> stores information about
   table columns.  There will be exactly one
   <structname>pg_attribute</structname> row for every column in every
   table in the database.  (There will also be attribute entries for
   indexes and other objects.  See <structname>pg_class</structname>.)
  </para>

  <para>
   The term attribute is equivalent to column and is used for
   historical reasons.
  </para>

  <table>
   <title>pg_attribute Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>attrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The table this column belongs to</entry>
     </row>

     <row>
      <entry>attname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Column name</entry>
     </row>

     <row>
      <entry>atttypid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>The data type of this column</entry>
     </row>

     <row>
      <entry>attstattarget</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>attstattarget</structfield> controls the level of detail
       of statistics accumulated for this column by
       <command>ANALYZE</command>.
       A zero value indicates that no statistics should be collected.
       The exact meaning of positive values is datatype-dependent.
       For scalar datatypes, <structfield>attstattarget</structfield>
       is both the target number of <quote>most common values</quote>
       to collect, and the target number of histogram bins to create.
      </entry>
     </row>

     <row>
      <entry>attlen</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       This is a copy of the
       <structname>pg_type</structname>.<structfield>typlen</structfield>
       for this column's type.
      </entry>
     </row>

     <row>
      <entry>attnum</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       The number of the column.  Ordinary columns are numbered from 1
       up.  System columns, such as <structfield>oid</structfield>,
       have (arbitrary) negative numbers.
      </entry>
     </row>

     <row>
      <entry>attndims</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Number of dimensions, if the column is an array type; otherwise 0.
       (Presently, the number of dimensions of an array is not enforced,
       so any nonzero value effectively means <quote>it's an array</>.)
      </entry>
     </row>

     <row>
      <entry>attcacheoff</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Always -1 in storage, but when loaded into a tuple descriptor
       in memory this may be updated to cache the offset of the attribute
       within the tuple.
      </entry>
     </row>

     <row>
      <entry>atttypmod</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>atttypmod</structfield> records type-specific data
       supplied at table creation time (for example, the maximum
       length of a <type>varchar</type> column).  It is passed to
       type-specific input and output functions as the third
       argument. The value will generally be -1 for types that do not
       need typmod.
      </entry>
     </row>

     <row>
      <entry>attbyval</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       A copy of
       <structname>pg_type</structname>.<structfield>typbyval</structfield>
       of this column's type
      </entry>
     </row>

     <row>
      <entry>attstorage</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       A copy of
       <structname>pg_type</structname>.<structfield>typstorage</structfield>
       of this column's type
      </entry>
     </row>

     <row>
      <entry>attisset</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If true, this attribute is a set.  In that case, what is really
       stored in the attribute is the OID of a tuple in the
       <structname>pg_proc</structname> catalog.  The
       <structname>pg_proc</structname> tuple contains the query
       string that defines this set - i.e., the query to run to get
       the set.  So the <structfield>atttypid</structfield> (see
       above) refers to the type returned by this query, but the
       actual length of this attribute is the length (size) of an
       <type>oid</type>.  --- At least this is the theory.  All this
       is probably quite broken these days.
      </entry>
     </row>

     <row>
      <entry>attalign</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       A copy of
       <structname>pg_type</structname>.<structfield>typalign</structfield>
       of this column's type
      </entry>
     </row>

     <row>
      <entry>attnotnull</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This represents a NOT NULL constraint.  It is possible to
       change this field to enable or disable the constraint.
      </entry>
     </row>

     <row>
      <entry>atthasdef</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This column has a default value, in which case there will be a
       corresponding entry in the <structname>pg_attrdef</structname>
       catalog that actually defines the value.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-class">
  <title>pg_class</title>

  <para>
   <structname>pg_class</structname> catalogues tables and mostly
   everything else that has columns or is otherwise similar to a
   table.  This includes indexes (but see also
   <structname>pg_index</structname>), sequences, views, and some
   kinds of special relation.  Below, when we mean all of these
   kinds of objects we speak of <quote>relations</quote>.  Not all
   fields are meaningful for all relation types.
  </para>

  <table>
   <title>pg_class Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>relname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the table, index, view, etc.</entry>
     </row>

     <row>
      <entry>reltype</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>
       The OID of the data type that corresponds to this table, if any
       (zero for indexes, which have no pg_type entry)
      </entry>
     </row>

     <row>
      <entry>relowner</entry>
      <entry><type>int4</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>Owner of the relation</entry>
     </row>

     <row>
      <entry>relam</entry>
      <entry><type>oid</type></entry>
      <entry>pg_am.oid</entry>
      <entry>If this is an index, the access method used (btree, hash, etc.)</entry>
     </row>

     <row>
      <entry>relfilenode</entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Name of the on-disk file of this relation</entry>
     </row>

     <row>
      <entry>relpages</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Size of the on-disk representation of this table in pages (size
       <symbol>BLCKSZ</symbol>).
       This is only an estimate used by the planner.
       It is updated by <command>VACUUM</command>,
       <command>ANALYZE</command>, and <command>CREATE INDEX</command>.
      </entry>
     </row>

     <row>
      <entry>reltuples</entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>
       Number of tuples in the table.
       This is only an estimate used by the planner.
       It is updated by <command>VACUUM</command>,
       <command>ANALYZE</command>, and <command>CREATE INDEX</command>.
      </entry>
     </row>

     <row>
      <entry>reltoastrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>
       Oid of the TOAST table associated with this table, 0 if none.
       The TOAST table stores large attributes <quote>out of
       line</quote> in a secondary table.
      </entry>
     </row>

     <row>
      <entry>reltoastidxid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>
       For a TOAST table, the OID of its index.  0 if not a TOAST table.
      </entry>
     </row>

     <row>
      <entry>relhasindex</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if this is a table and it has (or recently had) any indexes.
       This is set by CREATE INDEX, but not cleared immediately by DROP INDEX.
       VACUUM clears relhasindex if it finds the table has no indexes.
      </entry>
     </row>

     <row>
      <entry>relisshared</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if this table is shared across all databases in the
      cluster.  Only certain system catalogs (such as
      <structname>pg_database</structname>) are shared.</entry>
     </row>

     <row>
      <entry>relkind</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       'r' = ordinary table, 'i' = index, 'S' = sequence, 'v' = view,
       's' = special, 't' = secondary TOAST table
      </entry>
     </row>

     <row>
      <entry>relnatts</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Number of user columns in the relation (system columns not counted).
       There must be this many corresponding entries in
       <structname>pg_attribute</structname>.  See also
       <structname>pg_attribute</structname>.<structfield>attnum</structfield>.
      </entry>
     </row>

     <row>
      <entry>relchecks</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Number of check constraints on the table; see
       <structname>pg_relcheck</structname> catalog
      </entry>
     </row>

     <row>
      <entry>reltriggers</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Number of triggers on the table; see
       <structname>pg_trigger</structname> catalog
      </entry>
     </row>

     <row>
      <entry>relukeys</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>unused  (<emphasis>Not</emphasis> the number of unique keys)</entry>
     </row>

     <row>
      <entry>relfkeys</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>unused  (<emphasis>Not</emphasis> the number of foreign keys on the table)</entry>
     </row>

     <row>
      <entry>relrefs</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>unused</entry>
     </row>

     <row>
      <entry>relhasoids</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if we generate an OID for each row of the relation.
      </entry>
     </row>

     <row>
      <entry>relhaspkey</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if the table has (or once had) a primary key.
      </entry>
     </row>

     <row>
      <entry>relhasrules</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Table has rules; see
       <structname>pg_rewrite</structname> catalog
      </entry>
     </row>

     <row>
      <entry>relhassubclass</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>At least one table inherits from this one</entry>
     </row>

     <row>
      <entry>relacl</entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access permissions.  See the descriptions of
       <command>GRANT</command> and <command>REVOKE</command> for
       details.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-database">
  <title>pg_database</title>

  <para>
   The <structname>pg_database</structname> catalog stores information
   about the available databases.  Databases are created with the
   <command>CREATE DATABASE</command> command.  Consult the
   <citetitle>Administrator's Guide</citetitle> for details about the
   meaning of some of the parameters.
  </para>

  <para>
   Unlike most system catalogs, <structname>pg_database</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_database</structname> per cluster, not
   one per database.
  </para>

  <table>
   <title>pg_database Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>datname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Database name</entry>
     </row>

     <row>
      <entry>datdba</entry>
      <entry><type>int4</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>Owner of the database, initially who created it</entry>
     </row>

     <row>
      <entry>encoding</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Character/multibyte encoding for this database</entry>
     </row>

     <row>
      <entry>datistemplate</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If true then this database can be used in the
       <quote>TEMPLATE</quote> clause of <command>CREATE
       DATABASE</command> to create the new database as a clone of
       this one.
      </entry>
     </row>

     <row>
      <entry>datallowconn</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If false then no one can connect to this database.  This is
       used to protect the template0 database from being altered.
      </entry>
     </row>

     <row>
      <entry>datlastsysoid</entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>
       Last system OID in the database; useful
       particularly to <application>pg_dump</application>
      </entry>
     </row>

     <row>
      <entry>datvacuumxid</entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       All tuples inserted or deleted by transaction IDs before this one
       have been marked as known committed or known aborted in this database.
       This is used to determine when commit-log space can be recycled.
      </entry>
     </row>

     <row>
      <entry>datfrozenxid</entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       All tuples inserted by transaction IDs before this one have been
       relabeled with a permanent (<quote>frozen</>) transaction ID in this
       database.  This is useful to check whether a database must be vacuumed
       soon to avoid transaction ID wraparound problems.
      </entry>
     </row>

     <row>
      <entry>datpath</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       If the database is stored at an alternative location then this
       records the location.  It's either an environment variable name
       or an absolute path, depending how it was entered.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-description">
  <title>pg_description</title>

  <para>
   The pg_description table can store an optional description or
   comment for each database object.  Descriptions can be manipulated
   with the <command>COMMENT</command> command.  Client applications
   can view the descriptions by joining with this table.  Many builtin
   system objects have comments associated with them that are shown by
   <application>psql</application>'s <literal>\d</literal> commands.
  </para>

  <table>
   <title>pg_description Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>objoid</entry>
      <entry><type>oid</type></entry>
      <entry>any oid attribute</entry>
      <entry>The oid of the object this description pertains to</entry>
     </row>

     <row>
      <entry>classoid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The oid of the system catalog this object appears in</entry>
     </row>

     <row>
      <entry>objsubid</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>For a comment on a table attribute, this is the attribute's
       column number (the objoid and classoid refer to the table itself).
       For all other object types, this field is presently zero.
      </entry>
     </row>

     <row>
      <entry>description</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Arbitrary text that serves as the description of this object.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-group">
  <title>pg_group</title>

  <para>
   This catalog defines groups and stores what users belong to what
   groups.  Groups are created with the <command>CREATE
   GROUP</command> command.  Consult the <citetitle>Administrator's
   Guide</citetitle> for information about user permission management.
  </para>

  <para>
   Because user and group identities are cluster-wide,
   <structname>pg_group</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_group</structname> per cluster, not
   one per database.
  </para>

  <table>
   <title>pg_group Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>groname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the group</entry>
     </row>

     <row>
      <entry>grosysid</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>An arbitrary number to identify this group</entry>
     </row>

     <row>
      <entry>grolist</entry>
      <entry><type>int4[]</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>An array containing the ids of the users in this group</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-index">
  <title>pg_index</title>

  <para>
   <structname>pg_index</structname> contains part of the information
   about indexes.  The rest is mostly in
   <structname>pg_class</structname>.
  </para>

  <table>
   <title>pg_index Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>indexrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The oid of the pg_class entry for this index</entry>
     </row>

     <row>
      <entry>indrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The oid of the pg_class entry for the table this index is for</entry>
     </row>

     <row>
      <entry>indproc</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>The registered procedure if this is a functional index</entry>
     </row>

     <row>
      <entry>indkey</entry>
      <entry><type>int2vector</type></entry>
      <entry>pg_attribute.attnum</entry>
      <entry>
       This is a vector (array) of up to
       <symbol>INDEX_MAX_KEYS</symbol> values that indicate which
       table columns this index pertains to.  For example a value of
       <literal>1 3</literal> would mean that the first and the third
       column make up the index key.
      </entry>
     </row>

     <row>
      <entry>indclass</entry>
      <entry><type>oidvector</type></entry>
      <entry>pg_opclass.oid</entry>
      <entry>
       For each column in the index key this contains a reference to
       the <quote>operator class</quote> to use.  See
       <structname>pg_opclass</structname> for details.
      </entry>
     </row>

     <row>
      <entry>indisclustered</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>unused</entry>
     </row>

     <row>
      <entry>indisunique</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, this is a unique index.</entry>
     </row>

     <row>
      <entry>indisprimary</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, this index represents the primary key of the table.
      (indisunique should always be true when this is true.)</entry>
     </row>

     <row>
      <entry>indreference</entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>unused</entry>
     </row>

     <row>
      <entry>indpred</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Expression tree (in the form of a nodeToString representation)
      for partial index predicate</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-inherits">
  <title>pg_inherits</title>

  <para>
   This catalog records information about table inheritance hierarchies.
  </para>

  <table>
   <title>pg_inherits Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>inhrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>
       This is the reference to the subtable, that is, it records the
       fact that the identified table is inherited from some other
       table.
      </entry>
     </row>

     <row>
      <entry>inhparent</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>
       This is the reference to the parent table, which the table
       referenced by <structfield>inhrelid</structfield> inherited
       from.
      </entry>
     </row>

     <row>
      <entry>inhseqno</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       If there is more than one parent for a subtable (multiple
       inheritance), this number tells the order in which the
       inherited columns are to be arranged.  The count starts at 1.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-language">
  <title>pg_language</title>

  <para>
   <structname>pg_language</structname> registers call interfaces or
   languages in which you can write functions or stored procedures.
   See under <command>CREATE LANGUAGE</command> and in the
   <citetitle>Programmer's Guide</citetitle> for more information
   about language handlers.
  </para>

  <table>
   <title>pg_language Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>lanname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the language (to be specified when creating a function)</entry>
     </row>

     <row>
      <entry>lanispl</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This is false for internal languages (such as SQL) and true for
       dynamically loaded language handler modules.  It essentially
       means that, if it is true, the language may be dropped.
      </entry>
     </row>

     <row>
      <entry>lanpltrusted</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This is a trusted language.  See under <command>CREATE
       LANGUAGE</command> what this means.  If this is an internal
       language (<structfield>lanispl</structfield> is false) then
       this field is meaningless.
      </entry>
     </row>

     <row>
      <entry>lanplcallfoid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>
       For non-internal languages this references the language
       handler, which is a special function that is responsible for
       executing all functions that are written in the particular
       language.
      </entry>
     </row>

     <row>
      <entry>lancompiler</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>not currently used</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-largeobject">
  <title>pg_largeobject</title>

  <para>
   <structname>pg_largeobject</structname> holds the data making up
   <quote>large objects</quote>.  A large object is identified by an
   OID assigned when it is created.  Each large object is broken into
   segments or <quote>pages</> small enough to be conveniently stored as rows
   in <structname>pg_largeobject</structname>.
   The amount of data per page is defined to be LOBLKSIZE (which is currently
   BLCKSZ/4, or typically 2Kbytes).
  </para>

  <table>
   <title>pg_largeobject Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>loid</entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Identifier of the large object that includes this page</entry>
     </row>

     <row>
      <entry>pageno</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Page number of this page within its large object
      (counting from zero)</entry>
     </row>

     <row>
      <entry>data</entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>
       Actual data stored in the large object.
       This will never be more than LOBLKSIZE bytes, and may be less.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Each row of <structname>pg_largeobject</structname> holds data
   for one page of a large object, beginning at
   byte offset (pageno * LOBLKSIZE) within the object.  The implementation
   allows sparse storage: pages may be missing, and may be shorter than
   LOBLKSIZE bytes even if they are not the last page of the object.
   Missing regions within a large object read as zeroes.
  </para>

 </sect1>


 <sect1 id="catalog-pg-listener">
  <title>pg_listener</title>

  <para>
   <structname>pg_listener</structname> supports the <command>LISTEN</>
   and <command>NOTIFY</> commands.  A listener creates an entry in
   <structname>pg_listener</structname> for each notification name
   it is listening for.  A notifier scans <structname>pg_listener</structname>
   and updates each matching entry to show that a notification has occurred.
   The notifier also sends a signal (using the PID recorded in the table)
   to awaken the listener from sleep.
  </para>

  <table>
   <title>pg_listener Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>relname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Notify condition name.  (The name need not match any actual
      relation in the database; the term <quote>relname</> is historical.)
      </entry>
     </row>

     <row>
      <entry>listenerpid</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>PID of the backend process that created this entry.</entry>
     </row>

     <row>
      <entry>notification</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Zero if no event is pending for this listener.  If an event is
       pending, the PID of the backend that sent the notification.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-operator">
  <title>pg_operator</title>

  <para>
   See <command>CREATE OPERATOR</command> and the
   <citetitle>Programmer's Guide</citetitle> for details on these
   operator parameters.
  </para>

  <table>
   <title>pg_operator Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>oprname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the operator</entry>
     </row>

     <row>
      <entry>oprowner</entry>
      <entry><type>int4</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>Owner (creator) of the operator</entry>
     </row>

     <row>
      <entry>oprprec</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>unused</entry>
     </row>

     <row>
      <entry>oprkind</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       'b' = infix (<quote>both</quote>), 'l' = prefix
       (<quote>left</quote>), 'r' = postfix (<quote>right</quote>)
      </entry>
     </row>

     <row>
      <entry>oprisleft</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>unused</entry>
     </row>

     <row>
      <entry>oprcanhash</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>This operator supports hash joins.</entry>
     </row>

     <row>
      <entry>oprleft</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>Type of the left operand</entry>
     </row>

     <row>
      <entry>oprright</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>Type of the right operand</entry>
     </row>

     <row>
      <entry>oprresult</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>Type of the result</entry>
     </row>

     <row>
      <entry>oprcom</entry>
      <entry><type>oid</type></entry>
      <entry>pg_operator.oid</entry>
      <entry>Commutator of this operator, if any</entry>
     </row>

     <row>
      <entry>oprnegate</entry>
      <entry><type>oid</type></entry>
      <entry>pg_operator.oid</entry>
      <entry>Negator of this operator, if any</entry>
     </row>

     <row>
      <entry>oprlsortop</entry>
      <entry><type>oid</type></entry>
      <entry>pg_operator.oid</entry>
      <entry>
       If this operator supports merge joins, the operator that sorts
       the type of the left-hand operand
      </entry>
     </row>

     <row>
      <entry>oprrsortop</entry>
      <entry><type>oid</type></entry>
      <entry>pg_operator.oid</entry>
      <entry>
       If this operator supports merge joins, the operator that sorts
       the type of the right-hand operand
      </entry>
     </row>

     <row>
      <entry>oprcode</entry>
      <entry><type>regproc</type></entry>
      <entry></entry>
      <entry>Function that implements this operator</entry>
     </row>

     <row>
      <entry>oprrest</entry>
      <entry><type>regproc</type></entry>
      <entry></entry>
      <entry>Restriction selectivity estimation function for this operator</entry>
     </row>

     <row>
      <entry>oprjoin</entry>
      <entry><type>regproc</type></entry>
      <entry></entry>
      <entry>Join selectivity estimation function for this operator</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-proc">
  <title>pg_proc</title>

  <para>
   This catalog stores information about functions (or procedures).
   The description of <command>CREATE FUNCTION</command> and the
   <citetitle>Programmer's Guide</citetitle> contain more information
   about the meaning of some fields.
  </para>

  <table>
   <title>pg_proc Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>proname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the function</entry>
     </row>

     <row>
      <entry>proowner</entry>
      <entry><type>int4</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>Owner (creator) of the function</entry>
     </row>

     <row>
      <entry>prolang</entry>
      <entry><type>oid</type></entry>
      <entry>pg_language.oid</entry>
      <entry>Implementation language or call interface of this function</entry>
     </row>

     <row>
      <entry>proisinh</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>unused</entry>
     </row>

     <row>
      <entry>proistrusted</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>not functional</entry>
     </row>

     <row>
      <entry>proiscachable</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Function returns same result for same input values</entry>
     </row>

     <row>
      <entry>proisstrict</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Function returns null if any call argument is null.  In that
       case the function won't actually be called at all.  Functions
       that are not <quote>strict</quote> must be prepared to handle
       null inputs.
      </entry>
     </row>

     <row>
      <entry>pronargs</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of arguments</entry>
     </row>

     <row>
      <entry>proretset</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Function returns a set (ie, multiple values of the specified
      datatype)</entry>
     </row>

     <row>
      <entry>prorettype</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>Data type of the return value (0 if the function does not return a value)</entry>
     </row>

     <row>
      <entry>proargtypes</entry>
      <entry><type>oidvector</type></entry>
      <entry>pg_type.oid</entry>
      <entry>A vector with the data types of the function arguments</entry>
     </row>

     <row>
      <entry>probyte_pct</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>dead code</entry>
     </row>

     <row>
      <entry>properbyte_cpu</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>dead code</entry>
     </row>

     <row>
      <entry>propercall_cpu</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>dead code</entry>
     </row>

     <row>
      <entry>prooutin_ratio</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>dead code</entry>
     </row>

     <row>
      <entry>prosrc</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       This tells the function handler how to invoke the function.  It
       might be the actual source code of the function for interpreted
       languages, a link symbol, a file name, or just about anything
       else, depending on the implementation language/call convention.
      </entry>
     </row>

     <row>
      <entry>probin</entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>Additional information about how to invoke the function.
      Again, the interpretation is language-specific.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
  Currently, prosrc contains the function's C-language name (link symbol)
  for compiled functions, both built-in and dynamically loaded.  For all
  other language types, prosrc contains the function's source text.
  </para>

  <para>
  Currently, probin is unused except for dynamically-loaded C functions,
  for which it gives the name of the shared library file containing the
  function.
  </para>

 </sect1>


 <sect1 id="catalog-pg-relcheck">
  <title>pg_relcheck</title>

  <para>
   This system catalog stores CHECK constraints on tables.  (Column
   constraints are not treated specially.  Every column constraint is
   equivalent to some table constraint.)  See under <command>CREATE
   TABLE</command> for more information.
  </para>

  <table>
   <title>pg_relcheck Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>rcrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The table this check constraint is on</entry>
     </row>

     <row>
      <entry>rcname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Constraint name</entry>
     </row>

     <row>
      <entry>rcbin</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>An internal representation of the constraint expression</entry>
     </row>

     <row>
      <entry>rcsrc</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>A human-readable representation of the constraint expression</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <structname>pg_class</structname>.<structfield>relchecks</structfield>
    needs to match up with the entries in this table.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-rewrite">
  <title>pg_rewrite</title>

  <para>
   This system catalog stores rewrite rules for tables and views.
  </para>

  <table>
   <title>pg_rewrite Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>rulename</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Rule name</entry>
     </row>

     <row>
      <entry>ev_type</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Event type that the rule is for: '1' = SELECT,
      '2' = UPDATE, '3' = INSERT, '4' = DELETE</entry>
     </row>

     <row>
      <entry>ev_class</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The table this rule is for</entry>
     </row>

     <row>
      <entry>ev_attr</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>The column this rule is for (currently, always zero to
      indicate the whole table)</entry>
     </row>

     <row>
      <entry>is_instead</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if the rule is an INSTEAD rule</entry>
     </row>

     <row>
      <entry>ev_qual</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Expression tree (in the form of a nodeToString representation)
      for the rule's qualifying condition</entry>
     </row>

     <row>
      <entry>ev_action</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Query tree (in the form of a nodeToString representation)
      for the rule's action</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <structname>pg_class</structname>.<structfield>relhasrules</structfield>
    must be true if a table has any rules in this catalog.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-shadow">
  <title>pg_shadow</title>

  <para>
   <structname>pg_shadow</structname> contains information about
   database users.  The name stems from the fact that this table
   should not be readable by the public since it contains passwords.
   <structname>pg_user</structname> is a publicly readable view on
   <structname>pg_shadow</structname> that blanks out the password field.
  </para>

  <para>
   The <citetitle>Administrator's Guide</citetitle> contains detailed
   information about user and permission management.
  </para>

  <para>
   Because user identities are cluster-wide,
   <structname>pg_shadow</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_shadow</structname> per cluster, not
   one per database.
  </para>

  <table>
   <title>pg_shadow Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>usename</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>User name</entry>
     </row>

     <row>
      <entry>usesysid</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>User id (arbitrary number used to reference this user)</entry>
     </row>

     <row>
      <entry>usecreatedb</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>User may create databases</entry>
     </row>

     <row>
      <entry>usetrace</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>not used</entry>
     </row>

     <row>
      <entry>usesuper</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>User is a superuser</entry>
     </row>

     <row>
      <entry>usecatupd</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       User may update system catalogs.  (Even a superuser may not do
       this unless this attribute is true.)
      </entry>
     </row>

     <row>
      <entry>passwd</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Password</entry>
     </row>

     <row>
      <entry>valuntil</entry>
      <entry><type>abstime</type></entry>
      <entry></entry>
      <entry>Account expiry time (only used for password authentication)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-statistic">
  <title>pg_statistic</title>

  <para>
   <structname>pg_statistic</structname> stores statistical data about
   the contents of the database.  Entries are created by
   <command>ANALYZE</command> and subsequently used by the query planner.
   There is one entry for each table column that has been analyzed.
   Note that all the statistical data is inherently approximate,
   even assuming that it is up-to-date.
  </para>

  <para>
   Since different kinds of statistics may be appropriate for different
   kinds of data, <structname>pg_statistic</structname> is designed not
   to assume very much about what sort of statistics it stores.  Only
   extremely general statistics (such as NULL-ness) are given dedicated
   columns in <structname>pg_statistic</structname>.  Everything else
   is stored in <quote>slots</quote>, which are groups of associated columns whose
   content is identified by a code number in one of the slot's columns.
   For more information see
   <filename>src/include/catalog/pg_statistic.h</filename>.
  </para>

  <para>
   <structname>pg_statistic</structname> should not be readable by the
   public, since even statistical information about a table's contents
   may be considered sensitive.  (Example: minimum and maximum values
   of a salary column might be quite interesting.)
   <structname>pg_stats</structname> is a publicly readable view on
   <structname>pg_statistic</structname> that only exposes information
   about those tables that are readable by the current user.
   <structname>pg_stats</structname> is also designed to present the
   information in a more readable format than the underlying
   <structname>pg_statistic</structname> table --- at the cost that
   its schema must be extended whenever new slot types are added.
  </para>

  <table>
   <title>pg_statistic Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>starelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The table that the described column belongs to</entry>
     </row>

     <row>
      <entry>staattnum</entry>
      <entry><type>int2</type></entry>
      <entry>pg_attribute.attnum</entry>
      <entry>The number of the described column</entry>
     </row>

     <row>
      <entry>stanullfrac</entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>The fraction of the column's entries that are NULL</entry>
     </row>

     <row>
      <entry>stawidth</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>The average stored width, in bytes, of non-NULL entries</entry>
     </row>

     <row>
      <entry>stadistinct</entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>The number of distinct non-NULL data values in the column.
      A value greater than zero is the actual number of distinct values.
      A value less than zero is the negative of a fraction of the number
      of rows in the table (for example, a column in which values appear about
      twice on the average could be represented by stadistinct = -0.5).
      A zero value means the number of distinct values is unknown.
      </entry>
     </row>

     <row>
      <entry>stakindN</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>A code number indicating the kind of statistics stored in the Nth
      <quote>slot</quote> of the <structname>pg_statistic</structname> row.
      </entry>
     </row>

     <row>
      <entry>staopN</entry>
      <entry><type>oid</type></entry>
      <entry>pg_operator.oid</entry>
      <entry>An operator used to derive the statistics stored in the
      Nth <quote>slot</quote>.  For example, a histogram slot would show the <literal>&lt;</literal>
      operator that defines the sort order of the data.
      </entry>
     </row>

     <row>
      <entry>stanumbersN</entry>
      <entry><type>float4[]</type></entry>
      <entry></entry>
      <entry>Numerical statistics of the appropriate kind for the Nth
      <quote>slot</quote>, or NULL if the slot kind does not involve numerical values.
      </entry>
     </row>

     <row>
      <entry>stavaluesN</entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Column data values of the appropriate kind for the Nth
      <quote>slot</quote>, or NULL if the slot kind does not store any data values.
      For datatype independence, all column data values are converted
      to external textual form and stored as TEXT datums.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-trigger">
  <title>pg_trigger</title>

  <para>
   This system catalog stores triggers on tables.  See under
   <command>CREATE TRIGGER</command> for more information.
  </para>

  <table>
   <title>pg_trigger Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>tgrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The table this trigger is on</entry>
     </row>

     <row>
      <entry>tgname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Trigger name (need not be unique)</entry>
     </row>

     <row>
      <entry>tgfoid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>The function to be called</entry>
     </row>

     <row>
      <entry>tgtype</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Bitmask identifying trigger conditions</entry>
     </row>

     <row>
      <entry>tgenabled</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if trigger is enabled (not presently checked everywhere
      it should be, so disabling a trigger by setting this false does not
      work reliably)</entry>
     </row>

     <row>
      <entry>tgisconstraint</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if trigger is a RI constraint</entry>
     </row>

     <row>
      <entry>tgconstrname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>RI constraint name</entry>
     </row>

     <row>
      <entry>tgconstrrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The table referenced by an RI constraint</entry>
     </row>

     <row>
      <entry>tgdeferrable</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if deferrable</entry>
     </row>

     <row>
      <entry>tginitdeferred</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if initially deferred</entry>
     </row>

     <row>
      <entry>tgnargs</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of argument strings passed to trigger function</entry>
     </row>

     <row>
      <entry>tgattr</entry>
      <entry><type>int2vector</type></entry>
      <entry></entry>
      <entry>Currently unused</entry>
     </row>

     <row>
      <entry>tgargs</entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>Argument strings to pass to trigger, each null-terminated</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <structname>pg_class</structname>.<structfield>reltriggers</structfield>
    needs to match up with the entries in this table.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-type">
  <title>pg_type</title>

  <para>
   This catalog stores information about datatypes.  Scalar types
   (<quote>base types</>) are created with <command>CREATE TYPE</command>.
   A complex type is also created for each table in the database, to
   represent the row structure of the table.
  </para>

  <table>
   <title>pg_type Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>typname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Data type name</entry>
     </row>

     <row>
      <entry>typowner</entry>
      <entry><type>int4</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>Owner (creator) of the type</entry>
     </row>

     <row>
      <entry>typlen</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Length of the storage representation of the type, -1 if variable length</entry>
     </row>

     <row>
      <entry>typprtlen</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>unused</entry>
     </row>

     <row>
      <entry>typbyval</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <structfield>typbyval</structfield> determines whether internal
       routines pass a value of this type by value or by reference.
       Only <type>char</type>, <type>short</type>, and
       <type>int</type> equivalent items can be passed by value, so if
       the type is not 1, 2, or 4 bytes long,
       <productname>PostgreSQL</> does not have
       the option of passing by value and so
       <structfield>typbyval</structfield> had better be false.
       Variable-length types are always passed by reference. Note that
       <structfield>typbyval</structfield> can be false even if the
       length would allow pass-by-value; this is currently true for
       type <type>float4</type>, for example.
      </entry>
     </row>

     <row>
      <entry>typtype</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>typtype</structfield> is <literal>b</literal> for
       a base type and <literal>c</literal> for a complex type (i.e.,
       a table's row type).  If <structfield>typtype</structfield> is
       <literal>c</literal>, <structfield>typrelid</structfield> is
       the OID of the type's entry in
       <structname>pg_class</structname>.
      </entry>
     </row>

     <row>
      <entry>typisdefined</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if the type is defined, false if this is a placeholder
      entry for a not-yet-defined type.  When typisdefined is false,
      nothing except the type name and OID can be relied on.
      </entry>
     </row>

     <row>
      <entry>typdelim</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Character that separates two values of this type when parsing
      array input.  Note that the delimiter is associated with the array
      element datatype, not the array datatype.</entry>
     </row>

     <row>
      <entry>typrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>
       If this is a complex type (see
       <structfield>typtype</structfield>), then this field points to
       the <structfield>pg_class</structfield> entry that defines the
       corresponding table. A table could theoretically be used as a
       composite data type, but this is not fully functional.
      </entry>
     </row>

     <row>
      <entry>typelem</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>
       If <structfield>typelem</structfield> is not 0 then it
       identifies another row in <structname>pg_type</structname>.
       The current type can then be subscripted like an array yielding
       values of type <structfield>typelem</structfield>.  A
       <quote>true</quote> array type is variable length
       (<structfield>typlen</structfield> = -1),
       but some fixed-length (<structfield>typlen</structfield> &gt; 0) types
       also have nonzero <structfield>typelem</structfield>, for example
       <type>name</type> and <type>oidvector</type>.
       If a fixed-length type has a <structfield>typelem</structfield> then
       its internal representation must be N values of the
       <structfield>typelem</structfield> datatype with no other data.
       Variable-length array types have a header defined by the array
       subroutines.
      </entry>
     </row>

     <row>
      <entry>typinput</entry>
      <entry><type>regproc</type></entry>
      <entry></entry>
      <entry>Input function</entry>
     </row>

     <row>
      <entry>typoutput</entry>
      <entry><type>regproc</type></entry>
      <entry></entry>
      <entry>Output function</entry>
     </row>

     <row>
      <entry>typreceive</entry>
      <entry><type>regproc</type></entry>
      <entry></entry>
      <entry>unused</entry>
     </row>

     <row>
      <entry>typsend</entry>
      <entry><type>regproc</type></entry>
      <entry></entry>
      <entry>unused</entry>
     </row>

     <row>
      <entry>typalign</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>

       <structfield>typalign</structfield> is the alignment required
       when storing a value of this type.  It applies to storage on
       disk as well as most representations of the value inside
       <productname>PostgreSQL</>.
	When multiple values are stored consecutively, such
       as in the representation of a complete row on disk, padding is
       inserted before a datum of this type so that it begins on the
       specified boundary.  The alignment reference is the beginning
       of the first datum in the sequence.
      </para><para>
       Possible values are:
       <itemizedlist>
        <listitem>
         <para>'c' = CHAR alignment, i.e., no alignment needed.</para>
        </listitem>
        <listitem>
         <para>'s' = SHORT alignment (2 bytes on most machines).</para>
        </listitem>
        <listitem>
         <para>'i' = INT alignment (4 bytes on most machines).</para>
        </listitem>
        <listitem>
         <para>'d' = DOUBLE alignment (8 bytes on many machines, but by no means all).</para>
        </listitem>
       </itemizedlist>
      </para><note>
       <para>
        For types used in system tables, it is critical that the size
        and alignment defined in <structname>pg_type</structname>
        agree with the way that the compiler will lay out the field in
        a struct representing a table row.
       </para>
      </note></entry>
     </row>

     <row>
      <entry>typstorage</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typstorage</structfield> tells for variable-length
       types (those with <structfield>typlen</structfield> = -1) if
       the type is prepared for toasting and what the default strategy
       for attributes of this type should be.
       Possible values are
       <itemizedlist>
        <listitem>
         <para>'p': Value must always be stored plain.</para>
        </listitem>
        <listitem>
         <para>
          'e': Value can be stored in a <quote>secondary</quote>
          relation (if relation has one, see
          <structname>pg_class</structname>.<structfield>reltoastrelid</structfield>).
         </para>
        </listitem>
        <listitem>
         <para>'m': Value can be stored compressed inline.</para>
        </listitem>
        <listitem>
         <para>'x': Value can be stored compressed inline or in <quote>secondary</quote>.</para>
        </listitem>
       </itemizedlist>
       Note that 'm' fields can also be moved out to secondary
       storage, but only as a last resort ('e' and 'x' fields are
       moved first).
      </para></entry>
     </row>

     <row>
      <entry>typdefault</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typdefault</structfield> is NULL for types without a
       default value.  If it's not NULL, it contains the external string
       representation of the type's default value.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-tabs-mode:nil
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/share/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
