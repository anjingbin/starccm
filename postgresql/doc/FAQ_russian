
               Ответы на часто задаваемые вопросы по PostgreSQL
                                       
   Дата последнего обновления: Четверг 18 Февраля 17:56:04 EST 2002
   
   Английский вариант сопровождает: Брюс Момьян (Bruce Momjian)
   (pgman@candle.pha.pa.us)
   
   Перевел на русский: Виктор Вислобоков (victor_v@permonline.ru)
   
   Самую свежую английскую версию документа можно найти на
   http://www.PostgreSQL.org/docs/faq-english.html.
   
   Ответы на вопросы специфичные для конкретных платформ можно найти на
   http://www.PostgreSQL.org/users-lounge/docs/faq.html.
     _________________________________________________________________
   
                               Общие вопросы
                                      
   1.1) Что такое PostgreSQL? Как произносится это название?
   1.2) Каковы авторские права на PostgreSQL?
   1.3) На каких Unix платформах работает PostgreSQL?
   1.4) Существуют ли версии портированные не на Unix системы?
   1.5) Где можно взять PostgreSQL?
   1.6) Где получить поддержку?
   1.7) Какая последняя версия?
   1.8) Какая документация имеется в наличии?
   1.9) Как найти информацию об известных ошибках или отсутствующих
   возможностях?
   1.10) Как научиться SQL?
   1.11) Решена ли в PostgreSQL проблема 2000-го года (Y2K)?
   1.12) Как присоединится к команде разработчиков?
   1.13) Как отравить сообщение об ошибке?
   1.14) Как сравнивать PostgreSQL с другими СУБД?
   1.15) Как оказать финансовую помощь PostgreSQL?
   
                 Вопросы пользователей по клиентской части
                                      
   2.1) Существуют ли ODBC драйвера для PostgreSQL?
   2.2) Какие инструменты существуют для использования PostgreSQL через
   Web?
   2.3) Есть ли у PostgreSQL графический интерфейс пользователя?
   Генератор отчетов? Встроенный интерфейс для языка запросов?
   2.4) Какие языки могут взаимодействовать с PostgreSQL?
   
                         Вопросы администрирования
                                      
   3.1) Как мне установить PostgreSQL в место отличное от
   /usr/local/pgsql?
   3.2) Когда я запускаю postmaster, я получаю сообщение Bad System Call
   или сообщение core dumped. Почему?
   3.3) Когда я пытаюсь запустить postmaster, я получаю ошибки
   IpcMemoryCreate. Почему?
   3.4) Когда я пытаюсь запустить postmaster, я получаю ошибки
   IpcSemaphoreCreate. Почему?
   3.5) Как мне управлять соединениями с других компьютеров?
   3.6) Какие настройки мне нужно сделать для улучшения
   производительности?
   3.7) Какие возможности для отладки есть в наличии?
   3.8) Почему я получаю сообщение "Sorry, too many clients" когда
   пытаюсь подключиться к базе?
   3.9) Что это за файлы pg_sorttempNNN.NN в моем каталоге с базой
   данных?
   
                            Вопросы эксплуатации
                                      
   4.1) В чем отличие между бинарным и нормальным курсором?
   4.2) Как выполнить SELECT только для нескольких первых строчек
   запроса?
   4.3) Как получить список таблиц или других компонентов в psql?
   4.4) Как удалить колонку из таблицы?
   4.5) Каковы максимальные размеры для записей, таблиц и базы данных?
   4.6) Как много дискового пространства в базе данных нужно для
   сохранения данных из обычного текстового файла?
   4.7) Как мне убедиться, что нужные мне таблицы или индексы определены
   в базе данных?
   4.8) У меня медленно работают запросы или не происходит использования
   индексов. Почему?
   4.9) Как посмотреть на то, как оптимизатор выполняет мой запрос?
   4.10) Что такое R-tree индекс?
   4.11) Что такое Genetic Query Optimizer?
   4.12) Как мне выполнить поиск регулярного выражения и поиск
   независимый от регистра букв поиск регулярного выражения? Как мне
   использовать индекс для поиска независимого от регистра букв?
   4.13) Как я могу определить, что значение поля равно NULL в каком-либо
   запросе?
   4.14) Каковы отличия между разными символьными типами?
   4.15.1) Как мне создать поле serial/с-авто-увеличением?
   4.15.2) Как мне получить значение при вставке SERIAL?
   4.15.3) Не может ли получиться так, что использование currval() и
   nextval() приведет к зациклированию с другими пользователями?
   4.15.4) Почему числа из моей последовательности не используются снова
   при отмене транзакции? Почему создаются разрывы при нумерации в
   колонке, где я использую последовательность/SERIAL?
   4.16) Что такое OID? Что такое TID?
   4.17) Что означают некоторые термины используемые в PostgreSQL?
   4.18) Почему я получаю ошибку "ERROR: Memory exhausted in
   AllocSetAlloc()"?
   4.19) Как мне узнать, какая версия PostgreSQL запущена?
   4.20) Почему при работе с моим большим объектом я получаю ошибку
   "invalid large obj descriptor"?
   4.21) Как мне создать колонку которая по умолчанию будет содержать
   текущее время?
   4.22) Почему мои подзапросы, использующие IN так медленно работаеют?
   4.23) Как выполнить внешнее связывание?
   4.24) Как выполнять запросы, использующие несколько баз данных?
   
                           Расширения PostgreSQL
                                      
   5.1) Я написал функцию определяемую пользователем. Когда я запускаю ее
   в psql, почему я получаю dump core?
   5.2) Как я могу внести некоторые классные новые типы и функции в
   PostgreSQL?
   5.3) Как мне написать C функцию, возвращающую запись?
   5.4) Я изменил исходный файл. Почему после перекомпиляции я не вижу
   изменений?
     _________________________________________________________________
   
                               Общие вопросы
                                      
    1.1) Что такое PostgreSQL?
    
   PostgreSQL произносится Post-Gres-Q-L (Пост-Грес-Кью-Эл).
   
   PostgreSQL - это расширение СУБД POSTGRES, исследовательский прототип
   нового поколения СУБД. PostgreSQL одновременно сохраняет мощную модель
   данных и общирное количество типов POSTGRES, и замещает язык запросов
   PostQuel на расширенное подмножество SQL. PostgreSQL - это свободное и
   полностью открытое программное обеспечение.
   
   Разработку PostgreSQL выполняет команда, связанная через Internet, все
   участники которой подписаны на список рассылки разработчиков. В
   настоящее время, их координатором является Марк Форнай (Marc G.
   Fournier) (scrappy@PostgreSQL.org). (См. ниже о том, как подключиться
   к разработке). Эта команда теперь отвечает за всю разработку
   PostgreSQL.
   
   Авторами PostgreSQL 1.01 являются Эндрю Ю (Andrew Yu) и Джоли Чен
   (Jolly Chen). Многие другие внесли свой вклад в перенос на другие
   платформы, тестирование, отладку и расширение этого кода.
   Первоначальный код Postgres, из которого появился PostgreSQL, был
   итогом усилий многих академических студентов, неакадемических
   студентов и множества разных программистов, работавших под
   руководством профессора Майкла Стоунбрейкера (Michael Stonebraker) в
   Калифорнийском университете, Беркли.
   
   Первоначальное имя, данное в Беркли, было Postgres. Когда в 1995 году
   была добавлена функциональность SQL, это имя было изменено на
   Postgres95. Но и это имя было изменено в конце 1996 на PostgreSQL.
   
    1.2) Каковы авторские права на PostgreSQL?
    
   PostgreSQL попадает под действие следующего COPYRIGHT:
   
   Система Управления Базами Данных PostgreSQL
   
   Portion copyright (c) 1996-2002, PostgreSQL Global Development Group
   Portions Copyright (c) 1994-6 Regents of the University of California
   
   Предоставляются права на использование, копирование, изменение и
   распространение данного программного обеспечения и его документации
   для любых целей, бесплатно и без подписания какого-либо соглашения,
   при условии что для каждой копии будут предоставлены данное выше
   замечание об авторских правах, текущий параграф и два следующих
   параграфа.
   
   КАЛИФОРНИЙСКИЙ УНИВЕРСИТЕТ НЕ НЕСЕТ НИКАКОЙ ОТВЕТСТВЕННОСТИ ЗА ЛЮБЫЕ
   ПОВРЕЖДЕНИЯ, ВКЛЮЧАЯ ПОТЕРЮ ДОХОДА, НАНЕСЕННЫЕ ПРЯМЫМ ИЛИ НЕПРЯМЫМ,
   СПЕЦИАЛЬНЫМ ИЛИ СЛУЧАЙНЫМ ИСПОЛЬЗОВАНИЕМ ДАННОГО ПРОГРАММНОГО
   ОБЕСПЕЧЕНИЯ ИЛИ ЕГО ДОКУМЕНТАЦИИ, ДАЖЕ ЕСЛИ КАЛИФОРНИЙСКИЙ УНИВЕРСИТЕТ
   БЫЛ ИЗВЕЩЕН О ВОЗМОЖНОСТИ ТАКИХ ПОВРЕЖДЕНИЙ.
   
   КАЛИФОРНИЙСКИЙ УНИВЕРСИТЕТ СПЕЦИАЛЬНО ОТКАЗЫВАЗЫВАЕТСЯ ПРЕДОСТАВЛЯТЬ
   ЛЮБЫЕ ГАРАНТИИ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ТОЛЬКО ЭТИМИ ГАРАНТИЯМИ:
   НЕЯВНЫЕ ГАРАНТИИ ПРИГОДНОСТИ ТОВАРА ИЛИ ПРИГОДНОСТИ ДЛЯ ОТДЕЛЬНОЙ
   ЦЕЛИ. ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ НА ОСНОВЕ ПРИЦИПА
   "КАК ЕСТЬ" И КАЛИФОРНИЙСКИЙ УНИВЕРСИТЕТ НЕ ОБЯЗАН ПРЕДОСТАВЛЯТЬ
   СОПРОВОЖДЕНИЕ, ПОДДЕРЖКУ, ОБНОВЛЕНИЯ, РАСШИРЕНИЯ ИЛИ ИЗМЕНЕНИЯ.
   
   Вышеизложенное является BSD лицензией, классической лицензией
   программного обеспечения с открытым кодом. Эта лицензия не накладывает
   ограничений на использование исходного кода. Нам нравится эта лицензия
   и мы не собираемся её менять.
   
    1.3) На каких Unix платформах работает PostgreSQL?
    
   Обычно, PostgreSQL может работать на любой современной платформе
   совместимой с Unix. В инструкции по установке, вы найдете список тех
   платформ, на которых были проведены тестовые запуски PostgreSQL к
   моменту выхода данной версии.
   
    1.4) Существуют ли версии перенесенные не на Unix системы?
    
   Клиент
   
   Для запуска на платформах MS Windows возможна компиляция C библиотеки
   libpq, psql и других интерфесов и бинарных файлов. В этом случае,
   клиент запускается на MS Windows и связывается по TCP/IP с сервером,
   запущенным на одной из поддерживаемых Unix платформ. В дистрибутив
   включается файл win31.mak для того, чтобы можно было провести сборку
   библиотеки libpq и psql для Win32. PostgreSQL также работает через
   ODBC.
   
   Сервер
   
   Сервер БД может быть запущен на Windows NT и Win2k, используя
   библиотеку Cygwin, разработанную для переноса программного обеспечения
   Unix в NT. Смотрите pgsql/doc/FAQ_MSWIN в дистрибутиве или MS Windows
   FAQ на нашем сайте. Мы не планируем специально переносить PostgreSQL
   на какую-либо платформу Microsoft.
   
    1.5) Где можно взять PostgreSQL?
    
   Например, воспользовавшись анонимным доступом на ftp сайт PostgreSQL
   ftp://ftp.PostgreSQL.org/pub. Список зеркал вы найдете на нашем
   основном сайте.
   
    1.6) Где получить поддержку?
    
   Основной список рассылки: pgsql-general@PostgreSQL.org. В нем можно
   обсуждать любые темы, касающиеся PostgreSQL. Чтобы подписаться,
   отправьте письмо по электронной почте, в котором в теле письма (не в
   теме) напишите следующие строки:
    subscribe
    end

   на адрес pgsql-general-request@PostgreSQL.org.
   
   Существует дайжест список. Чтобы подписаться на него, отправьте письмо
   по электронной почте на адрес:
   pgsql-general-digest-request@PostgreSQL.org и в теле письма напишите
   строчки строчки:
    subscribe
    end

   Дайжесты отправляются подписчикам, когда в основном списке рассылки
   накопится около 30 килобайт сообщений.
   
   Доступен и список рассылки сообщений об ошибках. Чтобы подписаться на
   этот список, отправьте по электронной почте письмо на адрес
   pgsql-bugs-request@PostgreSQL.org и в теле письма напишите строчки
   строчки:
    subscribe
    end

   Также имеется список рассылки с дискуссиями разработчиков. Чтобы
   подписаться на этот список, отправьте по электронной почте письмо на
   адрес pgsql-hackers-request@PostgreSQL.org и в теле письма напишите
   строчки строчки:
    subscribe
    end

   Дополнительные списки рассылки и инфомацию о PostgreSQL можно найти на
   домашней страничке PostgreSQL по адресу:
   
     http://www.PostgreSQL.org
     
   Еще существует IRC канал на EFNet, с названием #PostgreSQL. Я
   использую для подключения к этому каналу команду Unix irc -c
   '#PostgreSQL' "$USER" irc.phoenix.net.
   
   Список коммерческой поддержки компаний доступен на
   http://www.postgresql.org/users-lounge/commercial-support.html.
   
    1.7) Какая последняя версия?
    
   Последний выпуск PostgreSQL - это версия 7.2.
   
   Мы планируем выпускать новые версии каждые четыре месяца.
   
    1.8) Какая документация имеется в наличии?
    
   В дистрибутив включаются различные руководства, страницы электронного
   руководства man и некоторые маленькие тестовые примеры. Смотрите в
   каталог /doc. Вы также можете просматривать документацию в Интернет по
   адресу http://www.PostgreSQL.org/users-lounge/docs/.
   
   Существует две книги по PostgreSQL доступные по адресам
   http://www.PostgreSQL.org/docs/awbook.html и
   http://www.commandprompt.com/ppbook/. Список книг по PostgreSQL,
   которые можно купить доступен по адресу
   http://www.postgresql.org/books/. Кроме того, по адресу
   http://techdocs.postgresql.org/ вы можете найти коллекцию технических
   статей посвященных PostgreSQL.
   
   psql имеет несколько прекрасных команд \d для отображения информации
   по типам, операторам, функциям, агрегатам и т.д.
   
   Наш сайт содержит еще больше информации.
   
    1.9) Как найти информацию об известных ошибках или отсутствующих
    возможностях?
    
   PostgreSQL поддерживает расширенный подкласс SQL-92. Смотрите наш
   список TODO на предмет известных ошибок, отсутствующих особенностях и
   будущих планов.
   
    1.10) Как мне научиться SQL?
    
   Книга по PostgreSQL на http://www.PostgreSQL.org/docs/awbook.html
   научит SQL. Существует другая книга по PostgreSQL на
   http://www.commandprompt.com/ppbook. Есть прекрасный учебник на
   http://www.intermedia.net/support/sql/sqltut.shtm, на
   http://ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM,
   и на http://sqlcourse.com.
   
   Еще один учебник - это книга "Teach Yourself SQL in 21 Days, Second
   Edition" (Освой самостоятельно SQL за 21 день, Вторая редакция) на
   http://members.tripod.com/er4ebus/sql/index.htm
   
   Многим из наших пользователей нравится книга The Practical SQL
   Handbook, Bowman, Judith S., et al., Addison-Wesley. Другим нравится
   The Complete Reference SQL, Groff et al., McGraw-Hill.
   
    1.11) Решена ли в PostgreSQL проблема 2000-го года (Y2K)?
    
   Да, мы легко манипулируем датами после 2000 года и перед 2000 годом.
   
    1.12) Как присоединится к команде разработчиков?
    
   Для начала, скачайте последнюю версию исходных текстов и прочтите
   документацию разработчиков PostgreSQL на нашем сайте или в
   дистрибутиве. Затем, подпишитесь на списки рассылки pgsql-hackers и
   pgsql-patches. Далее, отправляйте исправления (patches) высокого
   качества в список pgsql-patches.
   
   Существует ограниченный список людей, который имеют привелегию вносить
   изменения в CVS архив PostgreSQL. Каждый из этих людей в свое время
   отправил так много высококачественных исправлений, что их было
   невозможно оставить без внимания и они были удостоены превилегии
   вносить изменения, и мы уверены, что те исправления, которые они
   внесут будут высокого качества.
   
    1.13) Как отравить сообщение об ошибке??
    
   Пожалуйста посетите страничку PostgreSQL BugTool, на которой
   предоставлены детальные инструкции о том как отправить сообщение об
   ошибке.
   
   Также не забудьте посмотреть на ftp://ftp.PostgreSQL.org/pub на
   предмет более свежих версий PostgreSQL или заплат.
   
    1.14) Как сравнивать PostgreSQL с другими СУБД?
    
   Существует несколько методов сравнения программного обеспечения:
   возможности, производительность, надежность, поддержка и цена.
   
   Возможности
          PostgreSQL имеет большинство возможностей представленных в
          больших коммерческих СУБД, такие как: транзакции, подзапросы,
          триггеры, обзоры (views), внешний ключ ссылочной целостности и
          разные блокировки. У нас есть некоторые возможности, которых
          нет у них: типы, определяемые пользователем, механизм
          наследования, правила и конкуретное многоверсионное управление
          для работы с содержимым блокировок.
          
   Производительность
          PostgreSQL может работать в двух режима. В нормальном fsync
          режиме, каждая завершенная транзакция сбрасывается на диск,
          гарантируя, что если операционная система или питание рухнет в
          следующие несколько секунд, все ваши данные безопасно
          сохранятся на диске. В этом режиме, мы работаем медленее, чем
          большинство коммерческих СУБД, отчасти потому, что некоторые из
          них делают у себя по умолчанию такой консервативный сброс на
          диск. В режиме no-fsync, мы обычно быстрее чем коммерческие
          СУБД, но в этом режиме, падение операциооной системы может
          привести к потере данных. Мы работаем над тем чтобы
          предоставить промежуточный режим, который обеспечивал более
          высокую производительность, чем fsync режим и позволял
          сохранить целостность данных записанных в течении 30 секунд до
          падения операционной системы.
          В сравнении с MySQL или линейными СУБД, мы медленее при
          операциях вставки/обновления, потому что мы управляем
          транзакциями. И разумеется, MySQL не имеет каких-либо
          возможностей из перечисленых в секции Возможности. Мы делаем
          упор на удобстве и возможностях, но мы также продолжаем
          увеличивать производительность путем профилирования и анализа
          исходных текстов. Существует интересная страничка в Интернет,
          сравнивающая PostgreSQL и MySQL на
          http://openacs.org/why-not-mysql.html
          Мы управляем каждым пользовательским соединением, создавая Unix
          backend процесс. Backend процессы разделяют буферы данных и
          информацию о блокировках. При наличии нескольких процессоров,
          несколько backend процессов легко могут быть запущены на разных
          процессорах.
          
   Надежность
          Мы понимали, что наша СУБД должна быть надежной или она ничего
          не будет стоить. Мы стараемся выпускать хорошо проверенный,
          стабильный код, который содержит минимум ошибок. Каждый выпуск
          проходит стадию бета-тестирования по крайней мере в течении
          одного месяца и наша история выпусков показывает что мы можем
          предоставлять стабильные, монолитные выпуски, которые готовы к
          продуктивному использованию. Мы верим, что мы производим
          проверку не хуже, чем у других СУБД.
          
   Поддержка
          Наш список рассылки представлен большой группой разработчиков и
          пользователей, которые могут помочь решить любые возникшие
          проблемы. В то же время, мы не гарантируем какие-либо
          исправления, но и разработчики коммерческих СУБД не всегда
          делают исправления. Прямой доступ к разработчикам, сообществу
          пользователей, руководствам и исходным текстам часто делают
          поддержку PostgreSQL превосходящей другие СУБД. Существует
          коммерческая поддержка по результам возникших инцидентов,
          которая доступна для тех кому она нужна. (Смотрите Как получить
          поддержку?.)
          
   Цена
          Наш продукт бесплатен как для коммерческого так, и не для
          коммерческого использования. Вы можете добавлять свой код в наш
          продукт без ограничений, за исключением тех, что описываются в
          нашей лицензии стиля BSD, которая приведена выше.
          
    1.15) Как оказать финансовую помощь PostgreSQL?
    
   PostgreSQL имеет одноранговую инфраструктуру с того самого времени как
   мы начали разработку 6 лет назад. Мы должны благодарить за это Марка
   Фоная (Marc Fournier), который создал эту инфраструктуру и управляет
   ей на протяжении этих лет.
   
   Качественная инфраструктура очень важна для проектов с открытым
   исходным кодом. Она предотвращает расколы, которые могут сильно
   задержать поступательное движение проекта.
   
   Разумеется, эта инфраструктура не является дешевой. Существует
   некоторое количество ежемесячных и одноразовых расходов, которые
   требуют денег. Если вы или ваша компания имеет деньги, которые можно
   передать в помощь нашим усилиям, пожалуйста посетите страничку
   http://www.pgsql.com/pg_goodies и сделайте свой вклад.
   
   Хотя на страничке говорится о PostgreSQL, Inc, пункт "contributions"
   предназначен исключительно для поддержки проекта PostgreSQL и не
   передается какой-либо конкретной компании. Если хотите, то можете это
   проверить, написав письмо на контактный адрес.
     _________________________________________________________________
   
                 Вопросы пользователей по клиентской части
                                      
    2.1) Существуют ли ODBC драйвера для PostgreSQL?
    
   Существует два ODBC драйвера, PsqlODBC и OpenLink ODBC.
   
   PsqlODBC включается в дистрибутив. Больше информации об этом драйвере
   можно найти на ftp://ftp.PostgreSQL.org/pub/odbc/.
   
   OpenLink ODBC можно взять на http://www.openlinksw.com. Этот драйвер
   работает с их стандартным клиентским программным обеспечением,
   использующим ODBC, и таким образом, ODBC драйверы для PostgreSQL
   доступны для каждой из поддерживаемых ими платформ (Win, Mac, Unix,
   VMS).
   
   Возможно они будут продавать свой продукт тем кому нужна коммерческая
   поддержка, но бесплатная версия всегда будет доступна. Пожалуйста,
   направляйте вопросы на адрес postgres95@openlink.co.uk.
   
   Также посмотрите ODBC раздел в руководстве программиста.
   
    2.2) Какие инструменты существуют для использования PostgreSQL через Web?
    
   Прекрасное введение во взаимодействие баз данных и Web можно найти на:
   http://www.webreview.com
   
   Также загляните на http://www.phone.net/home/mwm/hotlist/.
   
   Для интеграции с Web, одним из превосходных инструментов является PHP.
   Домашняя станичка http://www.php.net.
   
   Для комплексных решений, многие пользуются Perl интерфейсом и CGI.pm.
   
    2.3) Есть ли у PostgreSQL графический интерфейс пользователя? Генератор
    отчетов? Встроенный интерфейс для языка запросов?
    
   У нас есть прекрасный горафический интерфейс, называемый pgaccess,
   который является частью дистрибутива. pgaccess также емеет генератор
   отчетов. Его страничка http://www.flex.ro/pgaccess
   
   Мы также включаем ecpg, который предоставляет встроенный интерфейс к
   языку запросов SQL из C.
   
    2.4) Какие языки могут взаимодействовать с PostgreSQL?
    
   Вот эти:
     * C (libpq)
     * C++ (libpq++)
     * Embedded C (ecpg)
     * Java (jdbc)
     * Perl (perl5)
     * ODBC (odbc)
     * Python (PyGreSQL)
     * TCL (libpgtcl)
     * C Easy API (libpgeasy)
     * Embedded HTML (PHP from http://www.php.net)
     _________________________________________________________________
   
                         Вопросы администрирования
                                      
    3.1) Как мне установить PostgreSQL в место отличное от /usr/local/pgsql?
    
   Задайте опцию --prefix когда запускаете configure.
   
    3.2) Когда я запускаю postmaster, я получаю сообщение Bad System Call или
    сообщение core dumped. Почему?
    
   Это может быть вызвано разными проблемами, но первое, что нужно
   сделать - это убедиться в том, что в вашем ядре установлено расширение
   System V. PostgreSQL требует, чтобы ядро поддерживало разделяемую
   память и семафоры.
   
    3.3) Когда я пытаюсь запустить postmaster, я получаю ошибки
    IpcMemoryCreate. Почему?
    
   Либо у вас в ядре неправильные настройки разделяемой памяти, либо
   вашему ядру нужно большее количество доступной разделяемой памяти. Те
   конкретные действия, которые вам нужно произвести зависят от
   архитектуры вашей машины и от того как много буферов и backend
   процессов вы настроили для postmaster. Для большинства систем, с
   количеством буферов и процессов по умолчанию, необходимый минимум -
   это около 1 мегабайта. Подробности о разделяемой памяти и семафорах
   смотрите в Руководстве администратора PostgreSQL.
   
    3.4) Когда я пытаюсь запустить postmaster, я получаю ошибки
    IpcSemaphoreCreate. Почему?
    
   Если это сообщение IpcSemaphoreCreate: semget failed (No space left on
   device) то настройки вашего ядра таковы, что ему не хватает семафоров.
   Postgres требует один семафор на потенциальный backend процесс.
   Временным решением является запуск postmaster с настройками на мешьшее
   количество backend процессов. Используйте -N с значением меньшим чем
   32, которое принято по умолчанию. Более правильное решение - это
   увеличить значения SEMMNS и SEMMNI в настрйках ядра.
   
   Неисправные семафоры также могут привести к падению СУБД во время
   доступа к базе данных.
   
   Если вы получили какое-либо другое сообщение об ошибке, то вполне
   возможно, что в вашем ядре вообще не настроена поддержка семафоров.
   Смотрите подробности о разделяемой памяти и семафорах в Руководстве
   Администратора PostgreSQL.
   
    3.5) Как мне управлять соединениями с других компьютеров?
    
   По умолчанию, PostgreSQL разрешает только соединения на локальной
   машине через сокеты домена Unix. Другие машины не смогут подключиться
   к базе пока для postmaster не будет задан флаг -i и пока не будет
   разрешена host-авторизация в файле $PGDATA/pg_hba.conf. Эти действия
   делают возможными TCP/IP соединения.
   
    3.6) Какие настройки мне нужно сделать для улучшения производительности?
    
   Несомненно, индексы могут увеличить скорость выполнения запросов.
   Команда EXPLAIN позволяет вам посмотреть как PostgreSQL интерпретирует
   ваш запрос и какие индексы используются.
   
   Если вы выполняете много операторов INSERT, рассмотрите возможность
   выполнять их в большой пачке, используя команду COPY. Это значительно
   быстрее, чем отдельные INSERT. Во-вторых, операторы вне блока
   транзакции BEGIN WORK/COMMIT сами выполняют транзакцию. Подумайте над
   выполнением нескольких операторов в одном блоке транзакции. Это
   уменьшит количество транзакций. Также, задумайтесь над удалением и
   пересозданием индексов, когда вы выполняете большие изменения данных.
   
   Существует несколько опций настройки. Вы можете запретить fsync() при
   старте postmaster с опцией -o -F. Это предотвратит вызовы fsync(),
   которые приводят к сбросу данных на диск после каждой транзакции.
   
   Вы можете также использовать для postmaster опцию -B для увеличения
   количества буферов разделяемой памяти, которая используется backend
   процессами. Если вы сделаете значение этого параметра слишком большим,
   то postmaster может не запустится потому что вы исчерпаете ограничение
   ядра на объем разделяемой памяти. Каждый буфер имеет размер в 8
   килобайт и по умолчанию выделяется 64 буфера.
   
   Вы можете также использовать backend опцию -S для увеличения
   максимального количества памяти, которое используется backend
   процессом для временных сортировок. Значение для опции -S задается в
   килобайтах и по умолчанию равно 512 (т.е. 512K).
   
   Вы также можете использовать команду CLUSTER для группировки данных в
   таблицах на совпадающий индекс. Подробности смотрите на странице
   руководства по команде CLUSTER.
   
    3.7) Какие возможности для отладки есть в наличии?
    
   PostgreSQL имеет несколько возможностей, позволяющие получить
   информацию о состоянии, которая может быть использована в отладочных
   целях.
   
   Во-первых, при запуске configure с опцией --enable-cassert, многие
   вызовы assert() позволяют отслеживать работу backend процесса и
   остановку программы при возникновении каких-либо неожиданностей.
   
   И postmaster, и postgres имеют несколько отладочных опций. Во-первых,
   при запуске postmaster, убедитесь, что стандартный вывод и вывод
   ошибок осуществляются в файл журнала:
    cd /usr/local/pgsql
    ./bin/postmaster >server.log 2>&1 &

   Это приведет к появлению файла server.log в главном каталоге
   PostgreSQL. Этот файл содержит полезную информацию о проблемах или
   ошибках, возникших на сервере. Postmaster имеет опцию -d, которая
   позволяет получать при протоколировании более детальную инфрмацию. Для
   опции -d указывается число, которое задает уровень отладки. Будьте
   осторожны, так как высокий уровень отладки приводит к генерации файлов
   журнала большого размера.
   
   Если postmaster не запущен, вы можете запустить postgres backend из
   командной строки и ввести ваш оператор SQL напрямую. Это рекомендуется
   только для целей отладки. Заметим, что в этом режиме, запрос
   завершается символом новой строки, а не точкой с запятой. Если вы
   производили компиляцию с отладочными символоами, вы можете
   использовать любой отладчик, чтобы посмотреть, что случилось.
   Поскольку backend запускается не из postmaster, он не запускается в
   идентичном окружении и значит проблемы итераций блокировок/backend не
   могут быть воспроизведены.
   
   Если postmaster запущен, запустите psql в одном окне, затем найдите
   PID процесса postgres, используемый psql. Используйте отдадчик для
   подключения к postgres PID. Вы можете установить точки прерывания в
   отладчике и запустить запрос из psql. Если вы производите отладку
   запуска postgres, вы можете установить PGOPTIONS="-W n", и затем
   запустить psql. Эта опция приводит к задержке процесса запуска на n
   секунд, в течение которых вы можете подключить к процессу отладчик,
   установить любые точки прерывания и продолжить запуск.
   
   Программа postgres имеет опции -s, -A, и -t которые могут быть очень
   полезными для отладки и измерения производительности.
   
   Вы также можете скомпилировать PostgreSQL с профилированием для того,
   чтобы увидеть какие функции сколько времени выполняются. Файлы
   профилирования backend'а находятся в каталоге pgsql/data/base/dbname.
   Файл профилирования клиента будет помещен в текущий каталог клиента.
   
    3.8) Почему я получаю сообщение "Sorry, too many clients" когда пытаюсь
    подключиться к базе?
    
   Вам нужно увеличить ограничение на количество конкуретных backend
   процессов при запуске postmaster.
   
   По умолчанию установлен лимит на 32 процесса. Вы можете увеличить этот
   лимит перезапустив postmaster с нужным значением процессов, которое
   указывается в опции -N или изменив файл postgresql.conf.
   
   Заметим, что если вы зададите в опции -N значение больше 32, то вы
   также должны увеличить значение в опции -B которое по умолчанию
   установлено в 64; Значение опции -B должно быть по крайней мере вдвое
   больше значения опции -N, и возможно ещё больше для лучшей
   производительности. Для большего количества backend процессов, вам
   также неплохо было бы увеличить некоторые параметры ядра Unix. Это
   такие параметры, как максимальное количество блоков разделяемой
   памяти, SHMMAX; максимальное количество семафоров, SEMMNS и SEMMNI;
   максимальное количество процессов, NPROC; максимальное количество
   процессов на пользователя, MAXUPRC; и максимальное количество открытых
   файлов, NFILE и NINODE. Причина создания ограничения на количество
   backend процессов как раз и состоит в том, чтобы вашей системе хватило
   ресурсов.
   
   В PostgreSQL до версии 6.5, максимальное количество backend процессов
   было 64, и изменение этого количества требовало перекомпиляции после
   установки константы MaxBackendId в include/storage/sinvaladt.h.
   
    3.9) Что это за файлы pg_sorttempNNN.NN в моем каталоге с базой данных?
    
   Это временные файлы, генерируемые во время выполнения запроса.
   Например, если для оператора ORDER BY должна быть выполнена
   сортировка, которая требует больше места чем выделенно для backend
   процесса в опции -S, то создается временный файл для хранения
   дополнительных данных.
   
   Временные файлы должны удаляться автоматически, но этого может не
   происходить, если backend процесс падает во время сортировки. Если у
   вас не запущено ни одного backend процесса, то вы можете спокойно
   удалить файлы pg_tempNNN.NN.
     _________________________________________________________________
   
                            Вопросы эксплуатации
                                      
    4.1) В чем отличие между бинарным и нормальным курсором?
    
   Смотрите описание на страницах руководства посвященным DECLARE.
   
    4.2) Как выполнить SELECT только для нескольких первых строчек запроса?
    
   Смотрите станицу руководства посвященную FETCH или используйте SELECT
   ... LIMIT....
   
   Даже если вы хотите получить только первые несколько записей, будет
   выполнен весь запрос. Рассмотрим запрос, который имеет ORDER BY. Если
   есть какой-либо индекс, который совпадает с ORDER BY, PostgreSQL может
   выдать только несколько первых запрошенных записей или может выполнять
   запрос пока не будут выданы желаемые записи.
   
    4.3) Как получить список таблиц или других компонентов в psql?
    
   Вы можете посмотреть исходный код psql в файле
   pgsql/src/bin/psql/describe.c. Он содержит команды SQL которые
   генерируются при вводе в psql команд, начинающихся с обратной косой
   черты. Вы также моежете запустить psql с опцией -E так, чтобы эта
   программа выдавала запросы, которые она использует для выполнения
   заданных вами команд.
   
    4.4) Как удалить колонку из таблицы?
    
   Мы не поддерживаем ALTER TABLE DROP COLUMN, но можно сделать так:
    SELECT ...  -- выборка всех колонок за исключением той, которую хотите удал
ить
    INTO TABLE new_table
    FROM old_table;
    DROP TABLE old_table;
    ALTER TABLE new_table RENAME TO old_table;

    4.5) Каковы максимальные размеры для записей, таблиц и базы данных?
    
   Существуют следующие ограничения:
    Максимальный размер базы?              неограничен (существуют базы на 60 G
B)
    Максимальный размер таблицы?           16 TB
    Максимальный размер записи?            неограничен начиная с версии 7.1
    Максимальный размер поля?              1 GB начиная с версии 7.1
    Максимальное количество записей в таблице?      неограничено
    Максимальное количество колонок в таблице?    250-1600 в зависимости от тип
а
    Максимальное количество индексов в таблице?   неограничено

   Разумеется, понятие "неограничено" на самом деле ограничивается
   доступным дисковым пространиством и размерами памяти/своппинга. Когда
   значения перечисленные выше неоправдано большие, может пострадать
   производительность.
   
   Максимальный размер таблицы в 16 TB не требует чтобы операционная
   система поддерживала файлы больших размеров. Большие таблицы хранятся
   как множество файлов размером в 1 GB, так что ограничения, которые
   накладывает файловая система не важны.
   
   Максимальный размер таблицы и максимальное количество колонок могут
   быть увеличены, если размер блока по умолчанию будет увеличен до 32k.
   
    4.6) Как много дискового пространства в базе данных нужно для сохранения
    данных из обычного текстового файла?
    
   СУБД PostgreSQL может потребоваться дискового пространства до 5 раз
   больше для сохранения данных из простого текстового файла.
   
   В качестве примера, рассмотрим файл в 100,000 строк в каждой, из
   которых целое число и текстовое описание. При этом длина текста, в
   среднем, составляет 20 байт. Размер простого файла составит 2.8 MB.
   Размер базы PostgreSQL, содержащей эти же данные составит
   приблизительно 6.4 MB из которых:
    36 байт: на каждый заголовок записи (приблизительно)
  + 24 байта: одно поле с целочисленным типом и одно текстовое поле
   + 4 байта: указатель на странице для всей записи
   ----------------------------------------
    64 байт на запись

   Размер страницы данных в PostgreSQL составляет 8192 байт (8 KB), так что:

   8192 байт на страницу
   -------------------   =  128 записей на страницу БД (с округлением)
     64 байт на запись

   100000 строк данных
   --------------------  =  782 страницы в БД
  128 записей на страницу

782 страницы БД * 8192 байт на страницу  =  6,406,144 байт (6.4 MB)

   Индексы не требуют так много, но поскольку они создаются для большого
   количества данных, они также могут быть велики.
   
    4.7) Как мне убедиться, что нужные мне таблицы или индексы определены в
    базе данных?
    
   psql имеет несколько команд, начинающихся с обратной косой черты, для
   того чтобы просматривать такую информацию. Используйте \? для того,
   чтобы увидеть эти команды.
   
   Также смотрите файл pgsql/src/tutorial/syscat.source. В нем
   представлены многие операторы SELECT которые нужны для получения
   информации из системных таблиц базы данных.
   
    4.8) У меня медленно работают запросы или не происходит использования
    индексов. Почему?
    
   PostgreSQL не управляет статистикой автоматически. Для обновления
   статистики должен быть запущен оператор VACUUM. После того, как
   статистика обновилась, оптимизатор узнает о том как много записей в
   таблице и если он должен использовать индексы, то он может принимать
   лучшие решения. Заметим, что оптимизатор не использует индексы в
   случае, когда таблица маленькая, потому что простой последовательный
   перебор будет быстрее.
   
   Для специфической статистики по колонкам, используйте VACUUM ANALYZE.
   VACUUM ANALYZE является важным для комплексных запросов множественного
   связывания, так как оптимизатор может оценить количество записей,
   возвращаемых от каждой таблицы и выбрать правильный порядок
   связывания. Backend не осуществляет для себя отслеживание статистики
   по колонкам, так что для сбора статистики нужно периодически запускать
   VACUUM ANALYZE.
   
   Обычно индексы не используются для ORDER BY или связываний.
   Последовательный перебор через явную сортировку будет быстрее, чем
   поиск по индексам всех записей в большой таблице, потому что доступ к
   диску с использованием рандомизации очень медленен.
   
   Когда используются операции с шаблонами, например LIKE или ~, индексы
   могут быть использованы только если начало строки-шаблона для поиска,
   соответствует началу искомой строки. Так что для того, чтобы
   использовать индексы, строка шаблона в LIKE не должна начинаться на %,
   а в ~ (поиск регулярного выражения) должна начинаться с ^.
   
    4.9) Как посмотреть на то, как оптимизатор выполняет мой запрос?
    
   Смотрите страницу руководства посвященную EXPLAIN.
   
    4.10) Что такое R-tree индекс?
    
   R-tree индекс используется для индексирования пространственных данных.
   Индекс хэша не может управлять поисками диапазона. B-tree индекс
   управляет только поисками диапазона в одном измерении. R-tree индекс
   может управлять многоразмерными данными. Например, если R-tree индекс
   может быть встроен в атрибут типа point, то система может более
   эффективно ответить на запрос типа "выбрать все точки внутри заданного
   четырехугольника."
   
   Канонический источник, описывающий первоначальное создание R-tree это:
   
   Guttman, A. "R-trees: A Dynamic Index Structure for Spatial
   Searching." Proceedings of the 1984 ACM SIGMOD Int'l Conf on Mgmt of
   Data, 45-57.
   
   Вы можете найти этот документ в книге Stonebraker'а "Readings in
   Database Systems".
   
   Встроеннные R-tree могут управлять полигонами и боксами. В теории,
   R-tree могут быть расширены для управления большим количеством
   измерений. На практике, расширение R-tree требует некоторых усилий и у
   нас, в данный момент, нет какой-либо документации о том, как это
   сделать.
   
    4.11) Что такое Genetic Query Optimizer?
    
   Модуль GEQO производит быструю оптимизацию запроса, когда происходит
   связывание многих таблиц через Genetic Algorithm (GA). Это позволяет
   управлять большими запросами на связывание через неистощающий поиск.
   
    4.12) Как мне выполнить поиск регулярного выражения и поиск независимый от
    регистра букв поиск регулярного выражения? Как мне использовать индекс для
    поиска независимого от регистра букв?
    
   Оператор ~ производит поиск регулярного выражения, а оператор ~*
   производит независимый от регистра букв поиск регулярного выражения.
   Независимый от регистра вариант LIKE называется ILIKE в PostgreSQL
   начиная с версии 7.1.
   
   Независимое от регистра сравнение обычно выражается так:
    SELECT *
    FROM tab
    WHERE lower(col) = 'abc'

   Эта конструкция не будет использовать стандартный индекс. Однако, если
   вы создадите функциональный индекс, он будет использован:
    CREATE INDEX tabindex on tab (lower(col));

    4.13) Как я могу определить, что значение поля равно NULL в каком-либо
    запросе?
    
   Вы просто сравниваете значение с IS NULL и IS NOT NULL.
   
    4.14) Каковы отличия между разными символьными типами?
    
Тип            Внутреннее имя   Замечания
--------------------------------------------------
"char"          char            1 символ
CHAR(#)         bpchar          заполняется пустотой до фиксированной длины
VARCHAR(#)      varchar         размер задает максимальную длину, нет заполнени
я
TEXT            text            нет задаваемого верхнего ограничения или длины
BYTEA           bytea           массив байт переменной длины (можно использоват
ь null-байт без опаски)

   Внутреннее имя вы можете увидеть, когда смотрите системные каталоги и
   в некоторых сообщениях об ошибках.
   
   Последние четыре типа являются "varlena" типами (т.е., первые четыре
   байта на диске являются длинной, за которой следуют данные). Таким
   образом, фактически используемое пространство больше, чем обозначенный
   размер. Однако, эти типы данных также поддаются сжатию или могут быть
   сохранены не в строком виде через TOAST, так что занимаемое дисковое
   пространство может также быть и меньше, чем ожидалось.
   
   CHAR() - это лучшее решение для хранения строк, которые обычно имеют
   одинаковую длину. VARCHAR() - это лучшее решение, когда нужно хранить
   строки переменной длины, но не превышающие определенного размера. TEXT
   - это лучшее решение для строк неограниченной длины, с максимально
   допустимой длиной в 1 гигабайт. BYTEA для хранения бинарных данных,
   значения которых могут включать NULL байты.
   
    4.15.1) Как мне создать поле serial/с-авто-увеличением?
    
   PostgreSQL поддерживает тип данных SERIAL. Он автоматически создает
   последовательность и индекс для колонки. Например:
    CREATE TABLE person (
        id   SERIAL,
        name TEXT
    );

   автоматически транслируется в:
    CREATE SEQUENCE person_id_seq;
    CREATE TABLE person (
        id   INT4 NOT NULL DEFAULT nextval('person_id_seq'),
        name TEXT
    );
    CREATE UNIQUE INDEX person_id_key ON person ( id );

   Смотрите подробности о последовательностях на странице руководства
   посвященной create_sequence. Вы также можете использовать каждое поле
   OID в записи как уникальное значение. Однако, если вам нужен дамп и
   перезагрузка базы данных, вам необходимо использовать команду pg_dump
   с опцией -o или опцию COPY WITH OIDS для сохранения значений поля OID.
   
    4.15.2) Как мне получить значение при вставке SERIAL?
    
   Один из способов состоит в получении следующего значения SERIAL из
   объекта sequence с помощью функции nextval() перед вставкой и затем
   вставлять это значение явно. Используйте таблицу-пример в 4.15.1,
   чтобы увидеть как это делается в Perl:
    new_id = output of "SELECT nextval('person_id_seq')"
    INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal');

   Затем вы должны также сохранить новое значение в переменной new_id для
   его использования в других запросах (например таких как внешний ключ
   для таблицы person). Заметим, что имя автоматически созданного объекта
   SEQUENCE будет <table>_<serialcolumn>_seq, где table и serialcolumn
   являются соответственно именами вашей таблицы и вашей колонки SERIAL.
   
   В качестве альтернативы, вы можете получить назначенное значение
   SERIAL с помощью функции currval() после проведения обычной операции
   вставки, например
    INSERT INTO person (name) VALUES ('Blaise Pascal');
    new_id = output of "SELECT currval('person_id_seq')";

   И наконец, вы можете использовать значение OID, возращаемое из
   опертора INSERT чтобы увидеть значение по умолчанию, что
   предположительно является наименее переносимым на другие платформы
   решением. В Perl, используя DBI с модулеи Edmund Mergl'я DBD::Pg,
   значение oid становится доступным через $sth->{pg_oid_status} после
   $sth->execute().
   
    4.15.3) Не может ли получиться так, что использование currval() и nextval()
    приведет к зациклированию с другими пользователями?
    
   Нет. Currval() возвращает текущее значение, назначенное вашем
   backend'ом, а не другими пользователями.
   
    4.15.4) Почему числа из моей последовательности не используются снова при
    отмене транзакции? Почему создаются разрывы при нумерации в колонке, где я
    использую последовательность/SERIAL?
    
   Для реализации конкуретности, значения последовательностей, при
   необходимости выдаются во время запуска транзакций и не блокируются до
   полного выполнения транзакций. Это может вызывать разрывы в нумерации
   при отмене транзакций
   
    4.16) Что такое OID? Что такое TID?
    
   Поля OID служат уникальными идетификаторами записей в PostgreSQL.
   Каждая запись, которая создаётся в PostgreSQL получает уникальный OID.
   Все значения OID генерируемые во время initdb имеют значения меньше
   16384 (из backend/access/transam.h). Все созданные пользователем OID
   имеют бОльшие значение. По умолчанию, все эти OID являются уникальными
   не только внутри какой-либо таблицы или базы данных, но и внутри всей
   СУБД PostgreSQL.
   
   PostgreSQL использует OID в своих внутренних системных таблицах для
   связи записей и таблиц. Значения OID могут быть использованы для
   идентификации заданных пользователем записей, а также использоваться
   при связываниях. Рекомендуется использовать тип колонки OID для
   хранения значений OID Вы можете создать индекс на поле OID для более
   быстрого доступа.
   
   Значения OID назначаются для всех новых записей из центральной
   области, которые используются всеми всеми базами данных. Если вы
   хотите изменить OID на какое-либо другое значение или если вы хотите
   создать копию таблицы с такимиже OID, то это можно сделать так:
        CREATE TABLE new_table(old_oid oid, mycol int);
        SELECT old_oid, mycol INTO new FROM old;
        COPY new TO '/tmp/pgtable';
        DELETE FROM new;
        COPY new WITH OIDS FROM '/tmp/pgtable';

   OID хранится как 4-х байтное целое и не может превышать значение в 4
   миллиарда. Однако, еще никто не сообщил о том, что такое произошло, но
   мы планируем до того как это случиться избавится от этого ограничения.
   
   TID используется для идентификации специальных физических записей с
   блочными и offset значениями. TID изменяется после того как записи
   были изменены или перегружены.
   
   TID используется индексными записями в качестве указателя на
   физические записи.
   
    4.17) Что означают некоторые термины используемые в PostgreSQL?
    
   Некоторый исходный код и старая документация используют
   общеупотребительные термины. Вот некоторые из них:
     * table, relation, class
     * row, record, tuple
     * column, field, attribute
     * retrieve, select
     * replace, update
     * append, insert
     * OID, serial value
     * portal, cursor
     * range variable, table name, table alias
       
   Список общих терминов по базам данных можно найти на
   http://www.comptechnews.com/~reaster/dbdesign.html
   
    4.18) Почему я получаю ошибку "ERROR: Memory exhausted in AllocSetAlloc()"?
    
   Если у вас версия ниже 7.1, то обновление версии может решить эту
   проблему. Также возможно, что у вас закончилась виртуальная память или
   что ваше ядро имеет маленький лимит на определенные ресурсы.
   Попытайтесь перед запуском postmaster выполнить следующие команды:
    ulimit -d 262144
    limit datasize 256m

   В зависимости от командного интерпретатора shell, только одна из
   данных команд выполнится успешно, но она позволит вам установить
   больший сегмент данных процесса и возможно решит проблему. Эта команда
   изменяет параметры текущего процесса и всех его потомков, созданных
   после её запуска. Если у вас возникла проблема с SQL клиентом, потому
   что backend возвращает слишком большой объем данных, попытайтесь
   выполнить эту команду перед запуском клиента.
   
    4.19) Как мне узнать, какая версия PostgreSQL запущена?
    
   Из psql, наберите select version();
   
    4.20) Почему при работе с моим большим объектом я получаю ошибку "invalid
    large obj descriptor"?
    
   Вам нужно при использовании большого объекта поместить в начале BEGIN
   WORK и в конце COMMIT, а внутри получившегося блока lo_open ...
   lo_close.
   
   В настоящий момент PostgreSQL требует, чтобы при закрытии большого
   объекта происходило выполнение транзакции. Таким образом, первая же
   попытка сделать что-либо с большим объектом, не соблюдая данного
   правила приведет к сообщению invalid large obj descriptor, так как код
   выполняющий работу над большим объектом (по крайней мере в настоящий
   момент) будет генерировать сообщение об ошибке если вы не используете
   транзакцию.
   
   Если вы используете такой интерфейс клиента как ODBC, вам возможно
   понадобится установить auto-commit off.
   
    4.21) Как мне создать колонку которая по умолчанию будет содержать текущее
    время?
    
   Используйте CURRENT_TIMESTAMP:
CREATE TABLE test (x int, modtime timestamp DEFAULT CURRENT_TIMESTAMP );

    4.22) Почему мои подзапросы, использующие IN так медленно работаеют?
    
   В настоящий момент, мы связываем позапросы для внешних запросов через
   последовательный перебор результата подзапроса для каждой записи
   внешнего запроса. Попробуйте заменить IN на EXISTS:
SELECT *
    FROM tab
    WHERE col1 IN (SELECT col2 FROM TAB2)

   на:
SELECT *
    FROM tab
    WHERE EXISTS (SELECT col2 FROM TAB2 WHERE col1 = col2)

   Мы надеемся убрать это ограничение в будущем выпуске.
   
    4.23) Как мне выполнить внешнее связывание?
    
   PostgreSQL начиная с версии 7.1 поддерживает внешнее связывание,
   используя стандартный синтаксис SQL. Вот два примера:
    SELECT *
    FROM t1 LEFT OUTER JOIN t2 ON (t1.col = t2.col);

   or
    SELECT *
    FROM t1 LEFT OUTER JOIN t2 USING (col);

   Это идентичные запросы связывания t1.col и t2.col, также возвращают
   любые несвязанные записи в t1 (которые не совпадают с t2). RIGHT
   связывание должно добавить несвязанные записи t2. FULL связывание
   должно возвратить совпавшие записи плюс все несвязанные записи из t1 и
   t2. Слово OUTER является необязательным и назначается в LEFT, RIGHT и
   FULL связываниях. Обычные связывания называются INNER связывания.
   
   В предыдущих версиях, внешние связывания могли быть эмулированы
   используя UNION и NOT IN. Например, когда происходит связывание tab1 и
   tab2, следующий запрос выполняет внешнее связывание двух таблиц:
    SELECT tab1.col1, tab2.col2
    FROM tab1, tab2
    WHERE tab1.col1 = tab2.col1
    UNION ALL
    SELECT tab1.col1, NULL
    FROM tab1
    WHERE tab1.col1 NOT IN (SELECT tab2.col1 FROM tab2)
    ORDER BY col1

    4.24) Как выполнять запросы, использующие несколько баз данных?
    
   Не существует способа создать запрос к базам данных отличным от
   текущей. Поскольку PostgreSQL загружает системные каталоги специфичные
   для базы данных, непонятно даже, как должен себя вести такой
   межбазовый запрос.
   
   Разумеется, клиент может одновременно устанавливать соедиенения с
   различными базами данных и таких образом объединять информацию из них.
     _________________________________________________________________
   
                           Расширения PostgreSQL
                                      
    5.1) Я написал функцию определяемую пользователем. Когда я запускаю ее в
    psql, почему я получаю dump core?
    
   Проблема может заключаться в нескольких вещах. Попытайтесь сперва
   протестировать вашу функцию в отдельной самостоятельной программе.
   
    5.2) Как я могу внести некоторые классные новые типы и функции в
    PostgreSQL?
    
   Отправьте ваши расширения в список рассылки pgsql-hackers и они по
   возможности будут помещены в подкаталог contrib/.
   
    5.3) Как мне написать C функцию, возвращающую запись?
    
   Это требует некоего шаманства так как авторы никогда не пробовали
   делать это, хотя в приницпе это возможно.
   
    5.4) Я изменил исходный файл. Почему после перекомпиляции я не вижу
    изменений?
    
   Файлы Makefile не имеют правильных зависимостей для include файлов. Вы
   должны выполнить make clean и затем make. Если вы используете GCC вы
   можете использовать опцию --enable-depend в configure чтобы поручить
   компилятору автоматически отслеживать зависимости.
